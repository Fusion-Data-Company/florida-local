Build this as my initial prototype

Copy-paste this component to /components/ui folder:
```tsx
revolution-hero.tsx
"use client"

import type React from "react"

import { useEffect, useRef, useState } from "react"
import { gsap } from "gsap"

const vertexShader = `
  attribute vec4 position;
  void main() {
    gl_Position = position;
  }
`

const fragmentShader = `
  precision mediump float;
  uniform float u_time;
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_intensity;
  
  // Advanced noise functions
  vec3 hash3(vec2 p) {
    vec3 q = vec3(dot(p, vec2(127.1, 311.7)), 
                  dot(p, vec2(269.5, 183.3)), 
                  dot(p, vec2(419.2, 371.9)));
    return fract(sin(q) * 43758.5453);
  }
  
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0); // Improved smoothstep
    return mix(mix(dot(hash3(i + vec2(0.0,0.0)).xy, f - vec2(0.0,0.0)), 
                   dot(hash3(i + vec2(1.0,0.0)).xy, f - vec2(1.0,0.0)), u.x),
               mix(dot(hash3(i + vec2(0.0,1.0)).xy, f - vec2(0.0,1.0)), 
                   dot(hash3(i + vec2(1.0,1.0)).xy, f - vec2(1.0,1.0)), u.x), u.y);
  }
  
  float fbm(vec2 p, int octaves) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 0.25;
    
    for(int i = 0; i < 10; i++) {
      if(i >= octaves) break;
      value += amplitude * noise(p * frequency);
      amplitude *= 0.52;
      frequency *= 1.13;
    }
    return value;
  }
  
  // Smooth voronoi
  float voronoi(vec2 p) {
    vec2 n = floor(p);
    vec2 f = fract(p);
    float md = 50.0;
    
    for(int i = -2; i <= 2; i++) {
      for(int j = -2; j <= 2; j++) {
        vec2 g = vec2(i, j);
        vec2 o = hash3(n + g).xy;
        o = 0.5 + 0.41 * sin(u_time * 1.5 + 6.28 * o);
        vec2 r = g + o - f;
        float d = dot(r, r);
        md = min(md, d);
      }
    }
    return sqrt(md);
  }
  
  // Smooth plasma
  float plasma(vec2 p, float time) {
    float a = sin(p.x * 8.0 + time * 2.0);
    float b = sin(p.y * 8.0 + time * 1.7);
    float c = sin((p.x + p.y) * 6.0 + time * 1.3);
    float d = sin(sqrt(p.x * p.x + p.y * p.y) * 8.0 + time * 2.3);
    return (a + b + c + d) * 0.5;
  }
  
  // Curl noise for fluid motion
  vec2 curl(vec2 p, float time) {
    float eps = 0.5;
    float n1 = fbm(p + vec2(eps, 0.0), 6);
    float n2 = fbm(p - vec2(eps, 0.0), 6);
    float n3 = fbm(p + vec2(0.0, eps), 6);
    float n4 = fbm(p - vec2(0.0, eps), 6);
    
    return vec2((n3 - n4) / (2.0 * eps), (n2 - n1) / (2.0 * eps));
  }

  // Film grain
  float grain(vec2 uv, float time) {
    vec2 seed = uv * time;
    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);
  }
  
  void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    vec2 st = (uv - 0.5) * 2.0;
    st.x *= u_resolution.x / u_resolution.y;
    
    float time = u_time * 0.25; // Reduced from 0.4 for smoother animation
    
    // Fluid motion using curl noise
    vec2 curlForce = curl(st * 2.0, time) * 0.6;
    vec2 flowField = st + curlForce;
    
    // Multiple smooth distortion layers
    float dist1 = fbm(flowField * 1.5 + time * 1.2, 8) * 0.4;
    float dist2 = fbm(flowField * 2.3 - time * 0.8, 6) * 0.3;
    float dist3 = fbm(flowField * 3.1 + time * 1.8, 4) * 0.2;
    float dist4 = fbm(flowField * 4.7 - time * 1.1, 3) * 0.15;
    
    // Smooth voronoi cellular structure
    float cells = voronoi(flowField * 2.5 + time * 0.5);
    cells = smoothstep(0.1, 0.7, cells);
    
    // Enhanced plasma effect
    float plasmaEffect = plasma(flowField + vec2(dist1, dist2), time * 1.5) * 0.2;
    
    // Combined smooth distortion
    float totalDist = dist1 + dist2 + dist3 + dist4 + plasmaEffect;
    
    // Smooth vertical streaks with multiple frequencies
    float streak1 = sin((st.x + totalDist) * 15.0 + time * 3.0) * 0.5 + 0.5;
    float streak2 = sin((st.x + totalDist * 0.7) * 25.0 - time * 2.0) * 0.5 + 0.5;
    float streak3 = sin((st.x + totalDist * 1.3) * 35.0 + time * 4.0) * 0.5 + 0.5;
    
    // Smooth power curves for streaks
    streak1 = smoothstep(0.3, 0.7, streak1);
    streak2 = smoothstep(0.2, 0.8, streak2);
    streak3 = smoothstep(0.4, 0.6, streak3);
    
    float combinedStreaks = streak1 * 0.6 + streak2 * 0.4 + streak3 * 0.5;
    
    // Multiple smooth flowing shapes
    float shape1 = 1.0 - abs(st.x + totalDist * 0.6);
    float shape2 = 1.0 - abs(st.x + totalDist * 0.4 + sin(st.y * 3.0 + time) * 0.15);
    float shape3 = 1.0 - abs(st.x + totalDist * 0.8 + cos(st.y * 2.0 - time) * 0.1);
    
    shape1 = smoothstep(0.0, 1.0, shape1);
    shape2 = smoothstep(0.1, 0.9, shape2);
    shape3 = smoothstep(0.2, 0.8, shape3);
    
    float finalShape = max(shape1 * 0.8, max(shape2 * 0.6, shape3 * 0.4));
    
    // Enhanced dramatic color palette
    vec3 color1 = vec3(1.0, 0.1, 0.6);   // Hot pink
    vec3 color2 = vec3(1.0, 0.3, 0.1);   // Electric orange
    vec3 color3 = vec3(0.9, 0.1, 1.0);   // Electric purple
    vec3 color4 = vec3(0.1, 0.5, 1.0);   // Electric blue
    vec3 color5 = vec3(0.1, 1.0, 0.9);   // Electric cyan
    vec3 color6 = vec3(0.3, 0.1, 0.9);   // Deep purple
    vec3 color7 = vec3(1.0, 0.8, 0.1);   // Electric yellow
    
    // Smooth color transitions
    float gradient = 1.0 - uv.y;
    float colorNoise = fbm(flowField * 3.0 + time * 0.5, 4) * 0.5 + 0.5;
    float colorShift = sin(time * 1.5 + st.y * 2.0) * 0.5 + 0.5;
    
    vec3 finalColor;
    
    // Smooth multi-layer color blending
    float t1 = smoothstep(0.85, 1.0, gradient);
    float t2 = smoothstep(0.7, 0.85, gradient);
    float t3 = smoothstep(0.5, 0.7, gradient);
    float t4 = smoothstep(0.3, 0.5, gradient);
    float t5 = smoothstep(0.15, 0.3, gradient);
    float t6 = smoothstep(0.0, 0.15, gradient);
    
    finalColor = mix(color6, color7, t6);
    finalColor = mix(finalColor, color5, t5);
    finalColor = mix(finalColor, color4, t4);
    finalColor = mix(finalColor, color3, t3);
    finalColor = mix(finalColor, color2, t2);
    finalColor = mix(finalColor, color1, t1);
    
    // Smooth color variations
    finalColor = mix(finalColor, color1, colorNoise * 0.82);
    finalColor = mix(finalColor, color5, colorShift * 0.5);
    
    // Enhanced chromatic aberration
    vec2 aberration = curlForce * 0.02;
    vec3 aberrationColor = finalColor;
    aberrationColor.r = mix(finalColor.r, color1.r, length(aberration) * 2.0);
    aberrationColor.b = mix(finalColor.b, color4.b, length(aberration) * 1.5);
    aberrationColor.g = mix(finalColor.g, color5.g, length(aberration) * 1.2);
    
    // Smooth energy pulses
    float pulse1 = sin(time * 3.0 + st.y * 6.0) * 0.5 + 0.5;
    float pulse2 = sin(time * 4.5 - st.y * 8.0) * 0.5 + 0.5;
    float energyPulse = smoothstep(0.3, 0.7, pulse1 * pulse2);
    
    // Apply all effects smoothly
    float intensity = finalShape * combinedStreaks * (1.0 + energyPulse * 0.4);
    intensity *= (1.0 + cells * 0.2);
    intensity *= u_intensity; // Global intensity control
    
    // Enhanced mouse interaction
    vec2 mouse = u_mouse / u_resolution.xy;
    mouse = (mouse - 0.5) * 2.0;
    mouse.x *= u_resolution.x / u_resolution.y;
    
    float mouseInfluence = 1.0 - length(st - mouse) * 0.6;
    mouseInfluence = max(0.0, mouseInfluence);
    mouseInfluence = smoothstep(0.0, 1.0, mouseInfluence);
    
    intensity += mouseInfluence * 0.6;
    aberrationColor = mix(aberrationColor, color1, 0.3);
    
    // Final color application with post-processing
    vec3 result = aberrationColor * intensity;
    
    // Bloom effect
    float bloom = smoothstep(0.4, 1.0, intensity) * 0.54;
    result += bloom * finalColor;
    
    // Color grading
    result = pow(result, vec3(0.85)); // Gamma correction
    result = mix(result, result * result, 0.2); // Contrast boost
    
    // Vignette effect
    float vignette = 1.0 - length(uv - 0.5) * 0.85;
    vignette = smoothstep(0.2, 1.0, vignette);
    
    // Enhanced background with subtle color
    vec3 bgColor = vec3(0.02, 0.01, 0.12) + finalColor * 0.03;
    result = mix(bgColor, result, smoothstep(0.0, 0.4, intensity));
    result *= vignette;
    
    // Final saturation and brightness
    result = mix(vec3(dot(result, vec3(0.299, 0.587, 0.114))), result, 1.3);

    // Film grain effect
    float grainAmount = 0.11;
    float grainValue = grain(uv, time * 0.5) * 2.0 - 1.0;
    result += grainValue * grainAmount;

    // Enhanced chromatic aberration
    vec2 aberrationOffset = (uv - 0.5) * 0.2;
    //result.r = mix(result.r, texture2D(u_texture, uv + aberrationOffset).r, 0.3);
    //result.b = mix(result.b, texture2D(u_texture, uv - aberrationOffset).b, 0.3);

    // Subtle scanlines
    float scanline = sin(uv.y * u_resolution.y * 2.0) * 0.04;
    result += scanline;
    
    gl_FragColor = vec4(result, 1.0);
  }
`

interface NavLinkProps {
  children: React.ReactNode
  href: string
  gradient: string
  index: number
}

function NavLink({ children, href, gradient, index }: NavLinkProps) {
  const linkRef = useRef<HTMLAnchorElement>(null)
  const [isHovered, setIsHovered] = useState(false)

  useEffect(() => {
    const link = linkRef.current
    if (!link) return

    const handleMouseEnter = () => {
      setIsHovered(true)
      gsap.to(link, {
        scale: 1.05, // Reduced from 1.1
        rotationX: -2, // Reduced from -5
        z: 20, // Reduced from 50
        duration: 0.6, // Increased from 0.4
        ease: "power3.out", // Changed from "power2.out"
      })

      gsap.to(link, {
        textShadow: "0 5px 20px rgba(255,255,255,0.2)", // Reduced intensity
        duration: 0.5, // Increased from 0.3
        ease: "power3.out",
      })
    }

    const handleMouseLeave = () => {
      setIsHovered(false)
      gsap.to(link, {
        scale: 1,
        rotationX: 0,
        z: 0,
        duration: 0.6, // Increased from 0.4
        ease: "power3.out",
      })

      gsap.to(link, {
        textShadow: "0 0 0px rgba(255,255,255,0)",
        duration: 0.5, // Increased from 0.3
        ease: "power3.out",
      })
    }

    link.addEventListener("mouseenter", handleMouseEnter)
    link.addEventListener("mouseleave", handleMouseLeave)

    return () => {
      link.removeEventListener("mouseenter", handleMouseEnter)
      link.removeEventListener("mouseleave", handleMouseLeave)
    }
  }, [])

  return (
    <a
      ref={linkRef}
      href={href}
      className={`block mb-2 text-4xl md:text-6xl lg:text-8xl font-black leading-tight cursor-pointer transition-all duration-300 transform-gpu perspective-1000 ${
        isHovered ? "z-10" : ""
      }`}
      style={{
        background: gradient,
        WebkitBackgroundClip: "text",
        backgroundClip: "text",
        color: "transparent",
        filter: isHovered ? "brightness(1.2) saturate(1.3)" : "brightness(1) saturate(1)",
      }}
    >
      {children}
    </a>
  )
}

export default function WebGLHero() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const heroTextRef = useRef<HTMLDivElement>(null)
  const navRef = useRef<HTMLDivElement>(null)
  const ctaRef = useRef<HTMLDivElement>(null)
  const mouseRef = useRef({ x: 0, y: 0 })
  const glRef = useRef<WebGLRenderingContext | null>(null)
  const programRef = useRef<WebGLProgram | null>(null)
  const bufferRef = useRef<WebGLBuffer | null>(null)
  const positionLocationRef = useRef<number>(0)
  const timeLocationRef = useRef<WebGLUniformLocation | null>(null)
  const resolutionLocationRef = useRef<WebGLUniformLocation | null>(null)
  const mouseLocationRef = useRef<WebGLUniformLocation | null>(null)
  const intensityLocationRef = useRef<WebGLUniformLocation | null>(null)
  const startTimeRef = useRef<number>(Date.now())
  const [globalIntensity, setGlobalIntensity] = useState(1.0)

  const navLinks = [
    { text: "IGNITE", href: "/ignite", gradient: "linear-gradient(135deg, #ffffff, #cccccc)" },
    { text: "TRANSFORM", href: "/transform", gradient: "linear-gradient(135deg, #ffffff, #cccccc)" },
    { text: "DOMINATE", href: "/dominate", gradient: "linear-gradient(135deg, #ffffff, #cccccc)" },
    { text: "EVOLVE", href: "/evolve", gradient: "linear-gradient(135deg, #ffffff, #cccccc)" },
  ]

  const createShader = (type: number, source: string) => {
    const gl = glRef.current
    if (!gl) return null

    const shader = gl.createShader(type)
    if (!shader) return null

    gl.shaderSource(shader, source)
    gl.compileShader(shader)

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader compile error:", gl.getShaderInfoLog(shader))
      gl.deleteShader(shader)
      return null
    }

    return shader
  }

  const initGL = () => {
    const canvas = canvasRef.current
    if (!canvas) return

    const gl = canvas.getContext("webgl")
    if (!gl) return

    glRef.current = gl

    // Create shader program
    const vertShader = createShader(gl.VERTEX_SHADER, vertexShader)
    const fragShader = createShader(gl.FRAGMENT_SHADER, fragmentShader)

    if (!vertShader || !fragShader) return

    const program = gl.createProgram()
    if (!program) return

    gl.attachShader(program, vertShader)
    gl.attachShader(program, fragShader)
    gl.linkProgram(program)

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Program link error:", gl.getProgramInfoLog(program))
      return
    }

    programRef.current = program

    // Create buffer
    const buffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW)

    bufferRef.current = buffer

    // Get uniform locations
    const positionLocation = gl.getAttribLocation(program, "position")
    positionLocationRef.current = positionLocation
    const timeLocation = gl.getUniformLocation(program, "u_time")
    timeLocationRef.current = timeLocation
    const resolutionLocation = gl.getUniformLocation(program, "u_resolution")
    resolutionLocationRef.current = resolutionLocation
    const mouseLocation = gl.getUniformLocation(program, "u_mouse")
    mouseLocationRef.current = mouseLocation
    const intensityLocation = gl.getUniformLocation(program, "u_intensity")
    intensityLocationRef.current = intensityLocation

    // Resize canvas
    const resizeCanvas = () => {
      const rect = canvas.getBoundingClientRect()
      canvas.width = rect.width * window.devicePixelRatio
      canvas.height = rect.height * window.devicePixelRatio
      gl.viewport(0, 0, canvas.width, canvas.height)
    }

    resizeCanvas()
    window.addEventListener("resize", resizeCanvas)

    // Mouse tracking
    const handleMouseMove = (e: MouseEvent) => {
      const rect = canvas.getBoundingClientRect()
      mouseRef.current.x = (e.clientX - rect.left) * window.devicePixelRatio
      mouseRef.current.y = (rect.height - (e.clientY - rect.top)) * window.devicePixelRatio

      // Smoother intensity changes
      gsap.to(
        { intensity: globalIntensity },
        {
          intensity: 1.15, // Reduced from 1.2
          duration: 0.3,
          ease: "power2.out",
          onUpdate: function () {
            setGlobalIntensity(this.targets()[0].intensity)
          },
        },
      )

      // Smooth decay back to normal
      gsap.to(
        { intensity: 1.15 },
        {
          intensity: 1.0,
          duration: 1.0, // Longer decay
          delay: 0.1,
          ease: "power2.out",
          onUpdate: function () {
            setGlobalIntensity(this.targets()[0].intensity)
          },
        },
      )
    }

    canvas.addEventListener("mousemove", handleMouseMove)
  }

  const animate = () => {
    const time = (Date.now() - startTimeRef.current) * 0.001
    const gl = glRef.current
    const program = programRef.current
    const buffer = bufferRef.current
    const positionLocation = positionLocationRef.current
    const timeLocation = timeLocationRef.current
    const resolutionLocation = resolutionLocationRef.current
    const mouseLocation = mouseLocationRef.current
    const intensityLocation = intensityLocationRef.current

    if (gl && program && buffer && timeLocation && resolutionLocation && mouseLocation && intensityLocation) {
      gl.useProgram(program)
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
      gl.enableVertexAttribArray(positionLocation)
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0)

      gl.uniform1f(timeLocation, time)
      gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height)
      gl.uniform2f(mouseLocation, mouseRef.current.x, mouseRef.current.y)
      gl.uniform1f(intensityLocation, globalIntensity)

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    }
    requestAnimationFrame(animate)
  }

  useEffect(() => {
    initGL()
  }, [])

  useEffect(() => {
    const animateFrame = () => {
      const time = (Date.now() - startTimeRef.current) * 0.001
      const gl = glRef.current
      const program = programRef.current
      const buffer = bufferRef.current
      const positionLocation = positionLocationRef.current
      const timeLocation = timeLocationRef.current
      const resolutionLocation = resolutionLocationRef.current
      const mouseLocation = mouseLocationRef.current
      const intensityLocation = intensityLocationRef.current

      if (gl && program && buffer && timeLocation && resolutionLocation && mouseLocation && intensityLocation) {
        gl.useProgram(program)
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.enableVertexAttribArray(positionLocation)
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0)

        gl.uniform1f(timeLocation, time)
        gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height)
        gl.uniform2f(mouseLocation, mouseRef.current.x, mouseRef.current.y)
        gl.uniform1f(intensityLocation, globalIntensity)

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
      }
      requestAnimationFrame(animateFrame)
    }

    animateFrame()
  }, [globalIntensity])

  return (
    <section className="relative h-screen w-full overflow-hidden bg-black">
      <canvas ref={canvasRef} className="absolute inset-0 w-full h-full" style={{ background: "#000510" }} />

      <div className="relative z-10 h-full flex flex-col justify-between p-8 md:p-12">
        {/* Top text */}
        <div ref={heroTextRef} className="text-left">
          <p className="text-gray-300 text-sm md:text-base uppercase tracking-wider font-bold">
            {"Break the boundaries,"}
          </p>
          <p className="text-gray-300 text-sm md:text-base uppercase tracking-wider font-bold">
            {"Unleash your potential"}
          </p>
        </div>

        {/* Bottom content */}
        <div className="flex flex-col md:flex-row justify-between items-end">
          <nav ref={navRef} className="text-left mb-8 md:mb-0">
            {navLinks.map((link, index) => (
              <NavLink key={link.text} href={link.href} gradient={link.gradient} index={index}>
                {link.text}
              </NavLink>
            ))}
          </nav>

          <div ref={ctaRef} className="text-right text-gray-300 text-xs md:text-sm max-w-xs">
            <p className="mb-2 font-semibold text-white">{"The future belongs to those"}</p>
            <p className="mb-2 font-semibold text-white">{"who dare to dream bigger"}</p>
            <p className="mb-4 text-gray-400">{"Every revolution starts with a single spark"}</p>
            <p className="mb-2 text-gray-400">{"Your moment is now."}</p>
            <p className="mb-2 text-gray-400">{"Your power is limitless."}</p>
            <p className="mb-6 text-gray-400">{"Your impact will be legendary."}</p>
            <p className="text-transparent bg-gradient-to-r from-pink-400 to-cyan-400 bg-clip-text font-bold">
              www.revolution.com
            </p>
          </div>
        </div>
      </div>
    </section>
  )
}

export const Component = () => {
  return (
    <WebGLHero />
  )
}

demo.tsx
import { Component } from "@/components/ui/revolution-hero";

export default function DemoOne() {
  return <Component />;
}

```

Install these NPM dependencies:
```bash
gsap
```


Additional important context to consider: Alright, Boss—here’s the rulebook you hand to Magic MCP so it stops spitting out “starter kit” junk and starts delivering Apple-showcase elements on command. Copy-paste this as the system prompt (or drop it into your “style rules” block for Magic MCP). It’s opinionated, airtight, and production-grade.

⸻

Magic MCP — “Apple-Level Styling” Rulebook (System Prompt)

You are Magic MCP – Elite UI Fabricator. Your job is to generate UI elements that look like they’re launching on Apple.com tomorrow morning: minimal, cinematic, tactile, premium. You produce fully-styled code, not bare markup. Prefer React + Tailwind; if Tailwind isn’t available, emit vanilla CSS with design tokens.

0) Output Contract
	•	Always output ready-to-ship code: one self-contained file (React component) with all necessary styles (Tailwind classes or an appended <style> block for vanilla CSS).
	•	No TODOs. No placeholders. Provide sane defaults and sample copy.
	•	Include hover/focus/active/disabled states, motion, dark mode, and responsive behaviors.
	•	Ensure WCAG AA contrast and prefers-reduced-motion support.

1) Design Language (Apple-esque)
	•	Minimal & luxurious: generous whitespace, precise alignment, clean grid, restrained color with subtle accents.
	•	Materials: glassmorphism (frosted glass), soft specular highlights, delicate borders (1px/0.5px hairlines), layered depth.
	•	Type: system-first stack, smooth tracking, nuanced weights; use a modular scale.
	•	Motion: micro-interactions under 250ms, frictionless easing (cubic-bezier(0.22, 1, 0.36, 1)), spring-like feel where appropriate.

2) Design Tokens (use or generate)

// Use as Tailwind CSS variables via :root or inline styles
:root {
  --bg:        16 16 18;     /* near-black charcoal */
  --bg-2:      22 22 24;
  --surface:   28 28 32;
  --brand:     180 230 255;  /* ice blue accent */
  --ink:       240 240 245;  /* high contrast text */
  --muted:     170 170 178;  /* secondary text */
  --border:    255 255 255 / 0.08;
  --ring:      180 230 255 / 0.6;

  --radius: 1.25rem;         /* 2xl */
  --shadow-1: 0 1px 1px rgb(0 0 0 / 0.3), 0 2px 6px rgb(0 0 0 / 0.25);
  --shadow-2: 0 12px 30px rgb(0 0 0 / 0.35);
  --blur: 18px;              /* glass blur */
}

3) Glassmorphism Recipe (standardize)
	•	Backdrop: backdrop-blur-[var(--blur)] + translucent layer bg-white/6 (light) or bg-white/4 (dark).
	•	Border: border border-white/10 + inner hairline: shadow-[inset_0_1px_0_rgba(255,255,255,.12)].
	•	Shadow: shadow-[var(--shadow-1)] hover:shadow-[var(--shadow-2)].
	•	Radii: rounded-[var(--radius)].

4) Background Textures & Effects (choose 1–2 max)
	•	Subtle noise (data-URI) with mix-blend-overlay at 2–4% opacity.
	•	Soft radial gradient vignette centered on hero content.
	•	Animated aurora (very subtle): slow 10–20s CSS keyframe on blurred gradient blobs.
	•	Grid/Hairline pattern: linear-gradient with 1px lines at 6–12% opacity.

5) Motion & Interaction
	•	Base transition: transition-all duration-200 ease-[cubic-bezier(0.22,1,0.36,1)].
	•	Hover: elevate +1–2px, increase backdrop blur by 2–4px, accent ring.
	•	Active: compress by 1px, increase inner highlight.
	•	Focus visible: ring-2 ring-[color:var(--ring)] ring-offset-2 ring-offset-[rgb(var(--bg))] outline-none.
	•	Respect prefers-reduced-motion: disable transforms and long animations.

6) Responsiveness & Layout
	•	Mobile-first. Key breakpoints: sm(640) md(768) lg(1024) xl(1280) 2xl(1536).
	•	Use fluid type/spacing via clamp for hero headings and paddings.
	•	Never overflow: guard long strings, add min-w-0, and implement text-balance.

7) Accessibility
	•	All interactive elements are <button>/<a> with ARIA labels where needed.
	•	Hit area ≥ 44×44px, keyboard navigable, visible focus rings.
	•	Color contrast AA minimum; use an underlay if needed to hit ratios.

8) Performance Guardrails
	•	No heavy images; prefer CSS gradients/noise. If image used, provide loading="lazy" and sizes.
	•	Limit blur layers (1–2). Avoid stacking filters excessively.
	•	Ship as a single component unless asked otherwise.

⸻

9) Component Blueprints (emit like this by default)

A) Glass Button (Primary)

export default function GlassButton({
  children = "Get Started",
  onClick,
  as = "button",
}: { children?: React.ReactNode; onClick?: () => void; as?: "button" | "a" }) {
  const Base = as === "a" ? "a" : "button";
  return (
    <Base
      onClick={onClick}
      className={[
        "group inline-flex items-center justify-center px-5 py-3",
        "rounded-[var(--radius)] border border-white/10",
        "bg-white/10 hover:bg-white/12 active:bg-white/8",
        "backdrop-blur-[var(--blur)] shadow-[var(--shadow-1)] hover:shadow-[var(--shadow-2)]",
        "text-[15px] font-medium text-[rgb(var(--ink))] tracking-[0.02em]",
        "transition-all duration-200 ease-[cubic-bezier(0.22,1,0.36,1)]",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[color:var(--ring)] focus-visible:ring-offset-2 focus-visible:ring-offset-[rgb(var(--bg))]",
        "disabled:opacity-60 disabled:pointer-events-none",
      ].join(" ")}
    >
      <span className="relative">
        <span className="absolute inset-0 rounded-[var(--radius)] shadow-[inset_0_1px_0_rgba(255,255,255,.35)] pointer-events-none" />
        {children}
      </span>
      <span className="ml-2 size-2.5 rounded-full bg-[color:var(--ring)] opacity-70 group-hover:opacity-100 transition" />
    </Base>
  );
}

B) Showcase Card

export function ShowcaseCard({
  title = "Pro-grade Performance",
  body = "Experience fluid UI with precision micro-interactions and tactile depth.",
  cta = "Explore",
}: { title?: string; body?: string; cta?: string }) {
  return (
    <div
      className={[
        "relative isolate overflow-hidden",
        "rounded-[var(--radius)] border border-white/10",
        "bg-white/6 backdrop-blur-[var(--blur)]",
        "shadow-[var(--shadow-1)] hover:shadow-[var(--shadow-2)]",
        "transition-all duration-200 ease-[cubic-bezier(0.22,1,0.36,1)]",
        "p-6 sm:p-8 lg:p-10",
      ].join(" ")}
    >
      {/* hairline highlight */}
      <div className="pointer-events-none absolute inset-0 rounded-[var(--radius)] shadow-[inset_0_1px_0_rgba(255,255,255,.12)]" />
      {/* soft radial spotlight */}
      <div className="pointer-events-none absolute -inset-32 opacity-[.12] blur-3xl bg-[radial-gradient(60%_60%_at_50%_10%,rgba(180,230,255,.7),transparent_60%)]" />
      <h3 className="text-balance text-2xl sm:text-3xl lg:text-4xl font-semibold text-[rgb(var(--ink))]">
        {title}
      </h3>
      <p className="mt-3 max-w-prose text-[15px] leading-7 text-[rgb(var(--muted))]">{body}</p>
      <div className="mt-6">
        <a
          href="#"
          className="inline-flex items-center gap-2 px-4 py-2 rounded-xl border border-white/10 bg-white/8 hover:bg-white/12 backdrop-blur-md text-[rgb(var(--ink))] transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[color:var(--ring)]"
          aria-label={`${cta}: ${title}`}
        >
          {cta}
          <svg width="14" height="14" viewBox="0 0 24 24" className="opacity-80 group-hover:translate-x-0.5 transition">
            <path fill="currentColor" d="M13 5l7 7-7 7v-4H4v-6h9V5z" />
          </svg>
        </a>
      </div>
    </div>
  );
}

C) Hero Section (Radial + Aurora)

export function PremiumHero() {
  return (
    <section className="relative overflow-hidden">
      {/* background */}
      <div className="absolute inset-0 -z-10 bg-[rgb(var(--bg))]" />
      <div className="absolute inset-0 -z-10 opacity-[.08] bg-[radial-gradient(80%_60%_at_50%_10%,rgba(180,230,255,.4),transparent_60%)]" />
      {/* aurora blobs */}
      <div className="absolute -top-40 -left-40 size-[40rem] rounded-full blur-3xl opacity-15 animate-[float_18s_ease-in-out_infinite] bg-[conic-gradient(from_90deg,rgba(180,230,255,.35),transparent_55%)]" />
      <div className="absolute -bottom-40 -right-40 size-[42rem] rounded-full blur-3xl opacity-15 animate-[float2_22s_ease-in-out_infinite] bg-[conic-gradient(from_210deg,rgba(255,255,255,.2),transparent_60%)]" />

      <div className="mx-auto max-w-6xl px-6 py-24 sm:py-28 lg:py-36">
        <div className="max-w-3xl">
          <h1 className="text-balance text-4xl sm:text-6xl lg:text-7xl font-semibold leading-tight text-[rgb(var(--ink))]">
            Crafted to Feel Effortless.
          </h1>
          <p className="mt-5 text-[17px] leading-8 text-[rgb(var(--muted))]">
            Cinematic depth, precise motion, and glass surfaces that breathe. Built for serious products.
          </p>
          <div className="mt-8 flex flex-wrap gap-3">
            <GlassButton>Start Now</GlassButton>
            <GlassButton>See Demos</GlassButton>
          </div>
        </div>
      </div>

      <style jsx global>{`
        @keyframes float { 0%{transform:translateY(0)} 50%{transform:translateY(-10px)} 100%{transform:translateY(0)} }
        @keyframes float2 { 0%{transform:translateY(0)} 50%{transform:translateY(12px)} 100%{transform:translateY(0)} }
        @media (prefers-reduced-motion: reduce) {
          .animate-\$begin:math:display$float_18s_ease-in-out_infinite\\$end:math:display$,
          .animate-\$begin:math:display$float2_22s_ease-in-out_infinite\\$end:math:display$ { animation: none; }
        }
      `}</style>
    </section>
  );
}

D) Utility: Subtle Noise & Grid (vanilla, inject once)

/* Add once at app root if Tailwind unavailable */
:root { color-scheme: dark; }
.body-bg {
  background: rgb(var(--bg));
  position: relative;
}
.body-bg::before { /* noise */
  content: "";
  position: absolute; inset: 0; pointer-events: none; opacity: .025;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='140' height='140' viewBox='0 0 140 140'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/></filter><rect width='100%' height='100%' filter='url(%23n)' opacity='.8'/></svg>");
}
.body-bg::after { /* grid hairlines */
  content: "";
  position: absolute; inset: 0; pointer-events: none; opacity: .06;
  background-image:
    linear-gradient(to right, rgba(255,255,255,.08) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255,255,255,.08) 1px, transparent 1px);
  background-size: 48px 48px;
}


⸻

10) Do / Don’t
	•	Do: glass, soft highlights, hairline borders, subtle gradients, precise motion, AA contrast, real focus rings, responsive clamps.
	•	Don’t: heavy drop shadows, neon overload, busy textures, default HTML styles, generic gray boxes, or motion that fights content.

11) When Given a Bare Element…

If the user asks for “a button”, you must return the Glass Button above (full styling). If asked for “a card,” return Showcase Card. For “hero,” return PremiumHero. Never reply with minimal markup.

⸻

Prompt Add-On (one-liner you can reuse)

Style mandate: “Apply the ‘Apple-Level Styling’ Rulebook: glassmorphism, hairline borders, radial spotlight, subtle noise, AA contrast, responsive clamps, micro-interactions, and reduced-motion support. Deliver a single React + Tailwind component with no placeholders.”



User Additional Context:
Use the text of the current site to replace the hero section on the discover page and make the background the same as the demo and do not edit it. 
Remember: For the code above, not change the component's code unless it's required to integrate or the user asks you to.
IMPORTANT: The code above contains the initial prototype desired by the user. Create all mentioned files in full, without abbreviations. Do not use placeholders like "insert the rest of the code here" – output every line of code exactly as it is, so it can be copied and pasted directly into the project.