var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/monitoring.ts
import * as Sentry from "@sentry/node";
import { nodeProfilingIntegration } from "@sentry/profiling-node";
import { PostHog } from "posthog-node";
import winston from "winston";
function initSentry(app) {
  if (!process.env.SENTRY_DSN) {
    console.log("\u26A0\uFE0F Sentry DSN not configured - error tracking disabled");
    return;
  }
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    integrations: [
      // Enable HTTP calls tracing
      Sentry.httpIntegration(),
      // Enable Express.js middleware tracing
      Sentry.expressIntegration(),
      // Enable profiling
      nodeProfilingIntegration()
    ],
    // Performance Monitoring
    tracesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1,
    profilesSampleRate: process.env.NODE_ENV === "production" ? 0.1 : 1,
    environment: process.env.NODE_ENV || "development",
    beforeSend(event, hint) {
      if (event.request) {
        delete event.request.cookies;
        delete event.request.headers?.authorization;
      }
      return event;
    }
  });
  console.log("\u2705 Sentry initialized");
}
function initPostHog() {
  if (!process.env.POSTHOG_KEY) {
    console.log("\u26A0\uFE0F PostHog key not configured - analytics disabled");
    return;
  }
  posthog = new PostHog(process.env.POSTHOG_KEY, {
    host: process.env.POSTHOG_HOST || "https://app.posthog.com",
    flushAt: 20,
    flushInterval: 1e4
  });
  console.log("\u2705 PostHog initialized");
}
function trackEvent(distinctId, event, properties) {
  if (posthog) {
    posthog.capture({
      distinctId,
      event,
      properties: {
        ...properties,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        environment: process.env.NODE_ENV
      }
    });
  }
}
function requestLogger(req, res, next) {
  const start = Date.now();
  logger.info("Request", {
    method: req.method,
    path: req.path,
    query: req.query,
    ip: req.ip,
    userAgent: req.get("user-agent"),
    userId: req.user?.claims?.sub
  });
  const originalSend = res.send;
  res.send = function(data) {
    const duration = Date.now() - start;
    logger.info("Response", {
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      duration,
      userId: req.user?.claims?.sub
    });
    trackEvent(req.user?.claims?.sub || "anonymous", "api_request", {
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      duration
    });
    return originalSend.call(this, data);
  };
  next();
}
function setupErrorHandling(app) {
  app.use(Sentry.expressErrorHandler({
    shouldHandleError(error) {
      if (error.status && error.status >= 400) {
        return true;
      }
      return true;
    }
  }));
  app.use((err, req, res, next) => {
    logger.error("Unhandled error", {
      error: err.message,
      stack: err.stack,
      path: req.path,
      method: req.method,
      userId: req.user?.claims?.sub
    });
    res.status(err.status || 500).json({
      message: err.message || "Internal server error",
      ...process.env.NODE_ENV === "development" && { stack: err.stack }
    });
  });
}
var posthog, logger;
var init_monitoring = __esm({
  "server/monitoring.ts"() {
    "use strict";
    posthog = null;
    logger = winston.createLogger({
      level: process.env.LOG_LEVEL || "info",
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: {
        service: "florida-elite",
        environment: process.env.NODE_ENV
      },
      transports: [
        // Console transport with colorized output
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        })
      ]
    });
    if (process.env.NODE_ENV === "production") {
      logger.add(
        new winston.transports.File({
          filename: "logs/error.log",
          level: "error",
          maxsize: 5242880,
          // 5MB
          maxFiles: 5
        })
      );
      logger.add(
        new winston.transports.File({
          filename: "logs/combined.log",
          maxsize: 5242880,
          // 5MB
          maxFiles: 5
        })
      );
    }
  }
});

// server/config.ts
function validateAndLoadConfig() {
  logger.info("\u{1F527} Loading and validating configuration...");
  const errors = [];
  const nodeEnv = process.env.NODE_ENV || "development";
  const isProduction = nodeEnv === "production" || process.env.REPLIT_DEPLOYMENT === "1";
  const isDevelopment = !isProduction;
  logger.info(`\u{1F4CD} Environment: ${nodeEnv} (isProduction: ${isProduction})`);
  if (!process.env.DATABASE_URL) {
    errors.push("DATABASE_URL environment variable is required");
  }
  if (!process.env.SESSION_SECRET) {
    errors.push("SESSION_SECRET environment variable is required");
  }
  if (!process.env.REPL_ID) {
    errors.push("REPL_ID environment variable is required");
  }
  if (isProduction && !process.env.REPLIT_DOMAINS) {
    errors.push("REPLIT_DOMAINS environment variable is required in production");
  }
  if (errors.length > 0) {
    logger.error("\u274C Configuration validation failed:");
    errors.forEach((error) => logger.error(`   - ${error}`));
    throw new Error(`Configuration validation failed: ${errors.join(", ")}`);
  }
  let replitDomains;
  if (process.env.REPLIT_DOMAINS) {
    replitDomains = process.env.REPLIT_DOMAINS.split(",").map((d) => d.trim());
  } else {
    replitDomains = [];
  }
  if (process.env.REPLIT_DEV_DOMAIN) {
    const devDomain = process.env.REPLIT_DEV_DOMAIN.trim();
    if (!replitDomains.includes(devDomain)) {
      replitDomains.push(devDomain);
    }
  }
  if (isDevelopment) {
    if (!replitDomains.includes("localhost")) {
      replitDomains.push("localhost");
    }
    if (!replitDomains.includes("127.0.0.1")) {
      replitDomains.push("127.0.0.1");
    }
  }
  if (replitDomains.length === 0) {
    replitDomains = ["localhost"];
  }
  const config2 = {
    nodeEnv,
    isProduction,
    isDevelopment,
    port: parseInt(process.env.PORT || "5000", 10),
    databaseUrl: process.env.DATABASE_URL,
    sessionSecret: process.env.SESSION_SECRET,
    replitDomains,
    replId: process.env.REPL_ID,
    issuerUrl: process.env.ISSUER_URL || "https://replit.com/oidc",
    redisHost: process.env.REDIS_HOST,
    redisPort: process.env.REDIS_PORT ? parseInt(process.env.REDIS_PORT, 10) : void 0,
    redisPassword: process.env.REDIS_PASSWORD
  };
  logger.info("\u2705 Configuration validated successfully");
  logger.info(`   - Port: ${config2.port}`);
  logger.info(`   - Database: ${config2.databaseUrl ? "\u2713 Configured" : "\u2717 Missing"}`);
  logger.info(`   - Session Secret: ${config2.sessionSecret ? "\u2713 Configured" : "\u2717 Missing"}`);
  logger.info(`   - Replit Domains: ${config2.replitDomains.join(", ")}`);
  logger.info(`   - REPL_ID (OAuth Client ID): ${config2.replId}`);
  logger.info(`   - REPL_ID length: ${config2.replId.length} chars`);
  logger.info(`   - Issuer URL: ${config2.issuerUrl}`);
  logger.info(`   - Redis: ${config2.redisHost ? `\u2713 ${config2.redisHost}:${config2.redisPort}` : "\u2717 Not configured"}`);
  return config2;
}
function initConfig() {
  config = validateAndLoadConfig();
  return config;
}
var config;
var init_config = __esm({
  "server/config.ts"() {
    "use strict";
    init_monitoring();
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  accountLockouts: () => accountLockouts,
  activeSessions: () => activeSessions,
  adCampaigns: () => adCampaigns,
  adCampaignsRelations: () => adCampaignsRelations,
  adImpressions: () => adImpressions,
  adImpressionsRelations: () => adImpressionsRelations,
  adSpots: () => adSpots,
  adSpotsRelations: () => adSpotsRelations,
  adminAuditLogs: () => adminAuditLogs,
  adminRoles: () => adminRoles,
  aiContentTemplates: () => aiContentTemplates,
  aiContentTests: () => aiContentTests,
  aiGeneratedContent: () => aiGeneratedContent,
  aiGeneratedImages: () => aiGeneratedImages,
  aiModerationLog: () => aiModerationLog,
  aiUsageTracking: () => aiUsageTracking,
  analyticsEvents: () => analyticsEvents,
  apiKeys: () => apiKeys,
  apiKeysRelations: () => apiKeysRelations,
  authAuditLogs: () => authAuditLogs,
  blogAnalytics: () => blogAnalytics,
  blogAnalyticsRelations: () => blogAnalyticsRelations,
  blogBookmarks: () => blogBookmarks,
  blogBookmarksRelations: () => blogBookmarksRelations,
  blogCategories: () => blogCategories,
  blogCategoriesRelations: () => blogCategoriesRelations,
  blogComments: () => blogComments,
  blogCommentsRelations: () => blogCommentsRelations,
  blogPostTags: () => blogPostTags,
  blogPostTagsRelations: () => blogPostTagsRelations,
  blogPosts: () => blogPosts,
  blogPostsRelations: () => blogPostsRelations,
  blogReactions: () => blogReactions,
  blogReactionsRelations: () => blogReactionsRelations,
  blogReadingLists: () => blogReadingLists,
  blogReadingListsRelations: () => blogReadingListsRelations,
  blogRevisions: () => blogRevisions,
  blogRevisionsRelations: () => blogRevisionsRelations,
  blogSubscriptions: () => blogSubscriptions,
  blogSubscriptionsRelations: () => blogSubscriptionsRelations,
  blogTags: () => blogTags,
  blogTagsRelations: () => blogTagsRelations,
  businessFollowers: () => businessFollowers,
  businessFollowersRelations: () => businessFollowersRelations,
  businessMetrics: () => businessMetrics,
  businesses: () => businesses,
  businessesMarketingRelations: () => businessesMarketingRelations,
  businessesRelations: () => businessesRelations,
  campaignClicks: () => campaignClicks,
  campaignClicksRelations: () => campaignClicksRelations,
  campaignLinks: () => campaignLinks,
  campaignLinksRelations: () => campaignLinksRelations,
  campaignRecipients: () => campaignRecipients,
  campaignRecipientsRelations: () => campaignRecipientsRelations,
  cartItems: () => cartItems,
  cartItemsRelations: () => cartItemsRelations,
  chatAnalytics: () => chatAnalytics,
  chatConversations: () => chatConversations,
  chatKnowledgeBase: () => chatKnowledgeBase,
  chatMessages: () => chatMessages,
  chatProactiveTriggers: () => chatProactiveTriggers,
  chatQuickActions: () => chatQuickActions,
  chatSessions: () => chatSessions,
  conversionFunnels: () => conversionFunnels,
  customerCohorts: () => customerCohorts,
  customerSegments: () => customerSegments,
  customerSegmentsRelations: () => customerSegmentsRelations,
  dailyMetrics: () => dailyMetrics,
  deviceFingerprints: () => deviceFingerprints,
  engagementMetrics: () => engagementMetrics,
  engagementMetricsRelations: () => engagementMetricsRelations,
  entrepreneurBusinesses: () => entrepreneurBusinesses,
  entrepreneurBusinessesRelations: () => entrepreneurBusinessesRelations,
  entrepreneurs: () => entrepreneurs,
  entrepreneursRelations: () => entrepreneursRelations,
  errorLogs: () => errorLogs,
  failedLoginAttempts: () => failedLoginAttempts,
  geoRestrictions: () => geoRestrictions,
  gmbReviews: () => gmbReviews,
  gmbReviewsRelations: () => gmbReviewsRelations,
  gmbSyncHistory: () => gmbSyncHistory,
  gmbSyncHistoryRelations: () => gmbSyncHistoryRelations,
  gmbTokens: () => gmbTokens,
  gmbTokensRelations: () => gmbTokensRelations,
  insertAIContentTemplateSchema: () => insertAIContentTemplateSchema,
  insertAIContentTestSchema: () => insertAIContentTestSchema,
  insertAIGeneratedContentSchema: () => insertAIGeneratedContentSchema,
  insertAIGeneratedImageSchema: () => insertAIGeneratedImageSchema,
  insertAIModerationLogSchema: () => insertAIModerationLogSchema,
  insertAIUsageTrackingSchema: () => insertAIUsageTrackingSchema,
  insertAdCampaignSchema: () => insertAdCampaignSchema,
  insertAdImpressionSchema: () => insertAdImpressionSchema,
  insertAdSpotSchema: () => insertAdSpotSchema,
  insertAdminAuditLogSchema: () => insertAdminAuditLogSchema,
  insertAdminRoleSchema: () => insertAdminRoleSchema,
  insertAnalyticsEventSchema: () => insertAnalyticsEventSchema,
  insertApiKeySchema: () => insertApiKeySchema,
  insertBlogAnalyticsSchema: () => insertBlogAnalyticsSchema,
  insertBlogBookmarkSchema: () => insertBlogBookmarkSchema,
  insertBlogCategorySchema: () => insertBlogCategorySchema,
  insertBlogCommentSchema: () => insertBlogCommentSchema,
  insertBlogPostSchema: () => insertBlogPostSchema,
  insertBlogPostTagSchema: () => insertBlogPostTagSchema,
  insertBlogReactionSchema: () => insertBlogReactionSchema,
  insertBlogReadingListSchema: () => insertBlogReadingListSchema,
  insertBlogRevisionSchema: () => insertBlogRevisionSchema,
  insertBlogSubscriptionSchema: () => insertBlogSubscriptionSchema,
  insertBlogTagSchema: () => insertBlogTagSchema,
  insertBusinessMetricsSchema: () => insertBusinessMetricsSchema,
  insertBusinessSchema: () => insertBusinessSchema,
  insertCampaignClickSchema: () => insertCampaignClickSchema,
  insertCampaignLinkSchema: () => insertCampaignLinkSchema,
  insertCampaignRecipientSchema: () => insertCampaignRecipientSchema,
  insertCartItemSchema: () => insertCartItemSchema,
  insertChatAnalyticsSchema: () => insertChatAnalyticsSchema,
  insertChatConversationSchema: () => insertChatConversationSchema,
  insertChatKnowledgeBaseSchema: () => insertChatKnowledgeBaseSchema,
  insertChatMessageSchema: () => insertChatMessageSchema,
  insertChatProactiveTriggerSchema: () => insertChatProactiveTriggerSchema,
  insertChatQuickActionSchema: () => insertChatQuickActionSchema,
  insertChatSessionSchema: () => insertChatSessionSchema,
  insertConversionFunnelSchema: () => insertConversionFunnelSchema,
  insertCustomerCohortSchema: () => insertCustomerCohortSchema,
  insertCustomerSegmentSchema: () => insertCustomerSegmentSchema,
  insertDailyMetricsSchema: () => insertDailyMetricsSchema,
  insertDeviceFingerprintSchema: () => insertDeviceFingerprintSchema,
  insertEngagementMetricsSchema: () => insertEngagementMetricsSchema,
  insertEntrepreneurBusinessSchema: () => insertEntrepreneurBusinessSchema,
  insertEntrepreneurSchema: () => insertEntrepreneurSchema,
  insertErrorLogSchema: () => insertErrorLogSchema,
  insertGmbReviewSchema: () => insertGmbReviewSchema,
  insertGmbSyncHistorySchema: () => insertGmbSyncHistorySchema,
  insertGmbTokenSchema: () => insertGmbTokenSchema,
  insertLeadCaptureFormSchema: () => insertLeadCaptureFormSchema,
  insertLeadSubmissionSchema: () => insertLeadSubmissionSchema,
  insertLoyaltyAccountSchema: () => insertLoyaltyAccountSchema,
  insertLoyaltyRuleSchema: () => insertLoyaltyRuleSchema,
  insertLoyaltyTierSchema: () => insertLoyaltyTierSchema,
  insertLoyaltyTransactionSchema: () => insertLoyaltyTransactionSchema,
  insertMarketingCampaignSchema: () => insertMarketingCampaignSchema,
  insertMarketingWorkflowSchema: () => insertMarketingWorkflowSchema,
  insertMessageSchema: () => insertMessageSchema,
  insertOrderItemSchema: () => insertOrderItemSchema,
  insertOrderSchema: () => insertOrderSchema,
  insertPaymentSchema: () => insertPaymentSchema,
  insertPostSchema: () => insertPostSchema,
  insertPremiumAdSlotSchema: () => insertPremiumAdSlotSchema,
  insertPremiumFeatureSchema: () => insertPremiumFeatureSchema,
  insertProductMetricsSchema: () => insertProductMetricsSchema,
  insertProductSchema: () => insertProductSchema,
  insertRateLimitViolationSchema: () => insertRateLimitViolationSchema,
  insertRecentPurchaseSchema: () => insertRecentPurchaseSchema,
  insertReferralSchema: () => insertReferralSchema,
  insertRewardRedemptionSchema: () => insertRewardRedemptionSchema,
  insertRewardSchema: () => insertRewardSchema,
  insertSegmentMemberSchema: () => insertSegmentMemberSchema,
  insertSessionEventSchema: () => insertSessionEventSchema,
  insertSocialAccountSchema: () => insertSocialAccountSchema,
  insertSocialAnalyticsSchema: () => insertSocialAnalyticsSchema,
  insertSocialContentCategorySchema: () => insertSocialContentCategorySchema,
  insertSocialMediaAccountSchema: () => insertSocialMediaAccountSchema,
  insertSocialMediaAnalyticsSchema: () => insertSocialMediaAnalyticsSchema,
  insertSocialMediaAutomationSchema: () => insertSocialMediaAutomationSchema,
  insertSocialMediaCampaignSchema: () => insertSocialMediaCampaignSchema,
  insertSocialMediaListenerSchema: () => insertSocialMediaListenerSchema,
  insertSocialMediaMentionSchema: () => insertSocialMediaMentionSchema,
  insertSocialMediaMessageSchema: () => insertSocialMediaMessageSchema,
  insertSocialMediaPostSchema: () => insertSocialMediaPostSchema,
  insertSocialMediaTeamSchema: () => insertSocialMediaTeamSchema,
  insertSocialPostSchema: () => insertSocialPostSchema,
  insertSocialResponseTemplateSchema: () => insertSocialResponseTemplateSchema,
  insertSocialTokenSchema: () => insertSocialTokenSchema,
  insertSpotlightHistorySchema: () => insertSpotlightHistorySchema,
  insertSpotlightVoteSchema: () => insertSpotlightVoteSchema,
  insertTimelineShowcaseSchema: () => insertTimelineShowcaseSchema,
  insertTimelineShowcaseVoteSchema: () => insertTimelineShowcaseVoteSchema,
  insertUserMetricsSchema: () => insertUserMetricsSchema,
  insertUserRoleSchema: () => insertUserRoleSchema,
  insertUserSchema: () => insertUserSchema,
  insertUserSessionSchema: () => insertUserSessionSchema,
  insertVendorTransactionSchema: () => insertVendorTransactionSchema,
  insertWorkflowEnrollmentSchema: () => insertWorkflowEnrollmentSchema,
  insertWorkflowStepLogSchema: () => insertWorkflowStepLogSchema,
  ipAccessControl: () => ipAccessControl,
  leadCaptureForms: () => leadCaptureForms,
  leadCaptureFormsRelations: () => leadCaptureFormsRelations,
  leadSubmissions: () => leadSubmissions,
  leadSubmissionsRelations: () => leadSubmissionsRelations,
  loyaltyAccounts: () => loyaltyAccounts,
  loyaltyRules: () => loyaltyRules,
  loyaltyTiers: () => loyaltyTiers,
  loyaltyTransactions: () => loyaltyTransactions,
  marketingCampaigns: () => marketingCampaigns,
  marketingCampaignsRelations: () => marketingCampaignsRelations,
  marketingWorkflows: () => marketingWorkflows,
  marketingWorkflowsRelations: () => marketingWorkflowsRelations,
  messages: () => messages,
  messagesRelations: () => messagesRelations,
  orderItems: () => orderItems,
  orderItemsRelations: () => orderItemsRelations,
  orders: () => orders,
  ordersRelations: () => ordersRelations,
  payments: () => payments,
  paymentsRelations: () => paymentsRelations,
  postComments: () => postComments,
  postCommentsRelations: () => postCommentsRelations,
  postLikes: () => postLikes,
  postLikesRelations: () => postLikesRelations,
  posts: () => posts,
  postsRelations: () => postsRelations,
  premiumAdSlots: () => premiumAdSlots,
  premiumFeatures: () => premiumFeatures,
  premiumFeaturesRelations: () => premiumFeaturesRelations,
  productMetrics: () => productMetrics,
  products: () => products,
  productsRelations: () => productsRelations,
  rateLimitRecords: () => rateLimitRecords,
  rateLimitViolations: () => rateLimitViolations,
  recentPurchases: () => recentPurchases,
  recentPurchasesRelations: () => recentPurchasesRelations,
  referrals: () => referrals,
  rewardRedemptions: () => rewardRedemptions,
  rewards: () => rewards,
  securityEvents: () => securityEvents,
  securityNotifications: () => securityNotifications,
  segmentMembers: () => segmentMembers,
  segmentMembersRelations: () => segmentMembersRelations,
  sessionEvents: () => sessionEvents,
  sessions: () => sessions,
  socialAccounts: () => socialAccounts,
  socialAnalytics: () => socialAnalytics,
  socialContentCategories: () => socialContentCategories,
  socialMediaAccounts: () => socialMediaAccounts,
  socialMediaAnalytics: () => socialMediaAnalytics,
  socialMediaAutomation: () => socialMediaAutomation,
  socialMediaCampaigns: () => socialMediaCampaigns,
  socialMediaListeners: () => socialMediaListeners,
  socialMediaMentions: () => socialMediaMentions,
  socialMediaMessages: () => socialMediaMessages,
  socialMediaPosts: () => socialMediaPosts,
  socialMediaTeam: () => socialMediaTeam,
  socialPosts: () => socialPosts,
  socialResponseTemplates: () => socialResponseTemplates,
  socialTokens: () => socialTokens,
  spotlightHistory: () => spotlightHistory,
  spotlightHistoryRelations: () => spotlightHistoryRelations,
  spotlightVotes: () => spotlightVotes,
  spotlightVotesRelations: () => spotlightVotesRelations,
  spotlights: () => spotlights,
  spotlightsRelations: () => spotlightsRelations,
  timelineShowcaseVotes: () => timelineShowcaseVotes,
  timelineShowcaseVotesRelations: () => timelineShowcaseVotesRelations,
  timelineShowcases: () => timelineShowcases,
  timelineShowcasesRelations: () => timelineShowcasesRelations,
  updateBlogCommentSchema: () => updateBlogCommentSchema,
  updateBlogPostSchema: () => updateBlogPostSchema,
  updateBusinessSchema: () => updateBusinessSchema,
  updateCampaignRecipientSchema: () => updateCampaignRecipientSchema,
  updateCustomerSegmentSchema: () => updateCustomerSegmentSchema,
  updateEntrepreneurSchema: () => updateEntrepreneurSchema,
  updateLeadCaptureFormSchema: () => updateLeadCaptureFormSchema,
  updateLeadSubmissionSchema: () => updateLeadSubmissionSchema,
  updateMarketingCampaignSchema: () => updateMarketingCampaignSchema,
  updateMarketingWorkflowSchema: () => updateMarketingWorkflowSchema,
  updateTimelineShowcaseSchema: () => updateTimelineShowcaseSchema,
  updateWorkflowEnrollmentSchema: () => updateWorkflowEnrollmentSchema,
  updateWorkflowStepLogSchema: () => updateWorkflowStepLogSchema,
  userMetrics: () => userMetrics,
  userRoles: () => userRoles,
  userSessions: () => userSessions,
  users: () => users,
  usersMarketingRelations: () => usersMarketingRelations,
  usersRelations: () => usersRelations,
  vendorTransactions: () => vendorTransactions,
  vendorTransactionsRelations: () => vendorTransactionsRelations,
  workflowEnrollments: () => workflowEnrollments,
  workflowEnrollmentsRelations: () => workflowEnrollmentsRelations,
  workflowStepLogs: () => workflowStepLogs,
  workflowStepLogsRelations: () => workflowStepLogsRelations
});
import { sql, relations } from "drizzle-orm";
import {
  index,
  uniqueIndex,
  jsonb,
  pgTable,
  timestamp,
  varchar,
  text,
  integer,
  decimal,
  boolean,
  uuid,
  date
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var sessions, users, businesses, products, posts, postLikes, postComments, businessFollowers, spotlights, messages, cartItems, orders, orderItems, payments, spotlightHistory, engagementMetrics, spotlightVotes, gmbTokens, gmbSyncHistory, gmbReviews, apiKeys, blogCategories, blogTags, blogPosts, blogPostTags, blogComments, blogReactions, blogBookmarks, blogReadingLists, blogSubscriptions, blogAnalytics, blogRevisions, entrepreneurs, entrepreneurBusinesses, timelineShowcases, timelineShowcaseVotes, vendorTransactions, recentPurchases, adSpots, adCampaigns, adImpressions, premiumFeatures, aiGeneratedContent, aiContentTemplates, aiGeneratedImages, aiUsageTracking, aiContentTests, aiModerationLog, usersRelations, businessesRelations, productsRelations, postsRelations, postLikesRelations, postCommentsRelations, businessFollowersRelations, spotlightsRelations, messagesRelations, cartItemsRelations, ordersRelations, orderItemsRelations, paymentsRelations, spotlightHistoryRelations, engagementMetricsRelations, spotlightVotesRelations, gmbTokensRelations, gmbSyncHistoryRelations, gmbReviewsRelations, apiKeysRelations, entrepreneursRelations, entrepreneurBusinessesRelations, timelineShowcasesRelations, timelineShowcaseVotesRelations, vendorTransactionsRelations, recentPurchasesRelations, adSpotsRelations, adCampaignsRelations, adImpressionsRelations, premiumFeaturesRelations, blogCategoriesRelations, blogTagsRelations, blogPostsRelations, blogPostTagsRelations, blogCommentsRelations, blogReactionsRelations, blogBookmarksRelations, blogReadingListsRelations, blogSubscriptionsRelations, blogAnalyticsRelations, blogRevisionsRelations, insertUserSchema, insertBusinessSchema, updateBusinessSchema, insertProductSchema, insertPostSchema, insertMessageSchema, insertCartItemSchema, insertOrderSchema, insertOrderItemSchema, insertPaymentSchema, insertSpotlightHistorySchema, insertEngagementMetricsSchema, insertSpotlightVoteSchema, insertGmbTokenSchema, insertGmbSyncHistorySchema, insertGmbReviewSchema, insertApiKeySchema, insertEntrepreneurSchema, updateEntrepreneurSchema, insertEntrepreneurBusinessSchema, insertTimelineShowcaseSchema, updateTimelineShowcaseSchema, insertTimelineShowcaseVoteSchema, insertVendorTransactionSchema, insertRecentPurchaseSchema, insertAdSpotSchema, insertAdCampaignSchema, insertAdImpressionSchema, insertPremiumFeatureSchema, insertBlogCategorySchema, insertBlogTagSchema, insertBlogPostSchema, updateBlogPostSchema, insertBlogPostTagSchema, insertBlogCommentSchema, updateBlogCommentSchema, insertBlogReactionSchema, insertBlogBookmarkSchema, insertBlogReadingListSchema, insertBlogSubscriptionSchema, insertBlogAnalyticsSchema, insertBlogRevisionSchema, marketingCampaigns, campaignRecipients, campaignLinks, campaignClicks, customerSegments, segmentMembers, marketingWorkflows, workflowEnrollments, workflowStepLogs, leadCaptureForms, leadSubmissions, marketingCampaignsRelations, campaignRecipientsRelations, campaignLinksRelations, campaignClicksRelations, customerSegmentsRelations, segmentMembersRelations, marketingWorkflowsRelations, workflowEnrollmentsRelations, workflowStepLogsRelations, leadCaptureFormsRelations, leadSubmissionsRelations, businessesMarketingRelations, usersMarketingRelations, insertMarketingCampaignSchema, updateMarketingCampaignSchema, insertCampaignRecipientSchema, updateCampaignRecipientSchema, insertCampaignLinkSchema, insertCampaignClickSchema, insertCustomerSegmentSchema, updateCustomerSegmentSchema, insertSegmentMemberSchema, insertMarketingWorkflowSchema, updateMarketingWorkflowSchema, insertWorkflowEnrollmentSchema, updateWorkflowEnrollmentSchema, insertWorkflowStepLogSchema, updateWorkflowStepLogSchema, insertLeadCaptureFormSchema, updateLeadCaptureFormSchema, insertLeadSubmissionSchema, updateLeadSubmissionSchema, loyaltyTiers, loyaltyAccounts, loyaltyTransactions, loyaltyRules, rewards, rewardRedemptions, referrals, insertLoyaltyTierSchema, insertLoyaltyAccountSchema, insertLoyaltyTransactionSchema, insertLoyaltyRuleSchema, insertRewardSchema, insertRewardRedemptionSchema, insertReferralSchema, dailyMetrics, businessMetrics, userMetrics, productMetrics, analyticsEvents, customerCohorts, conversionFunnels, insertDailyMetricsSchema, insertBusinessMetricsSchema, insertUserMetricsSchema, insertProductMetricsSchema, insertAnalyticsEventSchema, insertCustomerCohortSchema, insertConversionFunnelSchema, socialAccounts, socialTokens, socialPosts, socialAnalytics, insertSocialAccountSchema, insertSocialTokenSchema, insertSocialPostSchema, insertSocialAnalyticsSchema, adminRoles, userRoles, adminAuditLogs, errorLogs, premiumAdSlots, chatConversations, chatMessages, chatKnowledgeBase, chatSessions, chatAnalytics, chatQuickActions, chatProactiveTriggers, failedLoginAttempts, accountLockouts, ipAccessControl, geoRestrictions, securityEvents, activeSessions, securityNotifications, authAuditLogs, rateLimitRecords, rateLimitViolations, userSessions, deviceFingerprints, sessionEvents, socialMediaAccounts, socialMediaPosts, socialMediaCampaigns, socialContentCategories, socialMediaAnalytics, socialMediaMessages, socialResponseTemplates, socialMediaListeners, socialMediaMentions, socialMediaAutomation, socialMediaTeam, insertSocialMediaAccountSchema, insertSocialMediaPostSchema, insertSocialMediaCampaignSchema, insertSocialContentCategorySchema, insertSocialMediaAnalyticsSchema, insertSocialMediaMessageSchema, insertSocialResponseTemplateSchema, insertSocialMediaListenerSchema, insertSocialMediaMentionSchema, insertSocialMediaAutomationSchema, insertSocialMediaTeamSchema, insertAdminRoleSchema, insertUserRoleSchema, insertAdminAuditLogSchema, insertErrorLogSchema, insertPremiumAdSlotSchema, insertRateLimitViolationSchema, insertUserSessionSchema, insertDeviceFingerprintSchema, insertSessionEventSchema, insertChatConversationSchema, insertChatMessageSchema, insertChatKnowledgeBaseSchema, insertChatSessionSchema, insertChatAnalyticsSchema, insertChatQuickActionSchema, insertChatProactiveTriggerSchema, insertAIGeneratedContentSchema, insertAIContentTemplateSchema, insertAIGeneratedImageSchema, insertAIUsageTrackingSchema, insertAIContentTestSchema, insertAIModerationLogSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    sessions = pgTable(
      "sessions",
      {
        sid: varchar("sid").primaryKey(),
        sess: jsonb("sess").notNull(),
        expire: timestamp("expire").notNull()
      },
      (table) => [index("IDX_session_expire").on(table.expire)]
    );
    users = pgTable("users", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      email: varchar("email").unique(),
      firstName: varchar("first_name"),
      lastName: varchar("last_name"),
      profileImageUrl: varchar("profile_image_url"),
      isAdmin: boolean("is_admin").default(false),
      // SECURITY: Admin role for spotlight management
      onlineStatus: varchar("online_status", { length: 20 }).default("offline"),
      // online, away, offline
      lastSeenAt: timestamp("last_seen_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    businesses = pgTable("businesses", {
      id: uuid("id").primaryKey().defaultRandom(),
      ownerId: varchar("owner_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      tagline: varchar("tagline", { length: 500 }),
      description: text("description"),
      category: varchar("category", { length: 100 }),
      location: varchar("location", { length: 255 }),
      address: text("address"),
      phone: varchar("phone", { length: 20 }),
      website: varchar("website", { length: 255 }),
      logoUrl: varchar("logo_url"),
      coverImageUrl: varchar("cover_image_url"),
      operatingHours: jsonb("operating_hours"),
      socialLinks: jsonb("social_links"),
      googlePlaceId: varchar("google_place_id"),
      isVerified: boolean("is_verified").default(false),
      isActive: boolean("is_active").default(true),
      // Google My Business Integration Fields
      gmbVerified: boolean("gmb_verified").default(false),
      gmbConnected: boolean("gmb_connected").default(false),
      gmbAccountId: varchar("gmb_account_id"),
      gmbLocationId: varchar("gmb_location_id"),
      gmbSyncStatus: varchar("gmb_sync_status", { length: 20 }).default("none"),
      // none, pending, success, error
      gmbLastSyncAt: timestamp("gmb_last_sync_at"),
      gmbLastErrorAt: timestamp("gmb_last_error_at"),
      gmbLastError: text("gmb_last_error"),
      gmbDataSources: jsonb("gmb_data_sources"),
      // Track which fields come from GMB
      // Stripe Connect fields
      stripeAccountId: text("stripe_account_id"),
      stripeOnboardingStatus: text("stripe_onboarding_status"),
      // pending, active, disabled
      stripeChargesEnabled: boolean("stripe_charges_enabled").default(false),
      stripePayoutsEnabled: boolean("stripe_payouts_enabled").default(false),
      // Multi-payment integration support (Phase 2)
      paymentIntegrations: jsonb("payment_integrations"),
      // { stripe: {accountId, isActive}, paypal: {...}, square: {...} }
      miniStoreEnabled: boolean("mini_store_enabled").default(false),
      miniStoreConfig: jsonb("mini_store_config"),
      // { theme, colors, banner, logo }
      rating: decimal("rating", { precision: 3, scale: 2 }).default("0"),
      reviewCount: integer("review_count").default(0),
      followerCount: integer("follower_count").default(0),
      postCount: integer("post_count").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    products = pgTable("products", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      price: decimal("price", { precision: 10, scale: 2 }).notNull(),
      originalPrice: decimal("original_price", { precision: 10, scale: 2 }),
      category: varchar("category", { length: 100 }),
      images: jsonb("images"),
      inventory: integer("inventory").default(0),
      isActive: boolean("is_active").default(true),
      isDigital: boolean("is_digital").default(false),
      tags: jsonb("tags"),
      rating: decimal("rating", { precision: 3, scale: 2 }).default("0"),
      reviewCount: integer("review_count").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    posts = pgTable("posts", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      content: text("content").notNull(),
      images: jsonb("images"),
      type: varchar("type", { length: 50 }).default("update"),
      // update, achievement, partnership, product
      likeCount: integer("like_count").default(0),
      commentCount: integer("comment_count").default(0),
      shareCount: integer("share_count").default(0),
      isVisible: boolean("is_visible").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    postLikes = pgTable("post_likes", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp("created_at").defaultNow()
    });
    postComments = pgTable("post_comments", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text("content").notNull(),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    businessFollowers = pgTable("business_followers", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp("created_at").defaultNow()
    });
    spotlights = pgTable("spotlights", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      type: varchar("type", { length: 20 }).notNull(),
      // daily, weekly, monthly
      position: integer("position"),
      // 1, 2, 3 for daily; 1-5 for weekly; 1 for monthly
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow()
    });
    messages = pgTable("messages", {
      id: uuid("id").primaryKey().defaultRandom(),
      senderId: varchar("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      receiverId: varchar("receiver_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      senderBusinessId: uuid("sender_business_id").references(() => businesses.id, { onDelete: "cascade" }),
      receiverBusinessId: uuid("receiver_business_id").references(() => businesses.id, { onDelete: "cascade" }),
      // Message content and type
      content: text("content").notNull(),
      messageType: varchar("message_type", { length: 30 }).notNull().default("text"),
      // text, file, business_share, product_share, ice_breaker
      // File attachment fields
      fileUrl: varchar("file_url"),
      fileName: varchar("file_name"),
      fileType: varchar("file_type", { length: 100 }),
      fileSize: integer("file_size"),
      // in bytes
      // Shared content references for business networking
      sharedBusinessId: uuid("shared_business_id").references(() => businesses.id),
      sharedProductId: uuid("shared_product_id").references(() => products.id),
      // Message metadata
      isRead: boolean("is_read").default(false),
      readAt: timestamp("read_at"),
      isDelivered: boolean("is_delivered").default(false),
      deliveredAt: timestamp("delivered_at"),
      // Conversation threading
      conversationId: varchar("conversation_id").notNull(),
      // Generated from user IDs for grouping
      // Business networking context
      networkingContext: jsonb("networking_context"),
      // For storing ice-breaker prompts, Florida business tips, etc.
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    cartItems = pgTable("cart_items", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      productId: uuid("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      quantity: integer("quantity").notNull().default(1),
      addedAt: timestamp("added_at").defaultNow()
    });
    orders = pgTable("orders", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, processing, shipped, delivered, cancelled
      subtotal: decimal("subtotal", { precision: 10, scale: 2 }).notNull(),
      taxAmount: decimal("tax_amount", { precision: 10, scale: 2 }).default("0"),
      shippingAmount: decimal("shipping_amount", { precision: 10, scale: 2 }).default("0"),
      total: decimal("total", { precision: 10, scale: 2 }).notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("usd"),
      shippingAddress: jsonb("shipping_address"),
      billingAddress: jsonb("billing_address"),
      customerEmail: varchar("customer_email"),
      customerPhone: varchar("customer_phone", { length: 20 }),
      notes: text("notes"),
      customerComment: varchar("customer_comment", { length: 200 }),
      // Phase 2: For purchase notification widget
      invoiceNumber: varchar("invoice_number", { length: 50 }),
      vendorBusinessId: uuid("vendor_business_id").references(() => businesses.id),
      // Phase 2: Track which vendor
      parentOrderId: uuid("parent_order_id"),
      // Phase 2: For multi-vendor cart splits
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    orderItems = pgTable("order_items", {
      id: uuid("id").primaryKey().defaultRandom(),
      orderId: uuid("order_id").notNull().references(() => orders.id, { onDelete: "cascade" }),
      productId: uuid("product_id").notNull().references(() => products.id),
      productName: varchar("product_name", { length: 255 }).notNull(),
      // Store at time of order
      productPrice: decimal("product_price", { precision: 10, scale: 2 }).notNull(),
      // Price at time of order
      quantity: integer("quantity").notNull(),
      totalPrice: decimal("total_price", { precision: 10, scale: 2 }).notNull(),
      createdAt: timestamp("created_at").defaultNow()
    });
    payments = pgTable("payments", {
      id: uuid("id").primaryKey().defaultRandom(),
      orderId: uuid("order_id").notNull().references(() => orders.id, { onDelete: "cascade" }),
      stripePaymentIntentId: varchar("stripe_payment_intent_id").unique(),
      stripeClientSecret: varchar("stripe_client_secret"),
      amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("usd"),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, processing, succeeded, failed, cancelled
      paymentMethod: varchar("payment_method", { length: 50 }).default("card"),
      failureReason: text("failure_reason"),
      paidAt: timestamp("paid_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    spotlightHistory = pgTable("spotlight_history", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      type: varchar("type", { length: 20 }).notNull(),
      // daily, weekly, monthly
      position: integer("position"),
      // 1, 2, 3 for daily; 1-5 for weekly; 1 for monthly
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      engagementScore: decimal("engagement_score", { precision: 5, scale: 2 }),
      qualityScore: decimal("quality_score", { precision: 5, scale: 2 }),
      recencyScore: decimal("recency_score", { precision: 5, scale: 2 }),
      diversityScore: decimal("diversity_score", { precision: 5, scale: 2 }),
      totalScore: decimal("total_score", { precision: 5, scale: 2 }),
      createdAt: timestamp("created_at").defaultNow()
    });
    engagementMetrics = pgTable("engagement_metrics", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      followersGrowth: integer("followers_growth").default(0),
      // Growth in last 30 days
      postsEngagement: decimal("posts_engagement", { precision: 5, scale: 2 }).default("0"),
      // Avg likes/comments per post
      recentActivity: integer("recent_activity").default(0),
      // Posts in last 7 days
      productViews: integer("product_views").default(0),
      // Product page views in last 30 days
      profileViews: integer("profile_views").default(0),
      // Profile views in last 30 days
      orderCount: integer("order_count").default(0),
      // Orders in last 30 days
      lastFeaturedDaily: timestamp("last_featured_daily"),
      lastFeaturedWeekly: timestamp("last_featured_weekly"),
      lastFeaturedMonthly: timestamp("last_featured_monthly"),
      calculatedAt: timestamp("calculated_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      // Ensure each business can only have one engagement metrics record
      uniqueIndex("idx_unique_business_engagement_metrics").on(table.businessId)
    ]);
    spotlightVotes = pgTable("spotlight_votes", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      month: varchar("month", { length: 7 }).notNull(),
      // Format: YYYY-MM
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // CRITICAL: Ensure each user can only vote ONCE per month total (not per business)
      uniqueIndex("idx_unique_user_month_vote").on(table.userId, table.month)
    ]);
    gmbTokens = pgTable("gmb_tokens", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      accessToken: text("access_token").notNull(),
      // Encrypted in storage
      refreshToken: text("refresh_token").notNull(),
      // Encrypted in storage
      tokenType: varchar("token_type", { length: 20 }).default("Bearer"),
      expiresAt: timestamp("expires_at").notNull(),
      scope: text("scope"),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_business_gmb_token").on(table.businessId)
    ]);
    gmbSyncHistory = pgTable("gmb_sync_history", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      syncType: varchar("sync_type", { length: 30 }).notNull(),
      // full, partial, reviews, photos, info
      status: varchar("status", { length: 20 }).notNull(),
      // success, error, partial
      dataTypes: jsonb("data_types"),
      // Array of synced data types
      changes: jsonb("changes"),
      // Summary of changes made
      errorDetails: text("error_details"),
      itemsProcessed: integer("items_processed").default(0),
      itemsUpdated: integer("items_updated").default(0),
      itemsErrors: integer("items_errors").default(0),
      durationMs: integer("duration_ms"),
      triggeredBy: varchar("triggered_by", { length: 20 }).default("manual"),
      // manual, scheduled, webhook
      gmbApiVersion: varchar("gmb_api_version", { length: 10 }),
      createdAt: timestamp("created_at").defaultNow()
    });
    gmbReviews = pgTable("gmb_reviews", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      gmbReviewId: varchar("gmb_review_id").notNull(),
      // Google's review ID
      reviewerName: varchar("reviewer_name", { length: 255 }),
      reviewerPhotoUrl: varchar("reviewer_photo_url"),
      rating: integer("rating").notNull(),
      // 1-5 stars
      comment: text("comment"),
      reviewTime: timestamp("review_time").notNull(),
      replyComment: text("reply_comment"),
      replyTime: timestamp("reply_time"),
      gmbCreateTime: timestamp("gmb_create_time").notNull(),
      gmbUpdateTime: timestamp("gmb_update_time").notNull(),
      isVisible: boolean("is_visible").default(true),
      importedAt: timestamp("imported_at").defaultNow(),
      lastSyncedAt: timestamp("last_synced_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_gmb_review").on(table.businessId, table.gmbReviewId)
    ]);
    apiKeys = pgTable("api_keys", {
      id: uuid("id").primaryKey().defaultRandom(),
      keyHash: varchar("key_hash", { length: 64 }).notNull().unique(),
      // SHA-256 hash of the API key
      name: varchar("name", { length: 255 }).notNull(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      permissions: jsonb("permissions").notNull().default([]),
      // Array of permission strings
      rateLimit: jsonb("rate_limit"),
      // { requests: number, window: number }
      isActive: boolean("is_active").default(true),
      lastUsedAt: timestamp("last_used_at"),
      expiresAt: timestamp("expires_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_api_keys_key_hash").on(table.keyHash),
      index("idx_api_keys_business_id").on(table.businessId),
      index("idx_api_keys_user_id").on(table.userId)
    ]);
    blogCategories = pgTable("blog_categories", {
      id: uuid("id").primaryKey().defaultRandom(),
      name: varchar("name", { length: 100 }).notNull().unique(),
      slug: varchar("slug", { length: 100 }).notNull().unique(),
      description: text("description"),
      color: varchar("color", { length: 7 }),
      // Hex color for UI
      icon: varchar("icon", { length: 50 }),
      // Icon name
      postCount: integer("post_count").default(0),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_blog_categories_slug").on(table.slug)
    ]);
    blogTags = pgTable("blog_tags", {
      id: uuid("id").primaryKey().defaultRandom(),
      name: varchar("name", { length: 50 }).notNull().unique(),
      slug: varchar("slug", { length: 50 }).notNull().unique(),
      postCount: integer("post_count").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_blog_tags_slug").on(table.slug)
    ]);
    blogPosts = pgTable("blog_posts", {
      id: uuid("id").primaryKey().defaultRandom(),
      authorId: varchar("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "cascade" }),
      // Optional: business attribution
      title: varchar("title", { length: 255 }).notNull(),
      slug: varchar("slug", { length: 255 }).notNull().unique(),
      excerpt: varchar("excerpt", { length: 500 }),
      content: text("content").notNull(),
      // Rich text HTML from TipTap
      featuredImageUrl: varchar("featured_image_url"),
      categoryId: uuid("category_id").references(() => blogCategories.id, { onDelete: "set null" }),
      // SEO Fields
      metaTitle: varchar("meta_title", { length: 60 }),
      metaDescription: varchar("meta_description", { length: 160 }),
      metaKeywords: jsonb("meta_keywords"),
      // Array of keywords
      canonicalUrl: varchar("canonical_url", { length: 500 }),
      ogImage: varchar("og_image"),
      // Open Graph image
      // Status & Publishing
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      // draft, scheduled, published, archived
      publishedAt: timestamp("published_at"),
      scheduledAt: timestamp("scheduled_at"),
      // Engagement Metrics
      viewCount: integer("view_count").default(0),
      uniqueViewCount: integer("unique_view_count").default(0),
      likeCount: integer("like_count").default(0),
      commentCount: integer("comment_count").default(0),
      shareCount: integer("share_count").default(0),
      bookmarkCount: integer("bookmark_count").default(0),
      readCompletionRate: decimal("read_completion_rate", { precision: 5, scale: 2 }).default("0"),
      // Percentage
      avgReadTimeSeconds: integer("avg_read_time_seconds"),
      // Features
      isFeatured: boolean("is_featured").default(false),
      isPinned: boolean("is_pinned").default(false),
      allowComments: boolean("allow_comments").default(true),
      // Revision History
      version: integer("version").default(1),
      lastEditedBy: varchar("last_edited_by").references(() => users.id),
      lastEditedAt: timestamp("last_edited_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_blog_posts_slug").on(table.slug),
      index("idx_blog_posts_author").on(table.authorId),
      index("idx_blog_posts_business").on(table.businessId),
      index("idx_blog_posts_category").on(table.categoryId),
      index("idx_blog_posts_status").on(table.status),
      index("idx_blog_posts_published").on(table.publishedAt),
      index("idx_blog_posts_view_count").on(table.viewCount)
    ]);
    blogPostTags = pgTable("blog_post_tags", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => blogPosts.id, { onDelete: "cascade" }),
      tagId: uuid("tag_id").notNull().references(() => blogTags.id, { onDelete: "cascade" }),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_post_tag").on(table.postId, table.tagId)
    ]);
    blogComments = pgTable("blog_comments", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => blogPosts.id, { onDelete: "cascade" }),
      authorId: varchar("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      parentCommentId: uuid("parent_comment_id"),
      // Self-reference - set after table definition
      content: text("content").notNull(),
      isEdited: boolean("is_edited").default(false),
      editedAt: timestamp("edited_at"),
      likeCount: integer("like_count").default(0),
      replyCount: integer("reply_count").default(0),
      isApproved: boolean("is_approved").default(true),
      // Moderation
      isFlagged: boolean("is_flagged").default(false),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_blog_comments_post").on(table.postId),
      index("idx_blog_comments_author").on(table.authorId),
      index("idx_blog_comments_parent").on(table.parentCommentId)
    ]);
    blogReactions = pgTable("blog_reactions", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => blogPosts.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reactionType: varchar("reaction_type", { length: 20 }).notNull().default("like"),
      // like, love, clap, insightful
      count: integer("count").default(1),
      // Allow multiple claps from same user
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_post_user_reaction").on(table.postId, table.userId, table.reactionType)
    ]);
    blogBookmarks = pgTable("blog_bookmarks", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => blogPosts.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      readingListId: uuid("reading_list_id").references(() => blogReadingLists.id, { onDelete: "cascade" }),
      // Optional: organize into lists
      notes: text("notes"),
      // Personal notes on the bookmark
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_post_user_bookmark").on(table.postId, table.userId)
    ]);
    blogReadingLists = pgTable("blog_reading_lists", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      isPublic: boolean("is_public").default(false),
      bookmarkCount: integer("bookmark_count").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_reading_lists_user").on(table.userId)
    ]);
    blogSubscriptions = pgTable("blog_subscriptions", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }),
      // Optional: for logged-in users
      email: varchar("email", { length: 255 }).notNull(),
      // For guest subscriptions
      subscribedToAll: boolean("subscribed_to_all").default(true),
      // All new posts
      subscribedCategories: jsonb("subscribed_categories"),
      // Array of category IDs
      subscribedAuthors: jsonb("subscribed_authors"),
      // Array of author IDs
      frequency: varchar("frequency", { length: 20 }).default("instant"),
      // instant, daily, weekly
      isActive: boolean("is_active").default(true),
      unsubscribeToken: varchar("unsubscribe_token", { length: 64 }).unique(),
      // For one-click unsubscribe
      confirmedAt: timestamp("confirmed_at"),
      // Email verification
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_blog_subscription_email").on(table.email),
      index("idx_blog_subscriptions_user").on(table.userId)
    ]);
    blogAnalytics = pgTable("blog_analytics", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => blogPosts.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      // Null for anonymous
      sessionId: varchar("session_id", { length: 64 }),
      // For tracking unique views
      // View Data
      viewType: varchar("view_type", { length: 20 }).notNull().default("page_view"),
      // page_view, scroll_50, scroll_100, read_complete
      scrollDepth: integer("scroll_depth"),
      // Percentage scrolled
      timeSpentSeconds: integer("time_spent_seconds"),
      // Traffic Source
      referrer: varchar("referrer", { length: 500 }),
      utmSource: varchar("utm_source", { length: 100 }),
      utmMedium: varchar("utm_medium", { length: 100 }),
      utmCampaign: varchar("utm_campaign", { length: 100 }),
      // Device Info
      deviceType: varchar("device_type", { length: 20 }),
      // desktop, mobile, tablet
      browser: varchar("browser", { length: 50 }),
      os: varchar("os", { length: 50 }),
      country: varchar("country", { length: 2 }),
      // ISO country code
      city: varchar("city", { length: 100 }),
      viewedAt: timestamp("viewed_at").defaultNow()
    }, (table) => [
      index("idx_blog_analytics_post").on(table.postId),
      index("idx_blog_analytics_user").on(table.userId),
      index("idx_blog_analytics_session").on(table.sessionId),
      index("idx_blog_analytics_viewed_at").on(table.viewedAt)
    ]);
    blogRevisions = pgTable("blog_revisions", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").notNull().references(() => blogPosts.id, { onDelete: "cascade" }),
      version: integer("version").notNull(),
      editedBy: varchar("edited_by").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Snapshot of content at this version
      title: varchar("title", { length: 255 }).notNull(),
      content: text("content").notNull(),
      excerpt: varchar("excerpt", { length: 500 }),
      // Changes metadata
      changesSummary: text("changes_summary"),
      // Auto-generated or manual description
      changeType: varchar("change_type", { length: 20 }).default("edit"),
      // edit, major_update, minor_fix
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_blog_revisions_post").on(table.postId),
      uniqueIndex("idx_unique_post_version").on(table.postId, table.version)
    ]);
    entrepreneurs = pgTable("entrepreneurs", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
      firstName: varchar("first_name", { length: 100 }).notNull(),
      lastName: varchar("last_name", { length: 100 }).notNull(),
      bio: text("bio"),
      // Short bio
      story: text("story"),
      // Full entrepreneurial story
      tagline: varchar("tagline", { length: 200 }),
      profileImageUrl: varchar("profile_image_url"),
      coverImageUrl: varchar("cover_image_url"),
      socialLinks: jsonb("social_links"),
      // { twitter, linkedin, instagram, facebook }
      achievements: jsonb("achievements"),
      // Array of achievement objects
      specialties: jsonb("specialties"),
      // Array of specialty tags
      location: varchar("location", { length: 255 }),
      website: varchar("website", { length: 255 }),
      yearsExperience: integer("years_experience"),
      totalBusinessesOwned: integer("total_businesses_owned").default(0),
      totalRevenueGenerated: decimal("total_revenue_generated", { precision: 12, scale: 2 }),
      followerCount: integer("follower_count").default(0),
      showcaseCount: integer("showcase_count").default(0),
      isVerified: boolean("is_verified").default(false),
      isFeatured: boolean("is_featured").default(false),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    entrepreneurBusinesses = pgTable("entrepreneur_businesses", {
      id: uuid("id").primaryKey().defaultRandom(),
      entrepreneurId: uuid("entrepreneur_id").notNull().references(() => entrepreneurs.id, { onDelete: "cascade" }),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      role: varchar("role", { length: 50 }).notNull().default("founder"),
      // founder, co-founder, owner, partner
      equityPercentage: decimal("equity_percentage", { precision: 5, scale: 2 }),
      joinedDate: timestamp("joined_date").defaultNow(),
      leftDate: timestamp("left_date"),
      isCurrent: boolean("is_current").default(true),
      isPublic: boolean("is_public").default(true),
      // Show on entrepreneur profile
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_entrepreneur_business").on(table.entrepreneurId, table.businessId)
    ]);
    timelineShowcases = pgTable("timeline_showcases", {
      id: uuid("id").primaryKey().defaultRandom(),
      entrepreneurId: uuid("entrepreneur_id").references(() => entrepreneurs.id, { onDelete: "cascade" }),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "cascade" }),
      authorId: varchar("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: varchar("type", { length: 30 }).notNull().default("story"),
      // story, launch, milestone, promotion, update
      title: varchar("title", { length: 255 }).notNull(),
      content: text("content").notNull(),
      excerpt: varchar("excerpt", { length: 500 }),
      mediaUrls: jsonb("media_urls"),
      // Array of image/video URLs
      ctaText: varchar("cta_text", { length: 100 }),
      ctaUrl: varchar("cta_url", { length: 500 }),
      tags: jsonb("tags"),
      // Array of tag strings
      category: varchar("category", { length: 100 }),
      voteCount: integer("vote_count").default(0),
      likeCount: integer("like_count").default(0),
      commentCount: integer("comment_count").default(0),
      shareCount: integer("share_count").default(0),
      viewCount: integer("view_count").default(0),
      isPinned: boolean("is_pinned").default(false),
      isFeatured: boolean("is_featured").default(false),
      isPromoted: boolean("is_promoted").default(false),
      // Paid promotion
      promotionSpotId: uuid("promotion_spot_id"),
      // References ad spot if promoted
      promotionStartDate: timestamp("promotion_start_date"),
      promotionEndDate: timestamp("promotion_end_date"),
      isApproved: boolean("is_approved").default(false),
      // Admin moderation
      approvedBy: varchar("approved_by").references(() => users.id),
      approvedAt: timestamp("approved_at"),
      scheduledAt: timestamp("scheduled_at"),
      publishedAt: timestamp("published_at"),
      isPublished: boolean("is_published").default(false),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_timeline_published").on(table.isPublished, table.publishedAt),
      index("idx_timeline_votes").on(table.voteCount),
      index("idx_timeline_entrepreneur").on(table.entrepreneurId)
    ]);
    timelineShowcaseVotes = pgTable("timeline_showcase_votes", {
      id: uuid("id").primaryKey().defaultRandom(),
      showcaseId: uuid("showcase_id").notNull().references(() => timelineShowcases.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      voteType: varchar("vote_type", { length: 10 }).notNull().default("upvote"),
      // upvote, downvote
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      uniqueIndex("idx_unique_showcase_vote").on(table.showcaseId, table.userId)
    ]);
    vendorTransactions = pgTable("vendor_transactions", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      orderId: uuid("order_id").notNull().references(() => orders.id, { onDelete: "cascade" }),
      amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
      // Total order amount
      platformFee: decimal("platform_fee", { precision: 10, scale: 2 }).notNull(),
      // Platform's cut (e.g., 5%)
      vendorPayout: decimal("vendor_payout", { precision: 10, scale: 2 }).notNull(),
      // Amount vendor receives
      currency: varchar("currency", { length: 3 }).notNull().default("usd"),
      stripeTransferId: varchar("stripe_transfer_id"),
      // Stripe Connect transfer ID
      stripeChargeId: varchar("stripe_charge_id"),
      paymentProcessor: varchar("payment_processor", { length: 20 }).default("stripe"),
      // stripe, paypal, square
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, completed, failed, refunded
      failureReason: text("failure_reason"),
      paidOutAt: timestamp("paid_out_at"),
      refundedAt: timestamp("refunded_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_vendor_transactions_business").on(table.businessId),
      index("idx_vendor_transactions_order").on(table.orderId)
    ]);
    recentPurchases = pgTable("recent_purchases", {
      id: uuid("id").primaryKey().defaultRandom(),
      orderId: uuid("order_id").notNull().references(() => orders.id, { onDelete: "cascade" }),
      customerName: varchar("customer_name", { length: 100 }).notNull(),
      // Anonymized: "John D."
      customerLocation: varchar("customer_location", { length: 100 }),
      // "Miami, FL"
      productName: varchar("product_name", { length: 255 }).notNull(),
      vendorName: varchar("vendor_name", { length: 255 }).notNull(),
      vendorBusinessId: uuid("vendor_business_id").references(() => businesses.id, { onDelete: "cascade" }),
      customerComment: varchar("customer_comment", { length: 200 }),
      // Optional comment at checkout
      amount: decimal("amount", { precision: 10, scale: 2 }),
      isVisible: boolean("is_visible").default(true),
      // Can be hidden by admin
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_recent_purchases_created").on(table.createdAt)
    ]);
    adSpots = pgTable("ad_spots", {
      id: uuid("id").primaryKey().defaultRandom(),
      name: varchar("name", { length: 100 }).notNull().unique(),
      displayName: varchar("display_name", { length: 100 }).notNull(),
      description: text("description"),
      location: varchar("location", { length: 50 }).notNull(),
      // timeline, marketplace, home, sidebar
      position: varchar("position", { length: 50 }),
      // hero, top, middle, bottom, #3, #8, etc.
      pricePerDay: decimal("price_per_day", { precision: 10, scale: 2 }),
      pricePerWeek: decimal("price_per_week", { precision: 10, scale: 2 }),
      pricePerMonth: decimal("price_per_month", { precision: 10, scale: 2 }),
      dimensions: varchar("dimensions", { length: 50 }),
      // "300x250", "728x90", etc.
      maxActiveSlots: integer("max_active_slots").default(1),
      // How many can run simultaneously
      isAvailable: boolean("is_available").default(true),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    adCampaigns = pgTable("ad_campaigns", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      adSpotId: uuid("ad_spot_id").notNull().references(() => adSpots.id),
      showcaseId: uuid("showcase_id").references(() => timelineShowcases.id),
      // Content to promote
      name: varchar("name", { length: 255 }).notNull(),
      creativeUrl: varchar("creative_url"),
      // Custom ad image/video URL
      targetUrl: varchar("target_url"),
      // Where ad clicks go
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      totalCost: decimal("total_cost", { precision: 10, scale: 2 }).notNull(),
      billingCycle: varchar("billing_cycle", { length: 20 }).default("prepaid"),
      // prepaid, monthly
      impressions: integer("impressions").default(0),
      clicks: integer("clicks").default(0),
      conversions: integer("conversions").default(0),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, active, paused, completed, cancelled
      isPaid: boolean("is_paid").default(false),
      paidAt: timestamp("paid_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_ad_campaigns_business").on(table.businessId),
      index("idx_ad_campaigns_spot").on(table.adSpotId),
      index("idx_ad_campaigns_dates").on(table.startDate, table.endDate)
    ]);
    adImpressions = pgTable("ad_impressions", {
      id: uuid("id").primaryKey().defaultRandom(),
      campaignId: uuid("campaign_id").notNull().references(() => adCampaigns.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      ipAddress: varchar("ip_address", { length: 45 }),
      // Support IPv6
      userAgent: text("user_agent"),
      referrer: varchar("referrer", { length: 500 }),
      isClick: boolean("is_click").default(false),
      isConversion: boolean("is_conversion").default(false),
      timestamp: timestamp("timestamp").defaultNow()
    }, (table) => [
      index("idx_ad_impressions_campaign").on(table.campaignId),
      index("idx_ad_impressions_timestamp").on(table.timestamp)
    ]);
    premiumFeatures = pgTable("premium_features", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      featureType: varchar("feature_type", { length: 30 }).notNull(),
      // pin, boost, badge, email, multi_category
      showcaseId: uuid("showcase_id").references(() => timelineShowcases.id),
      // If feature applies to showcase
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      price: decimal("price", { precision: 10, scale: 2 }).notNull(),
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, expired, cancelled
      isPaid: boolean("is_paid").default(false),
      paidAt: timestamp("paid_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_premium_features_business").on(table.businessId),
      index("idx_premium_features_type").on(table.featureType)
    ]);
    aiGeneratedContent = pgTable("ai_generated_content", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      type: varchar("type", { length: 50 }).notNull(),
      // business_description, product_description, blog_post, social_media, email_template, review_response, faq, tagline
      platform: varchar("platform", { length: 30 }),
      // facebook, instagram, twitter, linkedin, gmb, email, general
      content: text("content").notNull(),
      prompt: text("prompt"),
      enhancedPrompt: text("enhanced_prompt"),
      tone: varchar("tone", { length: 30 }),
      // professional, casual, friendly, formal, humorous, inspirational
      language: varchar("language", { length: 10 }).default("en"),
      keywords: jsonb("keywords"),
      // Array of SEO keywords
      hashtags: jsonb("hashtags"),
      // Array of hashtags
      metadata: jsonb("metadata"),
      // { model, tokensUsed, cost, characterCount, wordCount, readingTime, seoScore, sentimentScore }
      qualityMetrics: jsonb("quality_metrics"),
      // { clarity, engagement, brandSafety, hasProfanity, plagiarismScore }
      version: integer("version").default(1),
      parentId: uuid("parent_id"),
      // For content iterations/versions
      isFavorite: boolean("is_favorite").default(false),
      isTemplate: boolean("is_template").default(false),
      templateName: varchar("template_name", { length: 255 }),
      usageCount: integer("usage_count").default(0),
      performanceMetrics: jsonb("performance_metrics"),
      // { views, clicks, conversions, engagement }
      status: varchar("status", { length: 20 }).default("draft"),
      // draft, published, archived
      publishedAt: timestamp("published_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_ai_content_business").on(table.businessId),
      index("idx_ai_content_type").on(table.type),
      index("idx_ai_content_created").on(table.createdAt),
      index("idx_ai_content_favorite").on(table.isFavorite)
    ]);
    aiContentTemplates = pgTable("ai_content_templates", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      type: varchar("type", { length: 50 }).notNull(),
      category: varchar("category", { length: 100 }),
      prompt: text("prompt").notNull(),
      variables: jsonb("variables"),
      // Array of variable names that can be replaced
      examples: jsonb("examples"),
      // Array of example outputs
      tone: varchar("tone", { length: 30 }),
      platform: varchar("platform", { length: 30 }),
      isGlobal: boolean("is_global").default(false),
      // Available to all businesses
      isActive: boolean("is_active").default(true),
      usageCount: integer("usage_count").default(0),
      rating: decimal("rating", { precision: 3, scale: 2 }).default("0"),
      createdBy: varchar("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_ai_templates_business").on(table.businessId),
      index("idx_ai_templates_type").on(table.type),
      index("idx_ai_templates_global").on(table.isGlobal)
    ]);
    aiGeneratedImages = pgTable("ai_generated_images", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      prompt: text("prompt").notNull(),
      enhancedPrompt: text("enhanced_prompt"),
      negativePrompt: text("negative_prompt"),
      url: text("url").notNull(),
      localPath: text("local_path"),
      s3Url: text("s3_url"),
      metadata: jsonb("metadata"),
      // { size, style, quality, model, cost, generationTime, fileSize, dimensions }
      category: varchar("category", { length: 50 }),
      // product, logo, social, banner, background, marketing
      tags: jsonb("tags"),
      // Array of tags
      variations: jsonb("variations"),
      // Array of variation URLs if generated
      isFavorite: boolean("is_favorite").default(false),
      usageCount: integer("usage_count").default(0),
      status: varchar("status", { length: 20 }).default("active"),
      // active, deleted, archived
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_ai_images_business").on(table.businessId),
      index("idx_ai_images_category").on(table.category),
      index("idx_ai_images_created").on(table.createdAt)
    ]);
    aiUsageTracking = pgTable("ai_usage_tracking", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      service: varchar("service", { length: 30 }).notNull(),
      // openai, dalle, gpt5, etc
      model: varchar("model", { length: 50 }).notNull(),
      type: varchar("type", { length: 50 }).notNull(),
      // content_generation, image_generation, embeddings
      tokensUsed: integer("tokens_used").default(0),
      cost: decimal("cost", { precision: 10, scale: 6 }).notNull(),
      metadata: jsonb("metadata"),
      // Additional usage details
      billingPeriod: varchar("billing_period", { length: 20 }),
      // YYYY-MM
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_ai_usage_business").on(table.businessId),
      index("idx_ai_usage_period").on(table.billingPeriod),
      index("idx_ai_usage_created").on(table.createdAt)
    ]);
    aiContentTests = pgTable("ai_content_tests", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      type: varchar("type", { length: 50 }).notNull(),
      // email_subject, ad_copy, landing_page, etc
      status: varchar("status", { length: 20 }).default("running"),
      // draft, running, completed, paused
      variants: jsonb("variants"),
      // Array of { id, content, metrics }
      winnerVariantId: varchar("winner_variant_id", { length: 50 }),
      startDate: timestamp("start_date"),
      endDate: timestamp("end_date"),
      metrics: jsonb("metrics"),
      // { totalViews, conversions, clickThrough, etc }
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_ai_tests_business").on(table.businessId),
      index("idx_ai_tests_status").on(table.status)
    ]);
    aiModerationLog = pgTable("ai_moderation_log", {
      id: uuid("id").primaryKey().defaultRandom(),
      contentId: uuid("content_id"),
      contentType: varchar("content_type", { length: 50 }).notNull(),
      // generated_content, generated_image
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "cascade" }),
      moderationResult: jsonb("moderation_result"),
      // { profanity, violence, adult, etc }
      flaggedReasons: jsonb("flagged_reasons"),
      // Array of reasons
      isSafe: boolean("is_safe").default(true),
      action: varchar("action", { length: 30 }),
      // approved, rejected, modified
      moderatedBy: varchar("moderated_by"),
      // system or user_id
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_ai_moderation_content").on(table.contentId),
      index("idx_ai_moderation_business").on(table.businessId)
    ]);
    usersRelations = relations(users, ({ one, many }) => ({
      businesses: many(businesses),
      postLikes: many(postLikes),
      postComments: many(postComments),
      businessFollowers: many(businessFollowers),
      sentMessages: many(messages, { relationName: "sentMessages" }),
      receivedMessages: many(messages, { relationName: "receivedMessages" }),
      cartItems: many(cartItems),
      orders: many(orders),
      spotlightVotes: many(spotlightVotes),
      entrepreneur: one(entrepreneurs),
      // Phase 2
      timelineShowcases: many(timelineShowcases),
      // Phase 2
      timelineShowcaseVotes: many(timelineShowcaseVotes),
      // Phase 2
      // Phase 4: Blog relations
      blogPosts: many(blogPosts),
      blogComments: many(blogComments),
      blogReactions: many(blogReactions),
      blogBookmarks: many(blogBookmarks),
      blogReadingLists: many(blogReadingLists),
      blogSubscriptions: many(blogSubscriptions)
    }));
    businessesRelations = relations(businesses, ({ one, many }) => ({
      owner: one(users, {
        fields: [businesses.ownerId],
        references: [users.id]
      }),
      products: many(products),
      posts: many(posts),
      followers: many(businessFollowers),
      spotlights: many(spotlights),
      spotlightHistory: many(spotlightHistory),
      engagementMetrics: one(engagementMetrics),
      spotlightVotes: many(spotlightVotes),
      sentMessages: many(messages, { relationName: "senderBusiness" }),
      receivedMessages: many(messages, { relationName: "receiverBusiness" }),
      gmbTokens: one(gmbTokens),
      gmbSyncHistory: many(gmbSyncHistory),
      gmbReviews: many(gmbReviews),
      // Phase 2 relations
      entrepreneurBusinesses: many(entrepreneurBusinesses),
      timelineShowcases: many(timelineShowcases),
      vendorTransactions: many(vendorTransactions),
      recentPurchases: many(recentPurchases),
      adCampaigns: many(adCampaigns),
      premiumFeatures: many(premiumFeatures),
      // Phase 4: Blog relations
      blogPosts: many(blogPosts)
    }));
    productsRelations = relations(products, ({ one, many }) => ({
      business: one(businesses, {
        fields: [products.businessId],
        references: [businesses.id]
      }),
      cartItems: many(cartItems),
      orderItems: many(orderItems)
    }));
    postsRelations = relations(posts, ({ one, many }) => ({
      business: one(businesses, {
        fields: [posts.businessId],
        references: [businesses.id]
      }),
      likes: many(postLikes),
      comments: many(postComments)
    }));
    postLikesRelations = relations(postLikes, ({ one }) => ({
      post: one(posts, {
        fields: [postLikes.postId],
        references: [posts.id]
      }),
      user: one(users, {
        fields: [postLikes.userId],
        references: [users.id]
      })
    }));
    postCommentsRelations = relations(postComments, ({ one }) => ({
      post: one(posts, {
        fields: [postComments.postId],
        references: [posts.id]
      }),
      user: one(users, {
        fields: [postComments.userId],
        references: [users.id]
      })
    }));
    businessFollowersRelations = relations(businessFollowers, ({ one }) => ({
      business: one(businesses, {
        fields: [businessFollowers.businessId],
        references: [businesses.id]
      }),
      user: one(users, {
        fields: [businessFollowers.userId],
        references: [users.id]
      })
    }));
    spotlightsRelations = relations(spotlights, ({ one }) => ({
      business: one(businesses, {
        fields: [spotlights.businessId],
        references: [businesses.id]
      })
    }));
    messagesRelations = relations(messages, ({ one }) => ({
      sender: one(users, {
        fields: [messages.senderId],
        references: [users.id],
        relationName: "sentMessages"
      }),
      receiver: one(users, {
        fields: [messages.receiverId],
        references: [users.id],
        relationName: "receivedMessages"
      }),
      senderBusiness: one(businesses, {
        fields: [messages.senderBusinessId],
        references: [businesses.id],
        relationName: "senderBusiness"
      }),
      receiverBusiness: one(businesses, {
        fields: [messages.receiverBusinessId],
        references: [businesses.id],
        relationName: "receiverBusiness"
      })
    }));
    cartItemsRelations = relations(cartItems, ({ one }) => ({
      user: one(users, {
        fields: [cartItems.userId],
        references: [users.id]
      }),
      product: one(products, {
        fields: [cartItems.productId],
        references: [products.id]
      })
    }));
    ordersRelations = relations(orders, ({ one, many }) => ({
      user: one(users, {
        fields: [orders.userId],
        references: [users.id]
      }),
      orderItems: many(orderItems),
      payments: many(payments)
    }));
    orderItemsRelations = relations(orderItems, ({ one }) => ({
      order: one(orders, {
        fields: [orderItems.orderId],
        references: [orders.id]
      }),
      product: one(products, {
        fields: [orderItems.productId],
        references: [products.id]
      })
    }));
    paymentsRelations = relations(payments, ({ one }) => ({
      order: one(orders, {
        fields: [payments.orderId],
        references: [orders.id]
      })
    }));
    spotlightHistoryRelations = relations(spotlightHistory, ({ one }) => ({
      business: one(businesses, {
        fields: [spotlightHistory.businessId],
        references: [businesses.id]
      })
    }));
    engagementMetricsRelations = relations(engagementMetrics, ({ one }) => ({
      business: one(businesses, {
        fields: [engagementMetrics.businessId],
        references: [businesses.id]
      })
    }));
    spotlightVotesRelations = relations(spotlightVotes, ({ one }) => ({
      business: one(businesses, {
        fields: [spotlightVotes.businessId],
        references: [businesses.id]
      }),
      user: one(users, {
        fields: [spotlightVotes.userId],
        references: [users.id]
      })
    }));
    gmbTokensRelations = relations(gmbTokens, ({ one }) => ({
      business: one(businesses, {
        fields: [gmbTokens.businessId],
        references: [businesses.id]
      }),
      user: one(users, {
        fields: [gmbTokens.userId],
        references: [users.id]
      })
    }));
    gmbSyncHistoryRelations = relations(gmbSyncHistory, ({ one }) => ({
      business: one(businesses, {
        fields: [gmbSyncHistory.businessId],
        references: [businesses.id]
      })
    }));
    gmbReviewsRelations = relations(gmbReviews, ({ one }) => ({
      business: one(businesses, {
        fields: [gmbReviews.businessId],
        references: [businesses.id]
      })
    }));
    apiKeysRelations = relations(apiKeys, ({ one }) => ({
      business: one(businesses, {
        fields: [apiKeys.businessId],
        references: [businesses.id]
      }),
      user: one(users, {
        fields: [apiKeys.userId],
        references: [users.id]
      })
    }));
    entrepreneursRelations = relations(entrepreneurs, ({ one, many }) => ({
      user: one(users, {
        fields: [entrepreneurs.userId],
        references: [users.id]
      }),
      entrepreneurBusinesses: many(entrepreneurBusinesses),
      timelineShowcases: many(timelineShowcases)
    }));
    entrepreneurBusinessesRelations = relations(entrepreneurBusinesses, ({ one }) => ({
      entrepreneur: one(entrepreneurs, {
        fields: [entrepreneurBusinesses.entrepreneurId],
        references: [entrepreneurs.id]
      }),
      business: one(businesses, {
        fields: [entrepreneurBusinesses.businessId],
        references: [businesses.id]
      })
    }));
    timelineShowcasesRelations = relations(timelineShowcases, ({ one, many }) => ({
      entrepreneur: one(entrepreneurs, {
        fields: [timelineShowcases.entrepreneurId],
        references: [entrepreneurs.id]
      }),
      business: one(businesses, {
        fields: [timelineShowcases.businessId],
        references: [businesses.id]
      }),
      author: one(users, {
        fields: [timelineShowcases.authorId],
        references: [users.id]
      }),
      votes: many(timelineShowcaseVotes),
      premiumFeatures: many(premiumFeatures),
      adCampaigns: many(adCampaigns)
    }));
    timelineShowcaseVotesRelations = relations(timelineShowcaseVotes, ({ one }) => ({
      showcase: one(timelineShowcases, {
        fields: [timelineShowcaseVotes.showcaseId],
        references: [timelineShowcases.id]
      }),
      user: one(users, {
        fields: [timelineShowcaseVotes.userId],
        references: [users.id]
      })
    }));
    vendorTransactionsRelations = relations(vendorTransactions, ({ one }) => ({
      business: one(businesses, {
        fields: [vendorTransactions.businessId],
        references: [businesses.id]
      }),
      order: one(orders, {
        fields: [vendorTransactions.orderId],
        references: [orders.id]
      })
    }));
    recentPurchasesRelations = relations(recentPurchases, ({ one }) => ({
      order: one(orders, {
        fields: [recentPurchases.orderId],
        references: [orders.id]
      }),
      vendorBusiness: one(businesses, {
        fields: [recentPurchases.vendorBusinessId],
        references: [businesses.id]
      })
    }));
    adSpotsRelations = relations(adSpots, ({ many }) => ({
      adCampaigns: many(adCampaigns)
    }));
    adCampaignsRelations = relations(adCampaigns, ({ one, many }) => ({
      business: one(businesses, {
        fields: [adCampaigns.businessId],
        references: [businesses.id]
      }),
      adSpot: one(adSpots, {
        fields: [adCampaigns.adSpotId],
        references: [adSpots.id]
      }),
      showcase: one(timelineShowcases, {
        fields: [adCampaigns.showcaseId],
        references: [timelineShowcases.id]
      }),
      impressions: many(adImpressions)
    }));
    adImpressionsRelations = relations(adImpressions, ({ one }) => ({
      campaign: one(adCampaigns, {
        fields: [adImpressions.campaignId],
        references: [adCampaigns.id]
      }),
      user: one(users, {
        fields: [adImpressions.userId],
        references: [users.id]
      })
    }));
    premiumFeaturesRelations = relations(premiumFeatures, ({ one }) => ({
      business: one(businesses, {
        fields: [premiumFeatures.businessId],
        references: [businesses.id]
      }),
      showcase: one(timelineShowcases, {
        fields: [premiumFeatures.showcaseId],
        references: [timelineShowcases.id]
      })
    }));
    blogCategoriesRelations = relations(blogCategories, ({ many }) => ({
      posts: many(blogPosts)
    }));
    blogTagsRelations = relations(blogTags, ({ many }) => ({
      blogPostTags: many(blogPostTags)
    }));
    blogPostsRelations = relations(blogPosts, ({ one, many }) => ({
      author: one(users, {
        fields: [blogPosts.authorId],
        references: [users.id]
      }),
      business: one(businesses, {
        fields: [blogPosts.businessId],
        references: [businesses.id]
      }),
      category: one(blogCategories, {
        fields: [blogPosts.categoryId],
        references: [blogCategories.id]
      }),
      lastEditor: one(users, {
        fields: [blogPosts.lastEditedBy],
        references: [users.id]
      }),
      tags: many(blogPostTags),
      comments: many(blogComments),
      reactions: many(blogReactions),
      bookmarks: many(blogBookmarks),
      analytics: many(blogAnalytics),
      revisions: many(blogRevisions)
    }));
    blogPostTagsRelations = relations(blogPostTags, ({ one }) => ({
      post: one(blogPosts, {
        fields: [blogPostTags.postId],
        references: [blogPosts.id]
      }),
      tag: one(blogTags, {
        fields: [blogPostTags.tagId],
        references: [blogTags.id]
      })
    }));
    blogCommentsRelations = relations(blogComments, ({ one, many }) => ({
      post: one(blogPosts, {
        fields: [blogComments.postId],
        references: [blogPosts.id]
      }),
      author: one(users, {
        fields: [blogComments.authorId],
        references: [users.id]
      }),
      parentComment: one(blogComments, {
        fields: [blogComments.parentCommentId],
        references: [blogComments.id],
        relationName: "replies"
      }),
      replies: many(blogComments, {
        relationName: "replies"
      })
    }));
    blogReactionsRelations = relations(blogReactions, ({ one }) => ({
      post: one(blogPosts, {
        fields: [blogReactions.postId],
        references: [blogPosts.id]
      }),
      user: one(users, {
        fields: [blogReactions.userId],
        references: [users.id]
      })
    }));
    blogBookmarksRelations = relations(blogBookmarks, ({ one }) => ({
      post: one(blogPosts, {
        fields: [blogBookmarks.postId],
        references: [blogPosts.id]
      }),
      user: one(users, {
        fields: [blogBookmarks.userId],
        references: [users.id]
      }),
      readingList: one(blogReadingLists, {
        fields: [blogBookmarks.readingListId],
        references: [blogReadingLists.id]
      })
    }));
    blogReadingListsRelations = relations(blogReadingLists, ({ one, many }) => ({
      user: one(users, {
        fields: [blogReadingLists.userId],
        references: [users.id]
      }),
      bookmarks: many(blogBookmarks)
    }));
    blogSubscriptionsRelations = relations(blogSubscriptions, ({ one }) => ({
      user: one(users, {
        fields: [blogSubscriptions.userId],
        references: [users.id]
      })
    }));
    blogAnalyticsRelations = relations(blogAnalytics, ({ one }) => ({
      post: one(blogPosts, {
        fields: [blogAnalytics.postId],
        references: [blogPosts.id]
      }),
      user: one(users, {
        fields: [blogAnalytics.userId],
        references: [users.id]
      })
    }));
    blogRevisionsRelations = relations(blogRevisions, ({ one }) => ({
      post: one(blogPosts, {
        fields: [blogRevisions.postId],
        references: [blogPosts.id]
      }),
      editor: one(users, {
        fields: [blogRevisions.editedBy],
        references: [users.id]
      })
    }));
    insertUserSchema = createInsertSchema(users).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBusinessSchema = createInsertSchema(businesses).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      followerCount: true,
      postCount: true,
      rating: true,
      reviewCount: true
    });
    updateBusinessSchema = insertBusinessSchema.omit({
      ownerId: true
    });
    insertProductSchema = createInsertSchema(products).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      rating: true,
      reviewCount: true
    });
    insertPostSchema = createInsertSchema(posts).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      likeCount: true,
      commentCount: true,
      shareCount: true
    });
    insertMessageSchema = createInsertSchema(messages).omit({
      id: true,
      createdAt: true
    });
    insertCartItemSchema = createInsertSchema(cartItems).omit({
      id: true,
      addedAt: true
    });
    insertOrderSchema = createInsertSchema(orders).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOrderItemSchema = createInsertSchema(orderItems).omit({
      id: true,
      createdAt: true
    });
    insertPaymentSchema = createInsertSchema(payments).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSpotlightHistorySchema = createInsertSchema(spotlightHistory).omit({
      id: true,
      createdAt: true
    });
    insertEngagementMetricsSchema = createInsertSchema(engagementMetrics).omit({
      id: true,
      calculatedAt: true,
      updatedAt: true
    });
    insertSpotlightVoteSchema = createInsertSchema(spotlightVotes).omit({
      id: true,
      createdAt: true
    });
    insertGmbTokenSchema = createInsertSchema(gmbTokens).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertGmbSyncHistorySchema = createInsertSchema(gmbSyncHistory).omit({
      id: true,
      createdAt: true
    });
    insertGmbReviewSchema = createInsertSchema(gmbReviews).omit({
      id: true,
      importedAt: true,
      lastSyncedAt: true
    });
    insertApiKeySchema = createInsertSchema(apiKeys).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertEntrepreneurSchema = createInsertSchema(entrepreneurs).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      followerCount: true,
      showcaseCount: true,
      totalBusinessesOwned: true
    });
    updateEntrepreneurSchema = insertEntrepreneurSchema.omit({
      userId: true
    });
    insertEntrepreneurBusinessSchema = createInsertSchema(entrepreneurBusinesses).omit({
      id: true,
      createdAt: true
    });
    insertTimelineShowcaseSchema = createInsertSchema(timelineShowcases).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      voteCount: true,
      likeCount: true,
      commentCount: true,
      shareCount: true,
      viewCount: true
    });
    updateTimelineShowcaseSchema = insertTimelineShowcaseSchema.omit({
      authorId: true
    });
    insertTimelineShowcaseVoteSchema = createInsertSchema(timelineShowcaseVotes).omit({
      id: true,
      createdAt: true
    });
    insertVendorTransactionSchema = createInsertSchema(vendorTransactions).omit({
      id: true,
      createdAt: true
    });
    insertRecentPurchaseSchema = createInsertSchema(recentPurchases).omit({
      id: true,
      createdAt: true
    });
    insertAdSpotSchema = createInsertSchema(adSpots).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAdCampaignSchema = createInsertSchema(adCampaigns).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      impressions: true,
      clicks: true,
      conversions: true
    });
    insertAdImpressionSchema = createInsertSchema(adImpressions).omit({
      id: true,
      timestamp: true
    });
    insertPremiumFeatureSchema = createInsertSchema(premiumFeatures).omit({
      id: true,
      createdAt: true
    });
    insertBlogCategorySchema = createInsertSchema(blogCategories).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      postCount: true
    });
    insertBlogTagSchema = createInsertSchema(blogTags).omit({
      id: true,
      createdAt: true,
      postCount: true
    });
    insertBlogPostSchema = createInsertSchema(blogPosts).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      viewCount: true,
      uniqueViewCount: true,
      likeCount: true,
      commentCount: true,
      shareCount: true,
      bookmarkCount: true,
      readCompletionRate: true,
      avgReadTimeSeconds: true,
      version: true
    });
    updateBlogPostSchema = insertBlogPostSchema.omit({
      authorId: true
    });
    insertBlogPostTagSchema = createInsertSchema(blogPostTags).omit({
      id: true,
      createdAt: true
    });
    insertBlogCommentSchema = createInsertSchema(blogComments).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      likeCount: true,
      replyCount: true,
      isEdited: true,
      editedAt: true
    });
    updateBlogCommentSchema = insertBlogCommentSchema.omit({
      authorId: true,
      postId: true
    });
    insertBlogReactionSchema = createInsertSchema(blogReactions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBlogBookmarkSchema = createInsertSchema(blogBookmarks).omit({
      id: true,
      createdAt: true
    });
    insertBlogReadingListSchema = createInsertSchema(blogReadingLists).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      bookmarkCount: true
    });
    insertBlogSubscriptionSchema = createInsertSchema(blogSubscriptions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBlogAnalyticsSchema = createInsertSchema(blogAnalytics).omit({
      id: true,
      viewedAt: true
    });
    insertBlogRevisionSchema = createInsertSchema(blogRevisions).omit({
      id: true,
      createdAt: true
    });
    marketingCampaigns = pgTable("marketing_campaigns", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      type: varchar("type", { length: 50 }).notNull(),
      // 'email', 'sms', 'push', 'multi-channel'
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      // 'draft', 'scheduled', 'active', 'paused', 'completed', 'archived'
      targetSegmentId: uuid("target_segment_id").references(() => customerSegments.id, { onDelete: "set null" }),
      // Campaign Content
      subject: varchar("subject", { length: 255 }),
      // For email
      preheaderText: varchar("preheader_text", { length: 150 }),
      // For email
      senderName: varchar("sender_name", { length: 100 }),
      senderEmail: varchar("sender_email", { length: 255 }),
      // For email
      senderPhone: varchar("sender_phone", { length: 20 }),
      // For SMS
      content: text("content").notNull(),
      // HTML for email, plain text for SMS
      plainTextContent: text("plain_text_content"),
      // Email fallback
      // Scheduling
      scheduledAt: timestamp("scheduled_at"),
      sendAt: varchar("send_at", { length: 50 }).default("immediate"),
      // 'immediate', 'scheduled', 'optimal'
      timezone: varchar("timezone", { length: 50 }).default("America/New_York"),
      // Tracking Counts
      totalRecipients: integer("total_recipients").default(0),
      sentCount: integer("sent_count").default(0),
      deliveredCount: integer("delivered_count").default(0),
      openedCount: integer("opened_count").default(0),
      clickedCount: integer("clicked_count").default(0),
      bouncedCount: integer("bounced_count").default(0),
      unsubscribedCount: integer("unsubscribed_count").default(0),
      spamCount: integer("spam_count").default(0),
      // Calculated Rates
      deliveryRate: decimal("delivery_rate", { precision: 5, scale: 2 }),
      openRate: decimal("open_rate", { precision: 5, scale: 2 }),
      clickRate: decimal("click_rate", { precision: 5, scale: 2 }),
      conversionRate: decimal("conversion_rate", { precision: 5, scale: 2 }),
      // Settings
      trackOpens: boolean("track_opens").default(true),
      trackClicks: boolean("track_clicks").default(true),
      allowUnsubscribe: boolean("allow_unsubscribe").default(true),
      testMode: boolean("test_mode").default(false),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      sentAt: timestamp("sent_at"),
      completedAt: timestamp("completed_at")
    });
    campaignRecipients = pgTable("campaign_recipients", {
      id: uuid("id").primaryKey().defaultRandom(),
      campaignId: uuid("campaign_id").notNull().references(() => marketingCampaigns.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      email: varchar("email", { length: 255 }),
      phone: varchar("phone", { length: 20 }),
      firstName: varchar("first_name", { length: 100 }),
      lastName: varchar("last_name", { length: 100 }),
      // Status Tracking
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // 'pending', 'sent', 'delivered', 'opened', 'clicked', 'bounced', 'unsubscribed', 'spam', 'failed'
      sentAt: timestamp("sent_at"),
      deliveredAt: timestamp("delivered_at"),
      openedAt: timestamp("opened_at"),
      firstClickedAt: timestamp("first_clicked_at"),
      bouncedAt: timestamp("bounced_at"),
      // Engagement Metrics
      openCount: integer("open_count").default(0),
      clickCount: integer("click_count").default(0),
      lastOpenedAt: timestamp("last_opened_at"),
      lastClickedAt: timestamp("last_clicked_at"),
      // Error Tracking
      errorMessage: text("error_message"),
      bounceType: varchar("bounce_type", { length: 50 }),
      // 'hard', 'soft', 'spam'
      // External IDs (for provider tracking)
      externalMessageId: varchar("external_message_id", { length: 255 }),
      externalStatus: varchar("external_status", { length: 100 }),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      campaignIdx: index("campaign_recipients_campaign_idx").on(table.campaignId),
      userIdx: index("campaign_recipients_user_idx").on(table.userId),
      emailIdx: index("campaign_recipients_email_idx").on(table.email)
    }));
    campaignLinks = pgTable("campaign_links", {
      id: uuid("id").primaryKey().defaultRandom(),
      campaignId: uuid("campaign_id").notNull().references(() => marketingCampaigns.id, { onDelete: "cascade" }),
      originalUrl: text("original_url").notNull(),
      shortCode: varchar("short_code", { length: 20 }).notNull().unique(),
      trackingUrl: text("tracking_url").notNull(),
      // Analytics
      clickCount: integer("click_count").default(0),
      uniqueClickCount: integer("unique_click_count").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      campaignIdx: index("campaign_links_campaign_idx").on(table.campaignId)
    }));
    campaignClicks = pgTable("campaign_clicks", {
      id: uuid("id").primaryKey().defaultRandom(),
      campaignId: uuid("campaign_id").notNull().references(() => marketingCampaigns.id, { onDelete: "cascade" }),
      recipientId: uuid("recipient_id").notNull().references(() => campaignRecipients.id, { onDelete: "cascade" }),
      linkId: uuid("link_id").notNull().references(() => campaignLinks.id, { onDelete: "cascade" }),
      // Click Details
      clickedAt: timestamp("clicked_at").defaultNow(),
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      deviceType: varchar("device_type", { length: 50 }),
      browser: varchar("browser", { length: 100 }),
      os: varchar("os", { length: 100 }),
      country: varchar("country", { length: 100 }),
      city: varchar("city", { length: 100 })
    }, (table) => ({
      campaignIdx: index("campaign_clicks_campaign_idx").on(table.campaignId),
      recipientIdx: index("campaign_clicks_recipient_idx").on(table.recipientId),
      linkIdx: index("campaign_clicks_link_idx").on(table.linkId)
    }));
    customerSegments = pgTable("customer_segments", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      // Segment Criteria (JSON)
      criteria: jsonb("criteria").notNull(),
      /* Example structure:
        {
          "rules": [
            { "field": "totalSpent", "operator": "greater_than", "value": 100 },
            { "field": "lastPurchaseDate", "operator": "within_days", "value": 30 },
            { "field": "location", "operator": "in", "value": ["Miami", "Tampa"] }
          ],
          "logic": "AND"
        }
      */
      // Segment Stats
      memberCount: integer("member_count").default(0),
      autoUpdate: boolean("auto_update").default(true),
      lastCalculatedAt: timestamp("last_calculated_at"),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      businessIdx: index("customer_segments_business_idx").on(table.businessId)
    }));
    segmentMembers = pgTable("segment_members", {
      id: uuid("id").primaryKey().defaultRandom(),
      segmentId: uuid("segment_id").notNull().references(() => customerSegments.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      addedAt: timestamp("added_at").defaultNow(),
      source: varchar("source", { length: 100 }).default("automatic")
      // 'automatic', 'manual', 'import'
    }, (table) => ({
      segmentIdx: index("segment_members_segment_idx").on(table.segmentId),
      userIdx: index("segment_members_user_idx").on(table.userId),
      uniqueMember: index("segment_members_unique").on(table.segmentId, table.userId)
    }));
    marketingWorkflows = pgTable("marketing_workflows", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      // Workflow Configuration
      triggerType: varchar("trigger_type", { length: 100 }).notNull(),
      /* e.g., "user_signup", "purchase_made", "cart_abandoned",
              "lead_created", "date_based", "segment_entry" */
      triggerConfig: jsonb("trigger_config"),
      /* Example:
        {
          "eventType": "cart_abandoned",
          "conditions": { "cartValue": { "min": 50 } },
          "delay": { "value": 1, "unit": "hours" }
        }
      */
      // Workflow Steps (JSON array)
      steps: jsonb("steps").notNull(),
      /* Example:
        [
          {
            "id": "step-1",
            "type": "delay",
            "config": { "value": 1, "unit": "hours" }
          },
          {
            "id": "step-2",
            "type": "send_email",
            "config": { "templateId": "uuid", "subject": "..." }
          },
          {
            "id": "step-3",
            "type": "condition",
            "config": { "field": "email_opened", "operator": "equals", "value": true },
            "trueStep": "step-4",
            "falseStep": "step-5"
          }
        ]
      */
      // Status
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      // 'draft', 'active', 'paused', 'archived'
      // Metrics
      totalEnrolled: integer("total_enrolled").default(0),
      activeEnrollments: integer("active_enrollments").default(0),
      completedEnrollments: integer("completed_enrollments").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      activatedAt: timestamp("activated_at")
    }, (table) => ({
      businessIdx: index("marketing_workflows_business_idx").on(table.businessId)
    }));
    workflowEnrollments = pgTable("workflow_enrollments", {
      id: uuid("id").primaryKey().defaultRandom(),
      workflowId: uuid("workflow_id").notNull().references(() => marketingWorkflows.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Enrollment Status
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // 'active', 'completed', 'exited', 'failed'
      currentStepId: varchar("current_step_id", { length: 100 }),
      currentStepStartedAt: timestamp("current_step_started_at"),
      // Tracking
      enrolledAt: timestamp("enrolled_at").defaultNow(),
      completedAt: timestamp("completed_at"),
      exitedAt: timestamp("exited_at"),
      exitReason: text("exit_reason"),
      // Enrollment Data (context for personalization)
      enrollmentData: jsonb("enrollment_data")
    }, (table) => ({
      workflowIdx: index("workflow_enrollments_workflow_idx").on(table.workflowId),
      userIdx: index("workflow_enrollments_user_idx").on(table.userId)
    }));
    workflowStepLogs = pgTable("workflow_step_logs", {
      id: uuid("id").primaryKey().defaultRandom(),
      enrollmentId: uuid("enrollment_id").notNull().references(() => workflowEnrollments.id, { onDelete: "cascade" }),
      workflowId: uuid("workflow_id").notNull().references(() => marketingWorkflows.id, { onDelete: "cascade" }),
      stepId: varchar("step_id", { length: 100 }).notNull(),
      // Step Execution
      stepType: varchar("step_type", { length: 100 }).notNull(),
      // 'send_email', 'send_sms', 'delay', 'condition'
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // 'pending', 'in_progress', 'completed', 'failed', 'skipped'
      // Details
      startedAt: timestamp("started_at").defaultNow(),
      completedAt: timestamp("completed_at"),
      errorMessage: text("error_message"),
      // Results (e.g., email sent, SMS delivered, condition result)
      result: jsonb("result")
    }, (table) => ({
      enrollmentIdx: index("workflow_step_logs_enrollment_idx").on(table.enrollmentId),
      workflowIdx: index("workflow_step_logs_workflow_idx").on(table.workflowId)
    }));
    leadCaptureForms = pgTable("lead_capture_forms", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      // Form Configuration
      fields: jsonb("fields").notNull(),
      /* Example:
        [
          { "name": "email", "type": "email", "required": true, "label": "Email Address" },
          { "name": "firstName", "type": "text", "required": true, "label": "First Name" },
          { "name": "phone", "type": "tel", "required": false, "label": "Phone Number" },
          { "name": "interests", "type": "checkbox", "options": ["Product A", "Product B"] }
        ]
      */
      // Settings
      successMessage: text("success_message").notNull().default("Thank you for your submission!"),
      redirectUrl: varchar("redirect_url", { length: 500 }),
      addToSegmentId: uuid("add_to_segment_id").references(() => customerSegments.id, { onDelete: "set null" }),
      enrollInWorkflowId: uuid("enroll_in_workflow_id").references(() => marketingWorkflows.id, { onDelete: "set null" }),
      // Tracking
      submissionCount: integer("submission_count").default(0),
      conversionRate: decimal("conversion_rate", { precision: 5, scale: 2 }),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      businessIdx: index("lead_capture_forms_business_idx").on(table.businessId)
    }));
    leadSubmissions = pgTable("lead_submissions", {
      id: uuid("id").primaryKey().defaultRandom(),
      formId: uuid("form_id").notNull().references(() => leadCaptureForms.id, { onDelete: "cascade" }),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      // Submission Data
      formData: jsonb("form_data").notNull(),
      // All form field values
      email: varchar("email", { length: 255 }),
      phone: varchar("phone", { length: 20 }),
      // Source Tracking
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      referrer: text("referrer"),
      utmSource: varchar("utm_source", { length: 100 }),
      utmMedium: varchar("utm_medium", { length: 100 }),
      utmCampaign: varchar("utm_campaign", { length: 100 }),
      // Status
      status: varchar("status", { length: 20 }).notNull().default("new"),
      // 'new', 'contacted', 'qualified', 'converted', 'archived'
      submittedAt: timestamp("submitted_at").defaultNow(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      formIdx: index("lead_submissions_form_idx").on(table.formId),
      businessIdx: index("lead_submissions_business_idx").on(table.businessId),
      emailIdx: index("lead_submissions_email_idx").on(table.email)
    }));
    marketingCampaignsRelations = relations(marketingCampaigns, ({ one, many }) => ({
      business: one(businesses, {
        fields: [marketingCampaigns.businessId],
        references: [businesses.id]
      }),
      targetSegment: one(customerSegments, {
        fields: [marketingCampaigns.targetSegmentId],
        references: [customerSegments.id]
      }),
      recipients: many(campaignRecipients),
      links: many(campaignLinks),
      clicks: many(campaignClicks)
    }));
    campaignRecipientsRelations = relations(campaignRecipients, ({ one, many }) => ({
      campaign: one(marketingCampaigns, {
        fields: [campaignRecipients.campaignId],
        references: [marketingCampaigns.id]
      }),
      user: one(users, {
        fields: [campaignRecipients.userId],
        references: [users.id]
      }),
      clicks: many(campaignClicks)
    }));
    campaignLinksRelations = relations(campaignLinks, ({ one, many }) => ({
      campaign: one(marketingCampaigns, {
        fields: [campaignLinks.campaignId],
        references: [marketingCampaigns.id]
      }),
      clicks: many(campaignClicks)
    }));
    campaignClicksRelations = relations(campaignClicks, ({ one }) => ({
      campaign: one(marketingCampaigns, {
        fields: [campaignClicks.campaignId],
        references: [marketingCampaigns.id]
      }),
      recipient: one(campaignRecipients, {
        fields: [campaignClicks.recipientId],
        references: [campaignRecipients.id]
      }),
      link: one(campaignLinks, {
        fields: [campaignClicks.linkId],
        references: [campaignLinks.id]
      })
    }));
    customerSegmentsRelations = relations(customerSegments, ({ one, many }) => ({
      business: one(businesses, {
        fields: [customerSegments.businessId],
        references: [businesses.id]
      }),
      members: many(segmentMembers),
      campaigns: many(marketingCampaigns),
      leadForms: many(leadCaptureForms)
    }));
    segmentMembersRelations = relations(segmentMembers, ({ one }) => ({
      segment: one(customerSegments, {
        fields: [segmentMembers.segmentId],
        references: [customerSegments.id]
      }),
      user: one(users, {
        fields: [segmentMembers.userId],
        references: [users.id]
      })
    }));
    marketingWorkflowsRelations = relations(marketingWorkflows, ({ one, many }) => ({
      business: one(businesses, {
        fields: [marketingWorkflows.businessId],
        references: [businesses.id]
      }),
      enrollments: many(workflowEnrollments),
      stepLogs: many(workflowStepLogs),
      leadForms: many(leadCaptureForms)
    }));
    workflowEnrollmentsRelations = relations(workflowEnrollments, ({ one, many }) => ({
      workflow: one(marketingWorkflows, {
        fields: [workflowEnrollments.workflowId],
        references: [marketingWorkflows.id]
      }),
      user: one(users, {
        fields: [workflowEnrollments.userId],
        references: [users.id]
      }),
      stepLogs: many(workflowStepLogs)
    }));
    workflowStepLogsRelations = relations(workflowStepLogs, ({ one }) => ({
      enrollment: one(workflowEnrollments, {
        fields: [workflowStepLogs.enrollmentId],
        references: [workflowEnrollments.id]
      }),
      workflow: one(marketingWorkflows, {
        fields: [workflowStepLogs.workflowId],
        references: [marketingWorkflows.id]
      })
    }));
    leadCaptureFormsRelations = relations(leadCaptureForms, ({ one, many }) => ({
      business: one(businesses, {
        fields: [leadCaptureForms.businessId],
        references: [businesses.id]
      }),
      addToSegment: one(customerSegments, {
        fields: [leadCaptureForms.addToSegmentId],
        references: [customerSegments.id]
      }),
      enrollInWorkflow: one(marketingWorkflows, {
        fields: [leadCaptureForms.enrollInWorkflowId],
        references: [marketingWorkflows.id]
      }),
      submissions: many(leadSubmissions)
    }));
    leadSubmissionsRelations = relations(leadSubmissions, ({ one }) => ({
      form: one(leadCaptureForms, {
        fields: [leadSubmissions.formId],
        references: [leadCaptureForms.id]
      }),
      business: one(businesses, {
        fields: [leadSubmissions.businessId],
        references: [businesses.id]
      }),
      user: one(users, {
        fields: [leadSubmissions.userId],
        references: [users.id]
      })
    }));
    businessesMarketingRelations = relations(businesses, ({ many }) => ({
      marketingCampaigns: many(marketingCampaigns),
      customerSegments: many(customerSegments),
      marketingWorkflows: many(marketingWorkflows),
      leadCaptureForms: many(leadCaptureForms),
      leadSubmissions: many(leadSubmissions)
    }));
    usersMarketingRelations = relations(users, ({ many }) => ({
      campaignRecipients: many(campaignRecipients),
      segmentMemberships: many(segmentMembers),
      workflowEnrollments: many(workflowEnrollments),
      leadSubmissions: many(leadSubmissions)
    }));
    insertMarketingCampaignSchema = createInsertSchema(marketingCampaigns);
    updateMarketingCampaignSchema = insertMarketingCampaignSchema.partial();
    insertCampaignRecipientSchema = createInsertSchema(campaignRecipients);
    updateCampaignRecipientSchema = insertCampaignRecipientSchema.partial();
    insertCampaignLinkSchema = createInsertSchema(campaignLinks);
    insertCampaignClickSchema = createInsertSchema(campaignClicks);
    insertCustomerSegmentSchema = createInsertSchema(customerSegments);
    updateCustomerSegmentSchema = insertCustomerSegmentSchema.partial();
    insertSegmentMemberSchema = createInsertSchema(segmentMembers);
    insertMarketingWorkflowSchema = createInsertSchema(marketingWorkflows);
    updateMarketingWorkflowSchema = insertMarketingWorkflowSchema.partial();
    insertWorkflowEnrollmentSchema = createInsertSchema(workflowEnrollments);
    updateWorkflowEnrollmentSchema = insertWorkflowEnrollmentSchema.partial();
    insertWorkflowStepLogSchema = createInsertSchema(workflowStepLogs);
    updateWorkflowStepLogSchema = insertWorkflowStepLogSchema.partial();
    insertLeadCaptureFormSchema = createInsertSchema(leadCaptureForms);
    updateLeadCaptureFormSchema = insertLeadCaptureFormSchema.partial();
    insertLeadSubmissionSchema = createInsertSchema(leadSubmissions);
    updateLeadSubmissionSchema = insertLeadSubmissionSchema.partial();
    loyaltyTiers = pgTable("loyalty_tiers", {
      id: uuid("id").primaryKey().defaultRandom(),
      name: varchar("name", { length: 50 }).notNull(),
      // Bronze, Silver, Gold, Platinum
      level: integer("level").notNull(),
      // 1, 2, 3, 4
      pointsRequired: integer("points_required").notNull(),
      // Minimum points to reach tier
      benefits: jsonb("benefits"),
      // Array of benefits
      discountPercentage: decimal("discount_percentage", { precision: 5, scale: 2 }).default("0"),
      // Tier-specific discount
      freeShippingThreshold: decimal("free_shipping_threshold", { precision: 10, scale: 2 }),
      // Free shipping above this amount
      prioritySupport: boolean("priority_support").default(false),
      // Access to priority support
      earlyAccess: boolean("early_access").default(false),
      // Early access to new products
      color: varchar("color", { length: 50 }),
      // Badge color (bronze, silver, gold, platinum)
      icon: varchar("icon", { length: 100 }),
      // Icon name or emoji
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    loyaltyAccounts = pgTable("loyalty_accounts", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
      currentPoints: integer("current_points").notNull().default(0),
      lifetimePoints: integer("lifetime_points").notNull().default(0),
      // Total points ever earned
      tierId: uuid("tier_id").references(() => loyaltyTiers.id),
      tierName: varchar("tier_name", { length: 50 }).default("Bronze"),
      // Denormalized for quick access
      tierLevel: integer("tier_level").default(1),
      enrolledAt: timestamp("enrolled_at").defaultNow(),
      lastActivityAt: timestamp("last_activity_at").defaultNow(),
      pointsExpiringNext30Days: integer("points_expiring_next_30_days").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    loyaltyTransactions = pgTable("loyalty_transactions", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      accountId: uuid("account_id").notNull().references(() => loyaltyAccounts.id, { onDelete: "cascade" }),
      type: varchar("type", { length: 50 }).notNull(),
      // earned, redeemed, expired, transferred_in, transferred_out, adjusted, bonus
      points: integer("points").notNull(),
      // Positive for earned, negative for spent
      balanceAfter: integer("balance_after").notNull(),
      source: varchar("source", { length: 100 }).notNull(),
      // purchase, review, referral, signup_bonus, reward_redemption, etc.
      sourceId: varchar("source_id"),
      // Order ID, review ID, referral ID, etc.
      description: text("description"),
      metadata: jsonb("metadata"),
      // Additional data
      expiresAt: timestamp("expires_at"),
      // When these points expire (typically 1 year)
      isExpired: boolean("is_expired").default(false),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("loyalty_transactions_user_idx").on(table.userId),
      index("loyalty_transactions_account_idx").on(table.accountId),
      index("loyalty_transactions_type_idx").on(table.type),
      index("loyalty_transactions_created_idx").on(table.createdAt)
    ]);
    loyaltyRules = pgTable("loyalty_rules", {
      id: uuid("id").primaryKey().defaultRandom(),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      eventType: varchar("event_type", { length: 100 }).notNull(),
      // purchase, review, referral, signup, share, etc.
      pointsAwarded: integer("points_awarded").notNull(),
      calculationType: varchar("calculation_type", { length: 50 }).default("fixed"),
      // fixed, percentage, tiered
      calculationValue: decimal("calculation_value", { precision: 10, scale: 2 }),
      // For percentage-based (e.g., 1% = 1 point per $1)
      minAmount: decimal("min_amount", { precision: 10, scale: 2 }),
      // Minimum purchase amount to qualify
      maxPoints: integer("max_points"),
      // Maximum points per transaction
      tierMultipliers: jsonb("tier_multipliers"),
      // { "Bronze": 1, "Silver": 1.25, "Gold": 1.5, "Platinum": 2 }
      isActive: boolean("is_active").default(true),
      startDate: timestamp("start_date"),
      endDate: timestamp("end_date"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    rewards = pgTable("rewards", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "cascade" }),
      // null for platform-wide rewards
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      imageUrl: varchar("image_url", { length: 500 }),
      pointsCost: integer("points_cost").notNull(),
      rewardType: varchar("reward_type", { length: 50 }).notNull(),
      // discount, free_product, free_shipping, gift_card, experience
      rewardValue: decimal("reward_value", { precision: 10, scale: 2 }),
      // Monetary value
      discountType: varchar("discount_type", { length: 50 }),
      // percentage, fixed_amount
      discountAmount: decimal("discount_amount", { precision: 10, scale: 2 }),
      productId: uuid("product_id").references(() => products.id),
      // For free_product rewards
      category: varchar("category", { length: 100 }),
      termsConditions: text("terms_conditions"),
      stockQuantity: integer("stock_quantity"),
      // null for unlimited
      maxRedemptionsPerUser: integer("max_redemptions_per_user"),
      // null for unlimited
      validFrom: timestamp("valid_from"),
      validUntil: timestamp("valid_until"),
      isActive: boolean("is_active").default(true),
      isFeatured: boolean("is_featured").default(false),
      tierRestriction: integer("tier_restriction"),
      // Minimum tier level required (1-4)
      redemptionCount: integer("redemption_count").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("rewards_business_idx").on(table.businessId),
      index("rewards_active_idx").on(table.isActive),
      index("rewards_featured_idx").on(table.isFeatured)
    ]);
    rewardRedemptions = pgTable("reward_redemptions", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      rewardId: uuid("reward_id").notNull().references(() => rewards.id, { onDelete: "cascade" }),
      transactionId: uuid("transaction_id").notNull().references(() => loyaltyTransactions.id),
      pointsSpent: integer("points_spent").notNull(),
      status: varchar("status", { length: 50 }).default("pending"),
      // pending, fulfilled, cancelled, expired
      redemptionCode: varchar("redemption_code", { length: 100 }).unique(),
      // Unique code for redemption
      redeemedAt: timestamp("redeemed_at").defaultNow(),
      fulfilledAt: timestamp("fulfilled_at"),
      expiresAt: timestamp("expires_at"),
      // When the reward expires if not used
      orderId: uuid("order_id").references(() => orders.id),
      // If used in an order
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("reward_redemptions_user_idx").on(table.userId),
      index("reward_redemptions_reward_idx").on(table.rewardId),
      index("reward_redemptions_status_idx").on(table.status)
    ]);
    referrals = pgTable("referrals", {
      id: uuid("id").primaryKey().defaultRandom(),
      referrerId: varchar("referrer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // User who sent referral
      refereeId: varchar("referee_id").references(() => users.id, { onDelete: "cascade" }),
      // User who was referred (null until signup)
      referralCode: varchar("referral_code", { length: 50 }).notNull().unique(),
      email: varchar("email", { length: 255 }),
      // Email of person being referred
      status: varchar("status", { length: 50 }).default("pending"),
      // pending, signed_up, completed, rewarded
      referrerRewardPoints: integer("referrer_reward_points").default(0),
      // Points given to referrer
      refereeRewardPoints: integer("referee_reward_points").default(0),
      // Points given to referee
      referrerRewarded: boolean("referrer_rewarded").default(false),
      refereeRewarded: boolean("referee_rewarded").default(false),
      refereeFirstPurchaseAt: timestamp("referee_first_purchase_at"),
      // When referee made first purchase
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      signedUpAt: timestamp("signed_up_at"),
      completedAt: timestamp("completed_at")
    }, (table) => [
      index("referrals_referrer_idx").on(table.referrerId),
      index("referrals_referee_idx").on(table.refereeId),
      index("referrals_code_idx").on(table.referralCode),
      index("referrals_status_idx").on(table.status)
    ]);
    insertLoyaltyTierSchema = createInsertSchema(loyaltyTiers);
    insertLoyaltyAccountSchema = createInsertSchema(loyaltyAccounts);
    insertLoyaltyTransactionSchema = createInsertSchema(loyaltyTransactions);
    insertLoyaltyRuleSchema = createInsertSchema(loyaltyRules);
    insertRewardSchema = createInsertSchema(rewards);
    insertRewardRedemptionSchema = createInsertSchema(rewardRedemptions);
    insertReferralSchema = createInsertSchema(referrals);
    dailyMetrics = pgTable("daily_metrics", {
      id: uuid("id").primaryKey().defaultRandom(),
      date: timestamp("date").notNull(),
      // Date for these metrics (start of day UTC)
      // Revenue metrics
      totalRevenue: decimal("total_revenue", { precision: 12, scale: 2 }).default("0"),
      orderCount: integer("order_count").default(0),
      averageOrderValue: decimal("average_order_value", { precision: 12, scale: 2 }).default("0"),
      // User metrics
      newUsers: integer("new_users").default(0),
      activeUsers: integer("active_users").default(0),
      returningUsers: integer("returning_users").default(0),
      // Business metrics
      newBusinesses: integer("new_businesses").default(0),
      activeBusinesses: integer("active_businesses").default(0),
      // Product metrics
      productsListed: integer("products_listed").default(0),
      productsSold: integer("products_sold").default(0),
      // Loyalty metrics
      pointsEarned: integer("points_earned").default(0),
      pointsRedeemed: integer("points_redeemed").default(0),
      rewardsRedeemed: integer("rewards_redeemed").default(0),
      // Engagement metrics
      reviewsCreated: integer("reviews_created").default(0),
      messagesExchanged: integer("messages_exchanged").default(0),
      socialShares: integer("social_shares").default(0),
      // Referral metrics
      referralsSent: integer("referrals_sent").default(0),
      referralsCompleted: integer("referrals_completed").default(0),
      // Metadata
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      uniqueIndex("daily_metrics_date_idx").on(table.date)
    ]);
    businessMetrics = pgTable("business_metrics", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      date: timestamp("date").notNull(),
      // Performance metrics
      views: integer("views").default(0),
      uniqueVisitors: integer("unique_visitors").default(0),
      clicks: integer("clicks").default(0),
      // Sales metrics
      revenue: decimal("revenue", { precision: 12, scale: 2 }).default("0"),
      orders: integer("orders").default(0),
      productsListedCount: integer("products_listed_count").default(0),
      productsSoldCount: integer("products_sold_count").default(0),
      // Customer metrics
      newCustomers: integer("new_customers").default(0),
      returningCustomers: integer("returning_customers").default(0),
      averageOrderValue: decimal("average_order_value", { precision: 12, scale: 2 }).default("0"),
      // Engagement metrics
      reviewsReceived: integer("reviews_received").default(0),
      averageRating: decimal("average_rating", { precision: 3, scale: 2 }).default("0"),
      messagesReceived: integer("messages_received").default(0),
      messagesReplied: integer("messages_replied").default(0),
      // Spotlight metrics
      spotlightVotes: integer("spotlight_votes").default(0),
      spotlightWins: integer("spotlight_wins").default(0),
      // Metadata
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("business_metrics_business_idx").on(table.businessId),
      index("business_metrics_date_idx").on(table.date),
      uniqueIndex("business_metrics_unique_idx").on(table.businessId, table.date)
    ]);
    userMetrics = pgTable("user_metrics", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      date: timestamp("date").notNull(),
      // Activity metrics
      pageViews: integer("page_views").default(0),
      sessionDuration: integer("session_duration").default(0),
      // seconds
      actionsCount: integer("actions_count").default(0),
      // Purchase metrics
      ordersPlaced: integer("orders_placed").default(0),
      totalSpent: decimal("total_spent", { precision: 12, scale: 2 }).default("0"),
      // Engagement metrics
      reviewsWritten: integer("reviews_written").default(0),
      messagesSent: integer("messages_sent").default(0),
      socialShares: integer("social_shares").default(0),
      // Loyalty metrics
      pointsEarned: integer("points_earned").default(0),
      pointsSpent: integer("points_spent").default(0),
      rewardsRedeemed: integer("rewards_redeemed").default(0),
      // Metadata
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("user_metrics_user_idx").on(table.userId),
      index("user_metrics_date_idx").on(table.date),
      uniqueIndex("user_metrics_unique_idx").on(table.userId, table.date)
    ]);
    productMetrics = pgTable("product_metrics", {
      id: uuid("id").primaryKey().defaultRandom(),
      productId: uuid("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      date: timestamp("date").notNull(),
      // Visibility metrics
      views: integer("views").default(0),
      uniqueViewers: integer("unique_viewers").default(0),
      searchAppearances: integer("search_appearances").default(0),
      // Sales metrics
      unitsSold: integer("units_sold").default(0),
      revenue: decimal("revenue", { precision: 12, scale: 2 }).default("0"),
      ordersCount: integer("orders_count").default(0),
      // Conversion metrics
      addToCartCount: integer("add_to_cart_count").default(0),
      checkoutCount: integer("checkout_count").default(0),
      purchaseCount: integer("purchase_count").default(0),
      // Engagement metrics
      likesCount: integer("likes_count").default(0),
      sharesCount: integer("shares_count").default(0),
      // Inventory metrics
      stockLevel: integer("stock_level").default(0),
      restockCount: integer("restock_count").default(0),
      // Metadata
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("product_metrics_product_idx").on(table.productId),
      index("product_metrics_date_idx").on(table.date),
      uniqueIndex("product_metrics_unique_idx").on(table.productId, table.date)
    ]);
    analyticsEvents = pgTable("analytics_events", {
      id: uuid("id").primaryKey().defaultRandom(),
      eventType: varchar("event_type", { length: 100 }).notNull(),
      // page_view, click, purchase, etc.
      eventCategory: varchar("event_category", { length: 100 }),
      // user_action, business_action, system_event
      // Context
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "set null" }),
      productId: uuid("product_id").references(() => products.id, { onDelete: "set null" }),
      orderId: uuid("order_id").references(() => orders.id, { onDelete: "set null" }),
      // Session info
      sessionId: varchar("session_id", { length: 255 }),
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      // Event details
      eventData: jsonb("event_data"),
      // Timing
      timestamp: timestamp("timestamp").defaultNow().notNull(),
      processingTime: integer("processing_time"),
      // milliseconds
      // Metadata
      metadata: jsonb("metadata")
    }, (table) => [
      index("analytics_events_type_idx").on(table.eventType),
      index("analytics_events_user_idx").on(table.userId),
      index("analytics_events_business_idx").on(table.businessId),
      index("analytics_events_timestamp_idx").on(table.timestamp)
    ]);
    customerCohorts = pgTable("customer_cohorts", {
      id: uuid("id").primaryKey().defaultRandom(),
      cohortName: varchar("cohort_name", { length: 100 }).notNull(),
      cohortType: varchar("cohort_type", { length: 50 }).notNull(),
      // signup_month, first_purchase_month, tier_based
      cohortDate: timestamp("cohort_date").notNull(),
      // Start date of cohort (e.g., 2025-01-01 for Jan 2025 cohort)
      // Cohort metrics
      userCount: integer("user_count").default(0),
      activeUsers: integer("active_users").default(0),
      retentionRate: decimal("retention_rate", { precision: 5, scale: 2 }).default("0"),
      // Revenue metrics
      totalRevenue: decimal("total_revenue", { precision: 12, scale: 2 }).default("0"),
      averageRevenuePerUser: decimal("average_revenue_per_user", { precision: 12, scale: 2 }).default("0"),
      // Engagement metrics
      averageOrdersPerUser: decimal("average_orders_per_user", { precision: 8, scale: 2 }).default("0"),
      averageLifetimeValue: decimal("average_lifetime_value", { precision: 12, scale: 2 }).default("0"),
      // Metadata
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("cohorts_date_idx").on(table.cohortDate),
      index("cohorts_type_idx").on(table.cohortType),
      uniqueIndex("cohorts_unique_idx").on(table.cohortName, table.cohortDate)
    ]);
    conversionFunnels = pgTable("conversion_funnels", {
      id: uuid("id").primaryKey().defaultRandom(),
      funnelName: varchar("funnel_name", { length: 100 }).notNull(),
      date: timestamp("date").notNull(),
      // Funnel steps (generic for flexibility)
      step1Count: integer("step1_count").default(0),
      step2Count: integer("step2_count").default(0),
      step3Count: integer("step3_count").default(0),
      step4Count: integer("step4_count").default(0),
      step5Count: integer("step5_count").default(0),
      // Conversion rates
      step1ToStep2Rate: decimal("step1_to_step2_rate", { precision: 5, scale: 2 }).default("0"),
      step2ToStep3Rate: decimal("step2_to_step3_rate", { precision: 5, scale: 2 }).default("0"),
      step3ToStep4Rate: decimal("step3_to_step4_rate", { precision: 5, scale: 2 }).default("0"),
      step4ToStep5Rate: decimal("step4_to_step5_rate", { precision: 5, scale: 2 }).default("0"),
      overallConversionRate: decimal("overall_conversion_rate", { precision: 5, scale: 2 }).default("0"),
      // Metadata (store step names, etc.)
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("funnels_name_idx").on(table.funnelName),
      index("funnels_date_idx").on(table.date),
      uniqueIndex("funnels_unique_idx").on(table.funnelName, table.date)
    ]);
    insertDailyMetricsSchema = createInsertSchema(dailyMetrics);
    insertBusinessMetricsSchema = createInsertSchema(businessMetrics);
    insertUserMetricsSchema = createInsertSchema(userMetrics);
    insertProductMetricsSchema = createInsertSchema(productMetrics);
    insertAnalyticsEventSchema = createInsertSchema(analyticsEvents);
    insertCustomerCohortSchema = createInsertSchema(customerCohorts);
    insertConversionFunnelSchema = createInsertSchema(conversionFunnels);
    socialAccounts = pgTable("social_accounts", {
      id: text("id").primaryKey(),
      userId: text("user_id").notNull().references(() => users.id),
      businessId: uuid("business_id").references(() => businesses.id),
      platform: text("platform").notNull(),
      // facebook, instagram, twitter, linkedin, tiktok, pinterest, youtube
      accountId: text("account_id").notNull(),
      // Platform-specific account ID
      accountName: text("account_name"),
      accountHandle: text("account_handle"),
      profileUrl: text("profile_url"),
      profileImageUrl: text("profile_image_url"),
      isActive: boolean("is_active").default(true),
      metadata: jsonb("metadata"),
      // Platform-specific metadata
      lastSyncedAt: timestamp("last_synced_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("social_accounts_user_idx").on(table.userId),
      index("social_accounts_business_idx").on(table.businessId),
      index("social_accounts_platform_idx").on(table.platform),
      uniqueIndex("social_accounts_unique_idx").on(table.userId, table.platform, table.accountId)
    ]);
    socialTokens = pgTable("social_tokens", {
      id: text("id").primaryKey(),
      socialAccountId: text("social_account_id").notNull().references(() => socialAccounts.id, { onDelete: "cascade" }),
      accessToken: text("access_token").notNull(),
      refreshToken: text("refresh_token"),
      expiresAt: timestamp("expires_at"),
      scopes: jsonb("scopes").$type(),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      uniqueIndex("social_tokens_account_idx").on(table.socialAccountId)
    ]);
    socialPosts = pgTable("social_posts", {
      id: text("id").primaryKey(),
      socialAccountId: text("social_account_id").notNull().references(() => socialAccounts.id),
      businessId: uuid("business_id").references(() => businesses.id),
      platformPostId: text("platform_post_id"),
      // ID on the social platform
      platform: text("platform").notNull(),
      postType: text("post_type").notNull(),
      // post, story, reel, video, etc.
      content: text("content"),
      mediaUrls: jsonb("media_urls").$type(),
      hashtags: jsonb("hashtags").$type(),
      mentions: jsonb("mentions").$type(),
      scheduledFor: timestamp("scheduled_for"),
      publishedAt: timestamp("published_at"),
      status: text("status").notNull(),
      // draft, scheduled, published, failed
      metrics: jsonb("metrics"),
      // likes, comments, shares, views, etc.
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("social_posts_account_idx").on(table.socialAccountId),
      index("social_posts_business_idx").on(table.businessId),
      index("social_posts_status_idx").on(table.status),
      index("social_posts_scheduled_idx").on(table.scheduledFor)
    ]);
    socialAnalytics = pgTable("social_analytics", {
      id: text("id").primaryKey(),
      socialAccountId: text("social_account_id").notNull().references(() => socialAccounts.id),
      businessId: uuid("business_id").references(() => businesses.id),
      platform: text("platform").notNull(),
      date: date("date").notNull(),
      metrics: jsonb("metrics").notNull(),
      // Platform-specific metrics
      insights: jsonb("insights"),
      // AI-generated insights
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("social_analytics_account_idx").on(table.socialAccountId),
      index("social_analytics_date_idx").on(table.date),
      uniqueIndex("social_analytics_unique_idx").on(table.socialAccountId, table.date)
    ]);
    insertSocialAccountSchema = createInsertSchema(socialAccounts);
    insertSocialTokenSchema = createInsertSchema(socialTokens);
    insertSocialPostSchema = createInsertSchema(socialPosts);
    insertSocialAnalyticsSchema = createInsertSchema(socialAnalytics);
    adminRoles = pgTable("admin_roles", {
      id: uuid("id").primaryKey().defaultRandom(),
      name: varchar("name", { length: 100 }).notNull().unique(),
      description: text("description"),
      permissions: jsonb("permissions").$type().notNull(),
      // Array of permission strings
      isSystemRole: boolean("is_system_role").default(false),
      // Cannot be deleted/modified
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    userRoles = pgTable("user_roles", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      roleId: uuid("role_id").notNull().references(() => adminRoles.id, { onDelete: "cascade" }),
      assignedBy: varchar("assigned_by").notNull().references(() => users.id),
      // Admin who assigned the role
      assignedAt: timestamp("assigned_at").defaultNow()
    }, (table) => [
      index("user_roles_user_idx").on(table.userId),
      index("user_roles_role_idx").on(table.roleId),
      uniqueIndex("user_roles_unique_idx").on(table.userId, table.roleId)
    ]);
    adminAuditLogs = pgTable("admin_audit_logs", {
      id: uuid("id").primaryKey().defaultRandom(),
      adminId: varchar("admin_id").notNull().references(() => users.id),
      // Admin who performed action
      action: varchar("action", { length: 100 }).notNull(),
      // user.promote, business.verify, content.moderate, etc.
      entityType: varchar("entity_type", { length: 50 }).notNull(),
      // user, business, post, product, etc.
      entityId: varchar("entity_id", { length: 255 }).notNull(),
      // ID of affected entity
      changes: jsonb("changes"),
      // Before/after state
      reason: text("reason"),
      // Optional reason for action
      ipAddress: varchar("ip_address", { length: 45 }),
      // IPv4 or IPv6
      userAgent: text("user_agent"),
      sessionId: varchar("session_id", { length: 255 }),
      status: varchar("status", { length: 20 }).default("success"),
      // success, failed, partial
      errorMessage: text("error_message"),
      // If status is failed
      metadata: jsonb("metadata"),
      // Additional context
      timestamp: timestamp("timestamp").defaultNow().notNull()
    }, (table) => [
      index("audit_logs_admin_idx").on(table.adminId),
      index("audit_logs_action_idx").on(table.action),
      index("audit_logs_entity_idx").on(table.entityType, table.entityId),
      index("audit_logs_timestamp_idx").on(table.timestamp)
    ]);
    errorLogs = pgTable("error_logs", {
      id: uuid("id").primaryKey().defaultRandom(),
      errorHash: varchar("error_hash", { length: 64 }).notNull(),
      // Hash of error type + message
      message: text("message").notNull(),
      stack: text("stack"),
      category: varchar("category", { length: 50 }).notNull(),
      // From ErrorCategory enum
      severity: varchar("severity", { length: 20 }).notNull(),
      // From ErrorSeverity enum
      userId: varchar("user_id"),
      // User who encountered error (if authenticated)
      requestPath: varchar("request_path", { length: 500 }),
      requestMethod: varchar("request_method", { length: 10 }),
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      count: integer("count").default(1),
      // Number of occurrences
      firstSeenAt: timestamp("first_seen_at").defaultNow().notNull(),
      lastSeenAt: timestamp("last_seen_at").defaultNow().notNull(),
      resolved: boolean("resolved").default(false),
      resolvedBy: varchar("resolved_by").references(() => users.id),
      resolvedAt: timestamp("resolved_at"),
      notes: text("notes")
      // Admin notes on resolution
    }, (table) => [
      index("error_logs_hash_idx").on(table.errorHash),
      index("error_logs_category_idx").on(table.category),
      index("error_logs_severity_idx").on(table.severity),
      index("error_logs_resolved_idx").on(table.resolved),
      index("error_logs_last_seen_idx").on(table.lastSeenAt)
    ]);
    premiumAdSlots = pgTable("premium_ad_slots", {
      id: uuid("id").primaryKey().defaultRandom(),
      companyName: varchar("company_name", { length: 255 }).notNull(),
      tagline: text("tagline"),
      imageUrl: varchar("image_url", { length: 500 }),
      isPremium: boolean("is_premium").default(false),
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "set null" }),
      displayOrder: integer("display_order").default(0),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      expiresAt: timestamp("expires_at")
    }, (table) => [
      index("premium_slots_active_idx").on(table.isActive),
      index("premium_slots_order_idx").on(table.displayOrder)
    ]);
    chatConversations = pgTable("chat_conversations", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      sessionId: varchar("session_id", { length: 100 }).notNull(),
      // Browser session ID
      title: varchar("title", { length: 255 }),
      // Auto-generated from first message
      status: varchar("status", { length: 20 }).default("active").notNull(),
      // active, resolved, escalated, archived
      channel: varchar("channel", { length: 50 }).default("widget").notNull(),
      // widget, mobile, api, sms
      businessId: uuid("business_id").references(() => businesses.id, { onDelete: "set null" }),
      // If discussing specific business
      // Context & Metadata
      metadata: jsonb("metadata"),
      // { page, referrer, utmParams, deviceInfo, etc. }
      tags: jsonb("tags").$type().default(sql`'[]'::jsonb`),
      // ["support", "billing", "product-inquiry"]
      intent: varchar("intent", { length: 50 }),
      // question, complaint, booking, purchase, feedback
      sentiment: varchar("sentiment", { length: 20 }),
      // positive, neutral, negative, frustrated
      language: varchar("language", { length: 10 }).default("en"),
      // ISO language code
      // Analytics
      messageCount: integer("message_count").default(0),
      satisfactionScore: integer("satisfaction_score"),
      // 1-5 rating
      satisfactionComment: text("satisfaction_comment"),
      resolved: boolean("resolved").default(false),
      resolvedAt: timestamp("resolved_at"),
      resolutionTime: integer("resolution_time"),
      // Seconds from start to resolution
      // Human handoff
      escalated: boolean("escalated").default(false),
      escalatedAt: timestamp("escalated_at"),
      escalatedTo: varchar("escalated_to").references(() => users.id),
      // Support agent
      escalationReason: text("escalation_reason"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      lastMessageAt: timestamp("last_message_at").defaultNow().notNull()
    }, (table) => [
      index("chat_conversations_user_idx").on(table.userId),
      index("chat_conversations_session_idx").on(table.sessionId),
      index("chat_conversations_status_idx").on(table.status),
      index("chat_conversations_created_idx").on(table.createdAt),
      index("chat_conversations_business_idx").on(table.businessId),
      index("chat_conversations_escalated_idx").on(table.escalated, table.escalatedTo)
    ]);
    chatMessages = pgTable("chat_messages", {
      id: uuid("id").primaryKey().defaultRandom(),
      conversationId: uuid("conversation_id").notNull().references(() => chatConversations.id, { onDelete: "cascade" }),
      role: varchar("role", { length: 20 }).notNull(),
      // user, assistant, system, agent
      content: text("content").notNull(),
      // Rich message features
      messageType: varchar("message_type", { length: 50 }).default("text"),
      // text, card, carousel, quick_reply, file
      attachments: jsonb("attachments"),
      // [{ type, url, name, size }]
      metadata: jsonb("metadata"),
      // For rich cards, buttons, actions
      // AI-specific fields
      model: varchar("model", { length: 50 }),
      // gpt-4, gpt-3.5-turbo, claude-3
      tokens: integer("tokens"),
      // Token usage for cost tracking
      latency: integer("latency"),
      // Response time in milliseconds
      temperature: decimal("temperature", { precision: 3, scale: 2 }),
      // Model temperature used
      // Context & Analysis
      intent: varchar("intent", { length: 50 }),
      // Detected intent
      sentiment: varchar("sentiment", { length: 20 }),
      // Message-level sentiment
      entities: jsonb("entities"),
      // Extracted entities: {orderNumber, businessName, date, etc.}
      knowledgeBaseUsed: boolean("knowledge_base_used").default(false),
      knowledgeBaseArticles: jsonb("knowledge_base_articles").$type(),
      // Article IDs used
      // Feedback & Quality
      helpful: boolean("helpful"),
      // User feedback: thumbs up/down
      feedbackComment: text("feedback_comment"),
      flagged: boolean("flagged").default(false),
      // For review
      flagReason: text("flag_reason"),
      // Status
      status: varchar("status", { length: 20 }).default("sent"),
      // pending, sent, delivered, read, failed
      errorMessage: text("error_message"),
      // If failed
      createdAt: timestamp("created_at").defaultNow().notNull(),
      readAt: timestamp("read_at")
    }, (table) => [
      index("chat_messages_conversation_idx").on(table.conversationId),
      index("chat_messages_created_idx").on(table.createdAt),
      index("chat_messages_role_idx").on(table.role),
      index("chat_messages_flagged_idx").on(table.flagged)
    ]);
    chatKnowledgeBase = pgTable("chat_knowledge_base", {
      id: uuid("id").primaryKey().defaultRandom(),
      category: varchar("category", { length: 100 }).notNull(),
      // products, billing, shipping, account, etc.
      subcategory: varchar("subcategory", { length: 100 }),
      // Content
      question: text("question").notNull(),
      // The question or topic
      answer: text("answer").notNull(),
      // The answer/content
      alternativeQuestions: jsonb("alternative_questions").$type(),
      // Different ways to ask
      keywords: jsonb("keywords").$type(),
      // For matching
      // SEO & Metadata
      title: varchar("title", { length: 255 }),
      // Display title
      slug: varchar("slug", { length: 255 }).unique(),
      summary: text("summary"),
      // Short summary
      relatedArticles: jsonb("related_articles").$type(),
      // Related article IDs
      externalLinks: jsonb("external_links"),
      // [{ title, url }]
      // Vector embeddings for semantic search
      embedding: text("embedding"),
      // JSON stringified vector (or use pgvector extension)
      embeddingModel: varchar("embedding_model", { length: 50 }),
      // text-embedding-ada-002
      // Usage analytics
      viewCount: integer("view_count").default(0),
      useCount: integer("use_count").default(0),
      // Times used in chat responses
      helpfulCount: integer("helpful_count").default(0),
      notHelpfulCount: integer("not_helpful_count").default(0),
      // Management
      isActive: boolean("is_active").default(true),
      priority: integer("priority").default(0),
      // Higher = shown first
      createdBy: varchar("created_by").references(() => users.id),
      lastEditedBy: varchar("last_edited_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("chat_kb_category_idx").on(table.category),
      index("chat_kb_active_idx").on(table.isActive),
      index("chat_kb_priority_idx").on(table.priority),
      index("chat_kb_slug_idx").on(table.slug)
    ]);
    chatSessions = pgTable("chat_sessions", {
      id: uuid("id").primaryKey().defaultRandom(),
      sessionId: varchar("session_id", { length: 100 }).notNull().unique(),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      // Null for anonymous
      // Device & Browser Info
      deviceInfo: jsonb("device_info"),
      // { browser, os, device, screen }
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      location: jsonb("location"),
      // { country, region, city, timezone }
      // Context
      initialPage: varchar("initial_page", { length: 500 }),
      // Landing page
      referrer: varchar("referrer", { length: 500 }),
      utmParams: jsonb("utm_params"),
      // UTM tracking parameters
      // Activity tracking
      pageViews: jsonb("page_views").$type(),
      lastActivity: timestamp("last_activity").defaultNow().notNull(),
      isActive: boolean("is_active").default(true),
      // Engagement
      conversationCount: integer("conversation_count").default(0),
      messagesSent: integer("messages_sent").default(0),
      avgResponseTime: integer("avg_response_time"),
      // Milliseconds
      createdAt: timestamp("created_at").defaultNow().notNull(),
      expiresAt: timestamp("expires_at")
      // Session expiry
    }, (table) => [
      index("chat_sessions_session_id_idx").on(table.sessionId),
      index("chat_sessions_user_idx").on(table.userId),
      index("chat_sessions_active_idx").on(table.isActive),
      index("chat_sessions_last_activity_idx").on(table.lastActivity)
    ]);
    chatAnalytics = pgTable("chat_analytics", {
      id: uuid("id").primaryKey().defaultRandom(),
      conversationId: uuid("conversation_id").notNull().references(() => chatConversations.id, { onDelete: "cascade" }),
      // Conversation metrics
      duration: integer("duration").notNull(),
      // Total conversation time in seconds
      messageCount: integer("message_count").notNull(),
      userMessageCount: integer("user_message_count").notNull(),
      assistantMessageCount: integer("assistant_message_count").notNull(),
      // Response times
      avgResponseTime: integer("avg_response_time"),
      // Average AI response time (ms)
      minResponseTime: integer("min_response_time"),
      maxResponseTime: integer("max_response_time"),
      // AI metrics
      totalTokens: integer("total_tokens"),
      totalCost: decimal("total_cost", { precision: 10, scale: 4 }),
      // USD
      modelsUsed: jsonb("models_used").$type(),
      // Quality metrics
      sentimentProgression: jsonb("sentiment_progression"),
      // Track sentiment over time
      intentChanges: integer("intent_changes"),
      // How many times intent changed
      knowledgeBaseHitRate: decimal("kb_hit_rate", { precision: 5, scale: 2 }),
      // % of answers from KB
      // Outcomes
      resolved: boolean("resolved").notNull(),
      escalated: boolean("escalated").notNull(),
      satisfactionScore: integer("satisfaction_score"),
      conversionEvent: varchar("conversion_event", { length: 100 }),
      // signup, purchase, demo_booked
      conversionValue: decimal("conversion_value", { precision: 10, scale: 2 }),
      // Context
      peakHour: integer("peak_hour"),
      // Hour of day (0-23)
      dayOfWeek: integer("day_of_week"),
      // 0-6
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("chat_analytics_conversation_idx").on(table.conversationId),
      index("chat_analytics_created_idx").on(table.createdAt),
      index("chat_analytics_resolved_idx").on(table.resolved)
    ]);
    chatQuickActions = pgTable("chat_quick_actions", {
      id: uuid("id").primaryKey().defaultRandom(),
      // Action config
      label: varchar("label", { length: 100 }).notNull(),
      // "Book Demo", "Contact Sales"
      actionType: varchar("action_type", { length: 50 }).notNull(),
      // navigate, api_call, modal, email
      actionPayload: jsonb("action_payload").notNull(),
      // { url, endpoint, modalId, etc. }
      // Display
      icon: varchar("icon", { length: 50 }),
      // Lucide icon name
      variant: varchar("variant", { length: 20 }).default("default"),
      // default, primary, outline
      description: text("description"),
      // Targeting
      showOnPages: jsonb("show_on_pages").$type(),
      // Pages where this action appears
      showForIntents: jsonb("show_for_intents").$type(),
      // Show for specific intents
      requiresAuth: boolean("requires_auth").default(false),
      // Analytics
      clickCount: integer("click_count").default(0),
      conversionCount: integer("conversion_count").default(0),
      // Management
      displayOrder: integer("display_order").default(0),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("chat_quick_actions_active_idx").on(table.isActive),
      index("chat_quick_actions_order_idx").on(table.displayOrder)
    ]);
    chatProactiveTriggers = pgTable("chat_proactive_triggers", {
      id: uuid("id").primaryKey().defaultRandom(),
      // Trigger config
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      triggerType: varchar("trigger_type", { length: 50 }).notNull(),
      // time_on_page, scroll_depth, exit_intent, cart_abandon, error_404
      // Conditions
      conditions: jsonb("conditions").notNull(),
      // { pages, minTime, scrollPercent, etc. }
      message: text("message").notNull(),
      // The proactive message to show
      quickReplies: jsonb("quick_replies").$type(),
      // Suggested responses
      // Targeting
      targetPages: jsonb("target_pages").$type(),
      requiresAuth: boolean("requires_auth").default(false),
      excludeIfConversationExists: boolean("exclude_if_conversation_exists").default(true),
      // Frequency control
      maxShowsPerSession: integer("max_shows_per_session").default(1),
      cooldownMinutes: integer("cooldown_minutes").default(60),
      // Analytics
      showCount: integer("show_count").default(0),
      engagementCount: integer("engagement_count").default(0),
      engagementRate: decimal("engagement_rate", { precision: 5, scale: 2 }),
      // Management
      priority: integer("priority").default(0),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("chat_proactive_active_idx").on(table.isActive),
      index("chat_proactive_priority_idx").on(table.priority)
    ]);
    failedLoginAttempts = pgTable("failed_login_attempts", {
      id: uuid("id").primaryKey().defaultRandom(),
      email: varchar("email", { length: 255 }).notNull(),
      ipAddress: varchar("ip_address", { length: 45 }).notNull(),
      // IPv6 support
      userAgent: text("user_agent"),
      failureReason: varchar("failure_reason", { length: 100 }),
      // wrong_password, account_not_found, etc.
      attemptTime: timestamp("attempt_time").defaultNow().notNull(),
      geoLocation: jsonb("geo_location")
      // { country, city, region, lat, lon }
    }, (table) => [
      index("idx_failed_login_email").on(table.email),
      index("idx_failed_login_ip").on(table.ipAddress),
      index("idx_failed_login_time").on(table.attemptTime)
    ]);
    accountLockouts = pgTable("account_lockouts", {
      id: uuid("id").primaryKey().defaultRandom(),
      email: varchar("email", { length: 255 }).notNull(),
      lockoutType: varchar("lockout_type", { length: 20 }).notNull(),
      // temporary, permanent
      lockedAt: timestamp("locked_at").defaultNow().notNull(),
      lockedUntil: timestamp("locked_until"),
      // null for permanent lockouts
      unlockedAt: timestamp("unlocked_at"),
      // when admin manually unlocked
      unlockedBy: varchar("unlocked_by").references(() => users.id),
      reason: text("reason"),
      attemptCount: integer("attempt_count").notNull().default(0)
    }, (table) => [
      index("idx_lockout_email").on(table.email),
      index("idx_lockout_active").on(table.lockedUntil, table.unlockedAt)
    ]);
    ipAccessControl = pgTable("ip_access_control", {
      id: uuid("id").primaryKey().defaultRandom(),
      ipAddress: varchar("ip_address", { length: 45 }).notNull(),
      // Single IP or CIDR notation
      ipRange: varchar("ip_range", { length: 100 }),
      // For IP ranges
      accessType: varchar("access_type", { length: 10 }).notNull(),
      // block, allow
      reason: text("reason"),
      expiresAt: timestamp("expires_at"),
      // null for permanent
      isActive: boolean("is_active").default(true),
      createdBy: varchar("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      uniqueIndex("idx_unique_ip_access").on(table.ipAddress, table.accessType),
      index("idx_ip_access_active").on(table.isActive, table.expiresAt)
    ]);
    geoRestrictions = pgTable("geo_restrictions", {
      id: uuid("id").primaryKey().defaultRandom(),
      countryCode: varchar("country_code", { length: 2 }).notNull(),
      // ISO 3166-1 alpha-2
      regionCode: varchar("region_code", { length: 10 }),
      // State/province code
      restrictionType: varchar("restriction_type", { length: 10 }).notNull(),
      // block, allow
      reason: text("reason"),
      isActive: boolean("is_active").default(true),
      createdBy: varchar("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      uniqueIndex("idx_unique_geo_restriction").on(table.countryCode, table.regionCode, table.restrictionType),
      index("idx_geo_restriction_active").on(table.isActive)
    ]);
    securityEvents = pgTable("security_events", {
      id: uuid("id").primaryKey().defaultRandom(),
      eventType: varchar("event_type", { length: 100 }).notNull(),
      // login_failed, session_hijack, ip_blocked, etc.
      severity: varchar("severity", { length: 20 }).notNull(),
      // info, warning, high, critical
      userId: varchar("user_id").references(() => users.id),
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      description: text("description").notNull(),
      metadata: jsonb("metadata"),
      // Additional event-specific data
      resolved: boolean("resolved").default(false),
      resolvedAt: timestamp("resolved_at"),
      resolvedBy: varchar("resolved_by").references(() => users.id),
      notificationSent: boolean("notification_sent").default(false),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("idx_security_event_type").on(table.eventType),
      index("idx_security_event_severity").on(table.severity),
      index("idx_security_event_user").on(table.userId),
      index("idx_security_event_created").on(table.createdAt)
    ]);
    activeSessions = pgTable("active_sessions", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      sessionId: varchar("session_id", { length: 255 }).notNull().unique(),
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      deviceType: varchar("device_type", { length: 50 }),
      // desktop, mobile, tablet
      browser: varchar("browser", { length: 100 }),
      os: varchar("os", { length: 100 }),
      isCurrent: boolean("is_current").default(false),
      lastActivity: timestamp("last_activity").defaultNow().notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("idx_active_session_user").on(table.userId),
      index("idx_active_session_id").on(table.sessionId),
      index("idx_active_session_expires").on(table.expiresAt)
    ]);
    securityNotifications = pgTable("security_notifications", {
      id: uuid("id").primaryKey().defaultRandom(),
      recipientEmail: varchar("recipient_email", { length: 255 }).notNull(),
      recipientPhone: varchar("recipient_phone", { length: 20 }),
      notificationType: varchar("notification_type", { length: 50 }).notNull(),
      // email, sms, both
      subject: varchar("subject", { length: 255 }).notNull(),
      message: text("message").notNull(),
      priority: varchar("priority", { length: 20 }).notNull().default("normal"),
      // low, normal, high, critical
      metadata: jsonb("metadata"),
      // Event details, user info, etc.
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, processing, sent, failed
      attempts: integer("attempts").default(0),
      sentAt: timestamp("sent_at"),
      failureReason: text("failure_reason"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("idx_notification_status").on(table.status),
      index("idx_notification_priority").on(table.priority),
      index("idx_notification_created").on(table.createdAt)
    ]);
    authAuditLogs = pgTable("auth_audit_logs", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").references(() => users.id),
      eventType: varchar("event_type", { length: 50 }).notNull(),
      // login_success, login_failed, logout, session_expired, password_changed
      eventStatus: varchar("event_status", { length: 20 }).notNull(),
      // success, failure, pending
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      sessionId: varchar("session_id", { length: 255 }),
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("idx_auth_audit_user").on(table.userId),
      index("idx_auth_audit_type").on(table.eventType),
      index("idx_auth_audit_created").on(table.createdAt)
    ]);
    rateLimitRecords = pgTable("rate_limit_records", {
      id: uuid("id").primaryKey().defaultRandom(),
      identifier: varchar("identifier", { length: 255 }).notNull(),
      // IP, userId, or composite key
      limitType: varchar("limit_type", { length: 50 }).notNull(),
      // api, login, registration, etc.
      attempts: integer("attempts").notNull().default(1),
      windowStart: timestamp("window_start").notNull(),
      windowEnd: timestamp("window_end").notNull(),
      blocked: boolean("blocked").default(false),
      blockedUntil: timestamp("blocked_until"),
      metadata: jsonb("metadata"),
      // Additional context
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      uniqueIndex("idx_unique_rate_limit").on(table.identifier, table.limitType, table.windowStart),
      index("idx_rate_limit_identifier").on(table.identifier),
      index("idx_rate_limit_window").on(table.windowEnd)
    ]);
    rateLimitViolations = pgTable("rate_limit_violations", {
      id: uuid("id").primaryKey().defaultRandom(),
      identifier: varchar("identifier", { length: 255 }).notNull(),
      // IP address or user ID
      ipAddress: varchar("ip_address", { length: 45 }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      endpoint: varchar("endpoint", { length: 255 }).notNull(),
      violationType: varchar("violation_type", { length: 50 }).notNull(),
      // rate_limit_exceeded, suspicious_pattern
      requestCount: integer("request_count").notNull(),
      timeWindow: integer("time_window").notNull(),
      // seconds
      penalty: varchar("penalty", { length: 50 }),
      // throttled, blocked, warned
      penaltyDuration: integer("penalty_duration"),
      // seconds
      metadata: jsonb("metadata"),
      // Request details, user agent, etc.
      resolved: boolean("resolved").default(false),
      resolvedAt: timestamp("resolved_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("idx_rate_violation_identifier").on(table.identifier),
      index("idx_rate_violation_ip").on(table.ipAddress),
      index("idx_rate_violation_user").on(table.userId),
      index("idx_rate_violation_created").on(table.createdAt)
    ]);
    userSessions = pgTable("user_sessions", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      token: varchar("token", { length: 255 }).notNull().unique(),
      ipAddress: varchar("ip_address", { length: 45 }).notNull(),
      userAgent: text("user_agent"),
      deviceId: varchar("device_id", { length: 255 }),
      location: jsonb("location").$type(),
      // Geo location data
      lastActivity: timestamp("last_activity").defaultNow().notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      uniqueIndex("idx_unique_session_token").on(table.token),
      index("idx_user_sessions_user").on(table.userId),
      index("idx_user_sessions_expires").on(table.expiresAt),
      index("idx_user_sessions_active").on(table.isActive)
    ]);
    deviceFingerprints = pgTable("device_fingerprints", {
      id: uuid("id").primaryKey().defaultRandom(),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      fingerprint: varchar("fingerprint", { length: 255 }).notNull(),
      deviceName: varchar("device_name", { length: 255 }),
      deviceType: varchar("device_type", { length: 50 }),
      // desktop, mobile, tablet
      os: varchar("os", { length: 100 }),
      browser: varchar("browser", { length: 100 }),
      browserVersion: varchar("browser_version", { length: 50 }),
      screenResolution: varchar("screen_resolution", { length: 50 }),
      trusted: boolean("trusted").default(false),
      lastSeen: timestamp("last_seen").defaultNow().notNull(),
      ipAddress: varchar("ip_address", { length: 45 }),
      location: jsonb("location").$type(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      uniqueIndex("idx_unique_device_fingerprint").on(table.userId, table.fingerprint),
      index("idx_device_fingerprints_user").on(table.userId),
      index("idx_device_fingerprints_trusted").on(table.trusted)
    ]);
    sessionEvents = pgTable("session_events", {
      id: uuid("id").primaryKey().defaultRandom(),
      sessionId: uuid("session_id").notNull().references(() => userSessions.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      eventType: varchar("event_type", { length: 50 }).notNull(),
      // login, logout, activity, location_change, device_change, hijack_detected
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      location: jsonb("location").$type(),
      metadata: jsonb("metadata"),
      // Additional event data
      severity: varchar("severity", { length: 20 }).default("info"),
      // info, warning, critical
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("idx_session_events_session").on(table.sessionId),
      index("idx_session_events_user").on(table.userId),
      index("idx_session_events_type").on(table.eventType),
      index("idx_session_events_severity").on(table.severity),
      index("idx_session_events_created").on(table.createdAt)
    ]);
    socialMediaAccounts = pgTable("social_media_accounts", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Platform Details
      platform: varchar("platform", { length: 30 }).notNull(),
      // facebook, instagram, twitter, linkedin, tiktok, pinterest, youtube
      accountType: varchar("account_type", { length: 30 }).default("business"),
      // business, personal, page, channel
      accountId: varchar("account_id", { length: 255 }).notNull(),
      // Platform-specific ID
      accountName: varchar("account_name", { length: 255 }),
      accountHandle: varchar("account_handle", { length: 255 }),
      profileUrl: varchar("profile_url"),
      profileImageUrl: varchar("profile_image_url"),
      // OAuth & Authentication
      accessToken: text("access_token"),
      refreshToken: text("refresh_token"),
      tokenExpiry: timestamp("token_expiry"),
      tokenScopes: jsonb("token_scopes"),
      // Array of granted permissions
      // Account Status
      isActive: boolean("is_active").default(true),
      isVerified: boolean("is_verified").default(false),
      lastSyncAt: timestamp("last_sync_at"),
      lastErrorAt: timestamp("last_error_at"),
      lastError: text("last_error"),
      // Platform-specific metadata
      platformMetadata: jsonb("platform_metadata"),
      // Store platform-specific data
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_social_accounts_business").on(table.businessId),
      uniqueIndex("idx_unique_social_account").on(table.businessId, table.platform, table.accountId)
    ]);
    socialMediaPosts = pgTable("social_media_posts", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      authorId: varchar("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Content Details
      content: text("content").notNull(),
      contentType: varchar("content_type", { length: 30 }).default("text"),
      // text, image, video, carousel, story, reel
      mediaUrls: jsonb("media_urls"),
      // Array of media URLs
      thumbnailUrl: varchar("thumbnail_url"),
      hashtags: jsonb("hashtags"),
      // Array of hashtags
      mentions: jsonb("mentions"),
      // Array of @mentions
      links: jsonb("links"),
      // Array of links in the post
      // Publishing Details
      status: varchar("status", { length: 30 }).notNull().default("draft"),
      // draft, scheduled, published, failed, archived
      scheduledAt: timestamp("scheduled_at"),
      publishedAt: timestamp("published_at"),
      // Platform Distribution
      platforms: jsonb("platforms").notNull(),
      // Array of platforms to publish to
      platformPosts: jsonb("platform_posts"),
      // Platform-specific post IDs and statuses
      // Campaign & Organization  
      campaignId: uuid("campaign_id"),
      categoryId: uuid("category_id"),
      isPromoted: boolean("is_promoted").default(false),
      promotionBudget: decimal("promotion_budget", { precision: 10, scale: 2 }),
      // Team Collaboration
      needsApproval: boolean("needs_approval").default(false),
      approvedBy: varchar("approved_by").references(() => users.id),
      approvedAt: timestamp("approved_at"),
      approvalNotes: text("approval_notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_social_posts_business").on(table.businessId),
      index("idx_social_posts_scheduled").on(table.scheduledAt),
      index("idx_social_posts_status").on(table.status)
    ]);
    socialMediaCampaigns = pgTable("social_media_campaigns", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      objectives: jsonb("objectives"),
      // Array of campaign objectives
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date"),
      budget: decimal("budget", { precision: 10, scale: 2 }),
      spentBudget: decimal("spent_budget", { precision: 10, scale: 2 }).default("0"),
      targetAudience: jsonb("target_audience"),
      // Demographics and interests
      targetPlatforms: jsonb("target_platforms"),
      // Array of platforms
      status: varchar("status", { length: 30 }).default("draft"),
      // draft, active, paused, completed
      // Performance Tracking
      postCount: integer("post_count").default(0),
      totalImpressions: integer("total_impressions").default(0),
      totalEngagements: integer("total_engagements").default(0),
      totalConversions: integer("total_conversions").default(0),
      totalRevenue: decimal("total_revenue", { precision: 10, scale: 2 }).default("0"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_social_campaigns_business").on(table.businessId),
      index("idx_social_campaigns_status").on(table.status)
    ]);
    socialContentCategories = pgTable("social_content_categories", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      color: varchar("color", { length: 7 }),
      // Hex color for calendar display
      icon: varchar("icon", { length: 50 }),
      description: text("description"),
      postCount: integer("post_count").default(0),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_content_categories_business").on(table.businessId)
    ]);
    socialMediaAnalytics = pgTable("social_media_analytics", {
      id: uuid("id").primaryKey().defaultRandom(),
      postId: uuid("post_id").references(() => socialMediaPosts.id, { onDelete: "cascade" }),
      accountId: uuid("account_id").references(() => socialMediaAccounts.id, { onDelete: "cascade" }),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      // Platform & Period
      platform: varchar("platform", { length: 30 }).notNull(),
      metricDate: date("metric_date").notNull(),
      metricType: varchar("metric_type", { length: 30 }).default("post"),
      // post, account, campaign, story
      // Engagement Metrics
      impressions: integer("impressions").default(0),
      reach: integer("reach").default(0),
      engagements: integer("engagements").default(0),
      likes: integer("likes").default(0),
      comments: integer("comments").default(0),
      shares: integer("shares").default(0),
      saves: integer("saves").default(0),
      clicks: integer("clicks").default(0),
      videoViews: integer("video_views").default(0),
      videoCompletions: integer("video_completions").default(0),
      // Audience Metrics
      followerCount: integer("follower_count"),
      followerGrowth: integer("follower_growth"),
      audienceDemographics: jsonb("audience_demographics"),
      // Performance Metrics
      engagementRate: decimal("engagement_rate", { precision: 5, scale: 2 }),
      clickThroughRate: decimal("click_through_rate", { precision: 5, scale: 2 }),
      conversionRate: decimal("conversion_rate", { precision: 5, scale: 2 }),
      costPerEngagement: decimal("cost_per_engagement", { precision: 10, scale: 2 }),
      // Revenue Attribution
      conversions: integer("conversions").default(0),
      revenue: decimal("revenue", { precision: 10, scale: 2 }),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_social_analytics_business").on(table.businessId),
      index("idx_social_analytics_date").on(table.metricDate),
      index("idx_social_analytics_platform").on(table.platform)
    ]);
    socialMediaMessages = pgTable("social_media_messages", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      accountId: uuid("account_id").notNull().references(() => socialMediaAccounts.id, { onDelete: "cascade" }),
      // Message Details
      platform: varchar("platform", { length: 30 }).notNull(),
      platformMessageId: varchar("platform_message_id", { length: 255 }),
      messageType: varchar("message_type", { length: 30 }).default("direct"),
      // direct, comment, mention, review
      // Sender/Recipient
      senderName: varchar("sender_name", { length: 255 }),
      senderId: varchar("sender_id", { length: 255 }),
      senderProfileUrl: varchar("sender_profile_url"),
      isFromBusiness: boolean("is_from_business").default(false),
      // Content
      content: text("content"),
      mediaUrls: jsonb("media_urls"),
      parentMessageId: uuid("parent_message_id"),
      // Self-reference - references parent message in thread
      threadId: varchar("thread_id", { length: 255 }),
      // Status & Management
      status: varchar("status", { length: 30 }).default("unread"),
      // unread, read, replied, archived, flagged
      priority: varchar("priority", { length: 20 }).default("normal"),
      // low, normal, high, urgent
      sentiment: varchar("sentiment", { length: 20 }),
      // positive, neutral, negative, critical
      // Assignment & Response
      assignedTo: varchar("assigned_to").references(() => users.id),
      repliedAt: timestamp("replied_at"),
      responseTime: integer("response_time"),
      // in seconds
      // Automation
      autoResponseSent: boolean("auto_response_sent").default(false),
      autoResponseTemplate: uuid("auto_response_template"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_social_messages_business").on(table.businessId),
      index("idx_social_messages_status").on(table.status),
      index("idx_social_messages_platform").on(table.platform)
    ]);
    socialResponseTemplates = pgTable("social_response_templates", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      category: varchar("category", { length: 100 }),
      // greeting, faq, complaint, thank_you
      content: text("content").notNull(),
      platforms: jsonb("platforms"),
      // Array of applicable platforms
      triggers: jsonb("triggers"),
      // Keywords or conditions that trigger this template
      useCount: integer("use_count").default(0),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_response_templates_business").on(table.businessId)
    ]);
    socialMediaListeners = pgTable("social_media_listeners", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      type: varchar("type", { length: 30 }).notNull(),
      // keyword, hashtag, mention, competitor
      // Monitoring Configuration
      keywords: jsonb("keywords"),
      // Array of keywords to track
      hashtags: jsonb("hashtags"),
      // Array of hashtags to monitor
      accounts: jsonb("accounts"),
      // Array of accounts to track (competitors, influencers)
      platforms: jsonb("platforms"),
      // Array of platforms to monitor
      // Alert Configuration
      alertEnabled: boolean("alert_enabled").default(false),
      alertThreshold: integer("alert_threshold"),
      // Number of mentions to trigger alert
      alertEmails: jsonb("alert_emails"),
      // Array of emails to notify
      isActive: boolean("is_active").default(true),
      lastCheckedAt: timestamp("last_checked_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_social_listeners_business").on(table.businessId)
    ]);
    socialMediaMentions = pgTable("social_media_mentions", {
      id: uuid("id").primaryKey().defaultRandom(),
      listenerId: uuid("listener_id").references(() => socialMediaListeners.id, { onDelete: "cascade" }),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      platform: varchar("platform", { length: 30 }).notNull(),
      platformPostId: varchar("platform_post_id", { length: 255 }),
      authorName: varchar("author_name", { length: 255 }),
      authorHandle: varchar("author_handle", { length: 255 }),
      authorProfileUrl: varchar("author_profile_url"),
      content: text("content"),
      postUrl: varchar("post_url"),
      sentiment: varchar("sentiment", { length: 20 }),
      // positive, neutral, negative
      reach: integer("reach"),
      engagement: integer("engagement"),
      isInfluencer: boolean("is_influencer").default(false),
      influencerScore: integer("influencer_score"),
      responded: boolean("responded").default(false),
      respondedAt: timestamp("responded_at"),
      mentionedAt: timestamp("mentioned_at").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("idx_social_mentions_business").on(table.businessId),
      index("idx_social_mentions_mentioned_at").on(table.mentionedAt)
    ]);
    socialMediaAutomation = pgTable("social_media_automation", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      type: varchar("type", { length: 50 }).notNull(),
      // rss_feed, product_sync, review_share, welcome_message, anniversary
      // Trigger Configuration
      triggerType: varchar("trigger_type", { length: 50 }),
      // time, event, condition
      triggerConfig: jsonb("trigger_config"),
      // Specific configuration for the trigger
      // Action Configuration
      actionType: varchar("action_type", { length: 50 }),
      // post, message, email
      actionConfig: jsonb("action_config"),
      // Specific configuration for the action
      platforms: jsonb("platforms"),
      // Target platforms
      isActive: boolean("is_active").default(true),
      lastTriggeredAt: timestamp("last_triggered_at"),
      triggerCount: integer("trigger_count").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_social_automation_business").on(table.businessId)
    ]);
    socialMediaTeam = pgTable("social_media_team", {
      id: uuid("id").primaryKey().defaultRandom(),
      businessId: uuid("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      role: varchar("role", { length: 50 }).notNull(),
      // admin, editor, moderator, viewer
      permissions: jsonb("permissions"),
      // Granular permissions
      // Access Control
      canPublish: boolean("can_publish").default(false),
      canSchedule: boolean("can_schedule").default(true),
      canRespond: boolean("can_respond").default(true),
      canViewAnalytics: boolean("can_view_analytics").default(true),
      canManageTeam: boolean("can_manage_team").default(false),
      assignedPlatforms: jsonb("assigned_platforms"),
      // Platforms this member can manage
      isActive: boolean("is_active").default(true),
      invitedBy: varchar("invited_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("idx_social_team_business").on(table.businessId),
      uniqueIndex("idx_unique_social_team_member").on(table.businessId, table.userId)
    ]);
    insertSocialMediaAccountSchema = createInsertSchema(socialMediaAccounts);
    insertSocialMediaPostSchema = createInsertSchema(socialMediaPosts);
    insertSocialMediaCampaignSchema = createInsertSchema(socialMediaCampaigns);
    insertSocialContentCategorySchema = createInsertSchema(socialContentCategories);
    insertSocialMediaAnalyticsSchema = createInsertSchema(socialMediaAnalytics);
    insertSocialMediaMessageSchema = createInsertSchema(socialMediaMessages);
    insertSocialResponseTemplateSchema = createInsertSchema(socialResponseTemplates);
    insertSocialMediaListenerSchema = createInsertSchema(socialMediaListeners);
    insertSocialMediaMentionSchema = createInsertSchema(socialMediaMentions);
    insertSocialMediaAutomationSchema = createInsertSchema(socialMediaAutomation);
    insertSocialMediaTeamSchema = createInsertSchema(socialMediaTeam);
    insertAdminRoleSchema = createInsertSchema(adminRoles);
    insertUserRoleSchema = createInsertSchema(userRoles);
    insertAdminAuditLogSchema = createInsertSchema(adminAuditLogs);
    insertErrorLogSchema = createInsertSchema(errorLogs);
    insertPremiumAdSlotSchema = createInsertSchema(premiumAdSlots);
    insertRateLimitViolationSchema = createInsertSchema(rateLimitViolations);
    insertUserSessionSchema = createInsertSchema(userSessions);
    insertDeviceFingerprintSchema = createInsertSchema(deviceFingerprints);
    insertSessionEventSchema = createInsertSchema(sessionEvents);
    insertChatConversationSchema = createInsertSchema(chatConversations);
    insertChatMessageSchema = createInsertSchema(chatMessages);
    insertChatKnowledgeBaseSchema = createInsertSchema(chatKnowledgeBase);
    insertChatSessionSchema = createInsertSchema(chatSessions);
    insertChatAnalyticsSchema = createInsertSchema(chatAnalytics);
    insertChatQuickActionSchema = createInsertSchema(chatQuickActions);
    insertChatProactiveTriggerSchema = createInsertSchema(chatProactiveTriggers);
    insertAIGeneratedContentSchema = createInsertSchema(aiGeneratedContent);
    insertAIContentTemplateSchema = createInsertSchema(aiContentTemplates);
    insertAIGeneratedImageSchema = createInsertSchema(aiGeneratedImages);
    insertAIUsageTrackingSchema = createInsertSchema(aiUsageTracking);
    insertAIContentTestSchema = createInsertSchema(aiContentTests);
    insertAIModerationLogSchema = createInsertSchema(aiModerationLog);
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  closeDatabaseConnection: () => closeDatabaseConnection,
  connectDatabaseWithRetry: () => connectDatabaseWithRetry,
  db: () => db,
  getDatabase: () => getDatabase,
  getDatabaseStatus: () => getDatabaseStatus,
  getPool: () => getPool,
  initializeDatabasePool: () => initializeDatabasePool,
  testDatabaseConnection: () => testDatabaseConnection
});
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
function getPool() {
  return pool;
}
async function initializeDatabasePool(databaseUrl) {
  if (pool) {
    logger.info("\u{1F4E6} Database pool already initialized");
    return pool;
  }
  logger.info("\u{1F527} Initializing database pool...");
  logger.info(`   - Connection string: ${databaseUrl.substring(0, 20)}...`);
  pool = new Pool({
    connectionString: databaseUrl,
    max: 20,
    idleTimeoutMillis: 3e4,
    connectionTimeoutMillis: 1e4,
    maxUses: 7500,
    allowExitOnIdle: true,
    statement_timeout: 3e4,
    query_timeout: 3e4,
    idle_in_transaction_session_timeout: 6e4
  });
  pool.on("error", (err) => {
    logger.error("\u274C Database pool error:", { message: err.message, stack: err.stack });
    dbConnectionState.isConnected = false;
    dbConnectionState.lastError = err;
    dbConnectionState.lastErrorTime = /* @__PURE__ */ new Date();
  });
  logger.info("\u2705 Database pool created");
  return pool;
}
async function connectDatabaseWithRetry(databaseUrl, maxAttempts = 3) {
  logger.info(`\u{1F50C} Connecting to database (max attempts: ${maxAttempts})...`);
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      logger.info(`   - Attempt ${attempt}/${maxAttempts}...`);
      if (!pool) {
        await initializeDatabasePool(databaseUrl);
      }
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Database connection timeout (10s)")), 1e4);
      });
      const connectionPromise = async () => {
        const client2 = await pool.connect();
        await client2.query("SELECT 1 as health_check");
        client2.release();
        logger.info("   - Connection test successful");
      };
      await Promise.race([connectionPromise(), timeoutPromise]);
      dbConnectionState.isConnected = true;
      dbConnectionState.lastError = null;
      dbConnectionState.reconnectAttempts = 0;
      logger.info(`\u2705 Database connected successfully on attempt ${attempt}`);
      return;
    } catch (error) {
      const err = error;
      dbConnectionState.lastError = err;
      dbConnectionState.lastErrorTime = /* @__PURE__ */ new Date();
      dbConnectionState.reconnectAttempts = attempt;
      logger.error(`\u274C Database connection attempt ${attempt} failed:`, {
        message: err.message,
        attempt,
        maxAttempts
      });
      if (attempt < maxAttempts) {
        const delay = Math.pow(2, attempt - 1) * 1e3;
        logger.info(`   - Retrying in ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      } else {
        logger.error("\u274C All database connection attempts failed");
        throw new Error(`Failed to connect to database after ${maxAttempts} attempts: ${err.message}`);
      }
    }
  }
}
async function testDatabaseConnection() {
  if (!pool) {
    logger.warn("\u26A0\uFE0F  Database pool not initialized");
    return false;
  }
  try {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error("Health check timeout")), 5e3);
    });
    const checkPromise = async () => {
      const client2 = await pool.connect();
      await client2.query("SELECT 1 as health_check");
      client2.release();
    };
    await Promise.race([checkPromise(), timeoutPromise]);
    if (!dbConnectionState.isConnected) {
      logger.info("\u2705 Database connection restored");
      dbConnectionState.isConnected = true;
      dbConnectionState.lastError = null;
      dbConnectionState.reconnectAttempts = 0;
    }
    return true;
  } catch (error) {
    const err = error;
    logger.error("\u274C Database health check failed:", { message: err.message });
    dbConnectionState.isConnected = false;
    dbConnectionState.lastError = err;
    dbConnectionState.lastErrorTime = /* @__PURE__ */ new Date();
    return false;
  }
}
function getDatabaseStatus() {
  return {
    isConnected: dbConnectionState.isConnected,
    lastError: dbConnectionState.lastError?.message || null,
    lastErrorTime: dbConnectionState.lastErrorTime,
    reconnectAttempts: dbConnectionState.reconnectAttempts,
    poolIdleCount: pool?.idleCount || 0,
    poolTotalCount: pool?.totalCount || 0,
    poolWaitingCount: pool?.waitingCount || 0
  };
}
function getDatabase() {
  if (!dbInstance && pool) {
    logger.info("\u{1F527} Creating Drizzle database instance...");
    dbInstance = drizzle({ client: pool, schema: schema_exports });
    logger.info("\u2705 Drizzle database instance created");
  }
  if (!dbInstance) {
    throw new Error("Database not initialized. Call initializeDatabasePool first.");
  }
  return dbInstance;
}
async function closeDatabaseConnection() {
  try {
    if (pool) {
      logger.info("\u{1F50C} Closing database pool...");
      await pool.end();
      pool = null;
      dbInstance = null;
      logger.info("\u2705 Database pool closed successfully");
    }
  } catch (error) {
    logger.error("\u274C Error closing database pool:", error);
  }
}
var dbConnectionState, pool, dbInstance, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    init_monitoring();
    neonConfig.webSocketConstructor = ws;
    neonConfig.fetchConnectionCache = true;
    neonConfig.pipelineTLS = false;
    neonConfig.pipelineConnect = false;
    dbConnectionState = {
      isConnected: false,
      lastError: null,
      lastErrorTime: null,
      reconnectAttempts: 0,
      maxReconnectAttempts: 3,
      reconnectDelay: 1e3
    };
    pool = null;
    dbInstance = null;
    db = new Proxy({}, {
      get(target, prop) {
        const database = getDatabase();
        return database[prop];
      }
    });
  }
});

// server/redis.ts
var redis_exports = {};
__export(redis_exports, {
  analyticsQueue: () => analyticsQueue,
  cache: () => cache,
  checkRedisConnection: () => checkRedisConnection,
  closeRedisConnections: () => closeRedisConnections,
  createRedisStore: () => createRedisStore,
  emailQueue: () => emailQueue,
  emailQueueEvents: () => emailQueueEvents,
  getQueues: () => getQueues,
  imageQueue: () => imageQueue,
  imageQueueEvents: () => imageQueueEvents,
  isRedisAvailable: () => isRedisAvailable,
  notificationQueue: () => notificationQueue,
  queueConnection: () => queueConnection,
  redis: () => redis,
  redisSubscriber: () => redisSubscriber,
  syncQueue: () => syncQueue
});
import Redis from "ioredis";
import { Queue, QueueEvents } from "bullmq";
import memorystore from "memorystore";
function logRedisError(error, context) {
  const now = Date.now();
  if (now - lastErrorLogged > ERROR_LOG_INTERVAL) {
    console.error(`\u274C Redis ${context} error:`, error.message);
    lastErrorLogged = now;
  }
}
function getQueues() {
  if (!emailQueue) {
    try {
      emailQueue = new Queue("email", { connection: queueConnection });
      imageQueue = new Queue("image-processing", { connection: queueConnection });
      syncQueue = new Queue("data-sync", { connection: queueConnection });
      analyticsQueue = new Queue("analytics", { connection: queueConnection });
      notificationQueue = new Queue("notifications", { connection: queueConnection });
      emailQueueEvents = new QueueEvents("email", { connection: queueConnection });
      imageQueueEvents = new QueueEvents("image-processing", { connection: queueConnection });
    } catch (error) {
      logRedisError(error, "queue initialization");
    }
  }
  return {
    emailQueue,
    imageQueue,
    syncQueue,
    analyticsQueue,
    notificationQueue,
    emailQueueEvents,
    imageQueueEvents
  };
}
async function checkRedisConnection() {
  try {
    const pong = await redis.ping();
    const isConnected = pong === "PONG";
    if (isConnected && !redisConnected) {
      redisConnected = true;
      console.log("\u2705 Redis reconnected");
    }
    return isConnected;
  } catch (error) {
    if (redisConnected) {
      logRedisError(error, "health check");
      redisConnected = false;
    }
    return false;
  }
}
function isRedisAvailable() {
  return redisConnected;
}
async function createRedisStore(session2) {
  const MemoryStore2 = memorystore(session2);
  if (!redisConnected) {
    console.log("\u26A0\uFE0F  Using memory store for sessions (Redis unavailable)");
    return new MemoryStore2({
      checkPeriod: 864e5
      // 1 day
    });
  }
  try {
    const connectRedisModule = await import("connect-redis");
    let RedisStore2;
    if ("RedisStore" in connectRedisModule) {
      RedisStore2 = connectRedisModule.RedisStore;
    } else if (connectRedisModule.default) {
      RedisStore2 = connectRedisModule.default;
    } else if (typeof connectRedisModule === "function") {
      RedisStore2 = connectRedisModule;
    } else {
      RedisStore2 = connectRedisModule;
    }
    if (typeof RedisStore2 === "function") {
      const testInstance = RedisStore2.prototype;
      if (testInstance && testInstance.constructor) {
        return new RedisStore2({
          client: redis,
          prefix: "sess:",
          ttl: 86400
          // 1 day
        });
      } else {
        const Store = RedisStore2(session2);
        return new Store({
          client: redis,
          prefix: "sess:",
          ttl: 86400
          // 1 day
        });
      }
    }
    throw new Error("Could not determine connect-redis usage pattern");
  } catch (error) {
    console.warn("\u26A0\uFE0F  Could not initialize Redis store, using memory store instead:", error);
    return new MemoryStore2({
      checkPeriod: 864e5
      // 1 day
    });
  }
}
async function initializeRedis() {
  try {
    await redis.connect();
  } catch (error) {
    logRedisError(error, "initial connection");
  }
}
async function closeRedisConnections() {
  try {
    if (redisConnected) {
      await redis.quit();
      await redisSubscriber.quit();
      await queueConnection.quit();
      console.log("Redis connections closed");
    }
  } catch (error) {
    logRedisError(error, "shutdown");
  }
}
var redisConnected, lastErrorLogged, ERROR_LOG_INTERVAL, redisConfig, bullmqRedisConfig, redis, redisSubscriber, queueConnection, emailQueue, imageQueue, syncQueue, analyticsQueue, notificationQueue, emailQueueEvents, imageQueueEvents, cache;
var init_redis = __esm({
  "server/redis.ts"() {
    "use strict";
    redisConnected = false;
    lastErrorLogged = 0;
    ERROR_LOG_INTERVAL = 6e4;
    redisConfig = {
      host: process.env.REDIS_HOST || "localhost",
      port: parseInt(process.env.REDIS_PORT || "6379"),
      password: process.env.REDIS_PASSWORD,
      maxRetriesPerRequest: 3,
      lazyConnect: true,
      // Don't connect immediately
      retryStrategy: (times) => {
        if (times > 10) {
          return null;
        }
        const delay = Math.min(times * 200, 5e3);
        return delay;
      },
      reconnectOnError: (err) => {
        const targetError = err.message.includes("READONLY");
        return targetError;
      }
    };
    bullmqRedisConfig = {
      host: process.env.REDIS_HOST || "localhost",
      port: parseInt(process.env.REDIS_PORT || "6379"),
      password: process.env.REDIS_PASSWORD,
      maxRetriesPerRequest: null,
      lazyConnect: true,
      retryStrategy: (times) => {
        if (times > 10) {
          return null;
        }
        const delay = Math.min(times * 200, 5e3);
        return delay;
      },
      reconnectOnError: (err) => {
        const targetError = err.message.includes("READONLY");
        return targetError;
      }
    };
    redis = new Redis(redisConfig);
    redisSubscriber = new Redis(redisConfig);
    queueConnection = new Redis(bullmqRedisConfig);
    redis.on("error", (err) => {
      redisConnected = false;
      logRedisError(err, "main");
    });
    redisSubscriber.on("error", (err) => {
      logRedisError(err, "subscriber");
    });
    queueConnection.on("error", (err) => {
      logRedisError(err, "queue");
    });
    redis.on("connect", () => {
      redisConnected = true;
      console.log("\u2705 Redis connected");
    });
    redis.on("close", () => {
      redisConnected = false;
    });
    emailQueue = null;
    imageQueue = null;
    syncQueue = null;
    analyticsQueue = null;
    notificationQueue = null;
    emailQueueEvents = null;
    imageQueueEvents = null;
    cache = {
      async get(key) {
        if (!redisConnected) return null;
        try {
          const value = await redis.get(key);
          return value ? JSON.parse(value) : null;
        } catch (error) {
          logRedisError(error, `cache get [${key}]`);
          return null;
        }
      },
      async set(key, value, ttlSeconds) {
        if (!redisConnected) return;
        try {
          const serialized = JSON.stringify(value);
          if (ttlSeconds) {
            await redis.setex(key, ttlSeconds, serialized);
          } else {
            await redis.set(key, serialized);
          }
        } catch (error) {
          logRedisError(error, `cache set [${key}]`);
        }
      },
      async delete(key) {
        if (!redisConnected) return;
        try {
          await redis.del(key);
        } catch (error) {
          logRedisError(error, `cache delete [${key}]`);
        }
      },
      async invalidatePattern(pattern) {
        if (!redisConnected) return;
        try {
          const keys = await redis.keys(pattern);
          if (keys.length > 0) {
            await redis.del(...keys);
          }
        } catch (error) {
          logRedisError(error, `cache invalidate [${pattern}]`);
        }
      }
    };
    initializeRedis();
  }
});

// server/monitoring/authSentry.ts
import * as Sentry2 from "@sentry/node";
function captureAuthError(error, context) {
  logger.error(`\u274C Auth Error: ${context.operation}`, {
    error: error.message,
    ...context
  });
  if (process.env.SENTRY_DSN) {
    Sentry2.withScope((scope) => {
      scope.setContext("auth", {
        operation: context.operation,
        strategyName: context.strategyName,
        sessionId: context.sessionId ? `${context.sessionId.substring(0, 8)}...` : void 0,
        ...context.additionalData
      });
      if (context.userId) {
        scope.setUser({ id: context.userId });
      }
      scope.setTag("component", "authentication");
      scope.setTag("operation", context.operation);
      if (context.operation.includes("OIDC") || context.operation.includes("critical")) {
        scope.setLevel("error");
      } else {
        scope.setLevel("warning");
      }
      Sentry2.captureException(error);
    });
  }
}
function captureAuthWarning(message, context) {
  logger.warn(`\u26A0\uFE0F  Auth Warning: ${context.operation}`, {
    message,
    ...context
  });
  if (process.env.SENTRY_DSN) {
    Sentry2.withScope((scope) => {
      scope.setContext("auth", {
        operation: context.operation,
        sessionId: context.sessionId ? `${context.sessionId.substring(0, 8)}...` : void 0,
        ...context.additionalData
      });
      if (context.userId) {
        scope.setUser({ id: context.userId });
      }
      scope.setTag("component", "authentication");
      scope.setTag("operation", context.operation);
      scope.setLevel("warning");
      Sentry2.captureMessage(message, "warning");
    });
  }
}
function trackAuthSuccess(operation, userId, duration, additionalData) {
  logger.info(`\u2705 Auth Success: ${operation}`, {
    userId,
    duration: `${duration}ms`,
    ...additionalData
  });
  if (process.env.SENTRY_DSN) {
    Sentry2.addBreadcrumb({
      category: "auth",
      message: `${operation} successful`,
      level: "info",
      data: {
        userId,
        duration,
        ...additionalData
      }
    });
  }
}
function captureCircuitBreakerEvent(serviceName, oldState, newState, metrics) {
  const message = `Circuit Breaker: ${serviceName} transitioned from ${oldState} to ${newState}`;
  logger.warn(message, { serviceName, oldState, newState, metrics });
  if (process.env.SENTRY_DSN && newState === "OPEN") {
    Sentry2.withScope((scope) => {
      scope.setContext("circuitBreaker", {
        service: serviceName,
        oldState,
        newState,
        ...metrics
      });
      scope.setTag("component", "circuit-breaker");
      scope.setTag("service", serviceName);
      scope.setLevel("error");
      Sentry2.captureMessage(message, "error");
    });
  }
}
function captureSessionDegradation(fromStore, toStore, reason, errorCount) {
  const message = `Session store degraded from ${fromStore} to ${toStore}`;
  logger.error(message, { fromStore, toStore, reason, errorCount });
  if (process.env.SENTRY_DSN) {
    Sentry2.withScope((scope) => {
      scope.setContext("sessionStore", {
        from: fromStore,
        to: toStore,
        reason,
        errorCount
      });
      scope.setTag("component", "session-store");
      scope.setTag("degradation", "true");
      scope.setLevel("error");
      Sentry2.captureMessage(message, "error");
    });
  }
}
var init_authSentry = __esm({
  "server/monitoring/authSentry.ts"() {
    "use strict";
    init_monitoring();
  }
});

// server/session/index.ts
import session from "express-session";
import connectPg from "connect-pg-simple";
import memorystore2 from "memorystore";
import { randomBytes } from "crypto";
async function createSessionStore(config2) {
  logger.info("\u{1F510} Creating session store with fallback chain...");
  logger.info("   - Option 1: Redis (if configured)");
  logger.info("   - Option 2: PostgreSQL (if database available)");
  logger.info("   - Option 3: Memory (last resort)");
  const sessionTtl = 7 * 24 * 60 * 60;
  if (config2.redisHost) {
    logger.info("   - Checking Redis availability...");
    try {
      const redisAvailable = await Promise.race([
        checkRedisConnection(),
        new Promise(
          (_, reject) => setTimeout(() => reject(new Error("Redis check timeout")), 3e3)
        )
      ]);
      if (redisAvailable) {
        logger.info("   - Redis is available, creating Redis store...");
        const store2 = await createRedisStore(session);
        logger.info("\u2705 Using Redis for session storage");
        const result2 = { store: store2, type: "redis" };
        currentSessionStore = result2;
        return result2;
      }
    } catch (error) {
      logger.warn("\u26A0\uFE0F  Redis not available:", error.message);
    }
  }
  logger.info("   - Redis not available, trying PostgreSQL...");
  try {
    const dbAvailable = await Promise.race([
      testDatabaseConnection(),
      new Promise(
        (_, reject) => setTimeout(() => reject(new Error("Database check timeout")), 3e3)
      )
    ]);
    if (dbAvailable) {
      logger.info("   - PostgreSQL is available, creating PostgreSQL session store...");
      const PgStore = connectPg(session);
      const store2 = new PgStore({
        conString: config2.databaseUrl,
        createTableIfMissing: true,
        ttl: sessionTtl,
        tableName: "sessions",
        schemaName: "public",
        errorLog: (error) => {
          logger.error("\u274C PostgreSQL session store error:", { message: error.message });
          degradeToMemoryStoreIfNeeded();
        }
      });
      store2.on("error", (error) => {
        logger.error("\u274C Session store connection error:", { message: error.message });
        degradeToMemoryStoreIfNeeded();
      });
      logger.info("\u2705 Using PostgreSQL for session storage");
      const result2 = { store: store2, type: "postgresql" };
      currentSessionStore = result2;
      return result2;
    }
  } catch (error) {
    logger.warn("\u26A0\uFE0F  PostgreSQL not available:", error.message);
  }
  logger.warn("\u26A0\uFE0F  Falling back to in-memory session store (sessions will not persist across restarts)");
  const store = new MemoryStore({
    checkPeriod: 864e5
  });
  logger.info("\u2705 Using Memory for session storage");
  const result = { store, type: "memory" };
  currentSessionStore = result;
  return result;
}
function degradeToMemoryStoreIfNeeded() {
  const now = Date.now();
  if (now - lastErrorTime > ERROR_WINDOW_MS) {
    sessionStoreErrorCount = 0;
  }
  sessionStoreErrorCount++;
  lastErrorTime = now;
  if (sessionStoreErrorCount >= ERROR_THRESHOLD && currentSessionStore?.type !== "memory") {
    const fromStore = currentSessionStore?.type || "unknown";
    logger.error(`\u274C Session store degradation triggered! ${sessionStoreErrorCount} errors in ${ERROR_WINDOW_MS}ms`);
    logger.warn("\u26A0\uFE0F  Switching to in-memory session store for reliability");
    captureSessionDegradation(
      fromStore,
      "memory",
      `${sessionStoreErrorCount} errors in ${ERROR_WINDOW_MS}ms`,
      sessionStoreErrorCount
    );
    const memoryStore = new MemoryStore({
      checkPeriod: 864e5
    });
    currentSessionStore = { store: memoryStore, type: "memory" };
    logger.error("\u{1F6A8} ALERT: Session store degraded to memory - investigate database/redis issues!");
  }
}
function getCurrentSessionStore() {
  return currentSessionStore;
}
function createSessionMiddleware(store, config2) {
  const sessionTtlMs = 7 * 24 * 60 * 60 * 1e3;
  const cookieConfig = {
    httpOnly: true,
    secure: config2.isProduction,
    maxAge: sessionTtlMs,
    // CRITICAL: Use 'lax' for OAuth flows that return to same domain
    // 'lax' allows cookies on top-level navigation (OAuth redirects)
    // 'none' would be needed for cross-origin iframes, but not for OAuth
    sameSite: "lax"
  };
  logger.info(`\u{1F36A} Cookie domain: using default (current host only) for OAuth compatibility`);
  logger.info(`\u{1F510} Session configuration:`, {
    isProduction: config2.isProduction,
    secure: cookieConfig.secure,
    sameSite: cookieConfig.sameSite,
    domain: cookieConfig.domain || "default",
    store: store.constructor.name
  });
  return session({
    secret: config2.sessionSecret,
    store,
    resave: false,
    // CRITICAL: Must be TRUE for OAuth state persistence
    // OAuth libraries store state in session BEFORE redirecting to OAuth provider
    // With saveUninitialized: false, that session won't be saved and state verification fails
    saveUninitialized: true,
    rolling: true,
    cookie: cookieConfig,
    name: "florida.elite.sid",
    genid: () => {
      return randomBytes(32).toString("hex");
    }
  });
}
async function initializeSession(config2) {
  logger.info("\u{1F510} Initializing session management...");
  const { store, type } = await createSessionStore(config2);
  const middleware = createSessionMiddleware(store, config2);
  logger.info(`\u2705 Session initialized with ${type} store`);
  return {
    middleware,
    store,
    storeType: type
  };
}
var MemoryStore, currentSessionStore, sessionStoreErrorCount, lastErrorTime, ERROR_THRESHOLD, ERROR_WINDOW_MS;
var init_session = __esm({
  "server/session/index.ts"() {
    "use strict";
    init_redis();
    init_db();
    init_monitoring();
    init_authSentry();
    MemoryStore = memorystore2(session);
    currentSessionStore = null;
    sessionStoreErrorCount = 0;
    lastErrorTime = 0;
    ERROR_THRESHOLD = 5;
    ERROR_WINDOW_MS = 6e4;
  }
});

// server/storage.ts
import { eq, desc, sql as sql2, and, or, like, inArray } from "drizzle-orm";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    DatabaseStorage = class {
      constructor() {
        // SECURITY: Enhanced rotation management with guards and frequency controls
        this.rotationInProgress = /* @__PURE__ */ new Set();
        this.lastRotationTimes = /* @__PURE__ */ new Map();
      }
      async getUserById(userId) {
        return (await db.select().from(users).where(eq(users.id, userId)).limit(1))[0] || null;
      }
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(eq(users.email, email));
        return user;
      }
      async upsertUser(userData) {
        try {
          console.log("\u{1F50D} upsertUser called with:", JSON.stringify(userData));
          if (!userData.email || typeof userData.email !== "string") {
            const fallbackEmail = `user-${Math.random().toString(36).substr(2, 9)}@placeholder.local`;
            console.warn(`\u26A0\uFE0F  No email provided, using fallback: ${fallbackEmail}`);
            userData.email = fallbackEmail;
          }
          const userEmail = userData.email.trim().toLowerCase();
          const existingByEmail = await db.select().from(users).where(eq(users.email, userEmail)).limit(1);
          console.log(`\u{1F50D} Existing user check: ${existingByEmail[0] ? `FOUND (${existingByEmail[0].id})` : "NOT FOUND"}`);
          if (existingByEmail[0]) {
            console.log(`\u2705 Updating existing user ${existingByEmail[0].id}`);
            const [user2] = await db.update(users).set({
              firstName: userData.firstName || existingByEmail[0].firstName,
              lastName: userData.lastName || existingByEmail[0].lastName,
              profileImageUrl: userData.profileImageUrl || existingByEmail[0].profileImageUrl,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq(users.email, userEmail)).returning();
            console.log(`\u2705 User updated: ${user2.id} (${user2.email})`);
            return { user: user2, isNewUser: false };
          }
          console.log("\u{1F4DD} Creating NEW user...");
          const baseId = userEmail.split("@")[0].toLowerCase().replace(/[^a-z0-9]/g, "-");
          const uniqueId = `${baseId}-${Math.random().toString(36).substr(2, 6)}`;
          console.log(`\u{1F4DD} Generated ID: ${uniqueId}`);
          const [user] = await db.insert(users).values({
            id: uniqueId,
            email: userEmail,
            firstName: userData.firstName || "User",
            lastName: userData.lastName || "",
            profileImageUrl: userData.profileImageUrl
          }).returning();
          console.log(`\u2705 New user created: ${user.id} (${user.email})`);
          return { user, isNewUser: true };
        } catch (error) {
          console.error("\u274C FATAL ERROR in upsertUser:", error);
          console.error("userData was:", JSON.stringify(userData));
          throw error;
        }
      }
      async updateUserAdminStatus(id, isAdmin2) {
        await db.update(users).set({
          isAdmin: isAdmin2,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(users.id, id));
      }
      async updateUserOnlineStatus(userId, status) {
        await db.update(users).set({
          onlineStatus: status,
          lastSeenAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(users.id, userId));
      }
      async getUserConnections(userId) {
        const myBusinesses = await db.select({ id: businesses.id }).from(businesses).where(eq(businesses.ownerId, userId));
        if (myBusinesses.length === 0) {
          return [];
        }
        const businessIds = myBusinesses.map((b) => b.id);
        const followers = await db.select({ userId: businessFollowers.userId }).from(businessFollowers).where(inArray(businessFollowers.businessId, businessIds)).groupBy(businessFollowers.userId);
        const messageConnections = await db.select({ userId: messages.senderId }).from(messages).where(
          or(
            eq(messages.senderId, userId),
            eq(messages.receiverId, userId)
          )
        ).groupBy(messages.senderId).union(
          db.select({ userId: messages.receiverId }).from(messages).where(
            or(
              eq(messages.senderId, userId),
              eq(messages.receiverId, userId)
            )
          ).groupBy(messages.receiverId)
        );
        const connectionIds = /* @__PURE__ */ new Set([
          ...followers.map((f) => f.userId),
          ...messageConnections.map((m) => m.userId).filter((id) => id !== userId)
        ]);
        return Array.from(connectionIds);
      }
      async userHasAccessToConversation(userId, conversationId) {
        const message = await db.select().from(messages).where(
          and(
            eq(messages.id, conversationId),
            or(
              eq(messages.senderId, userId),
              eq(messages.receiverId, userId)
            )
          )
        ).limit(1);
        return message.length > 0;
      }
      async getUserFollowedBusinesses(userId) {
        const follows = await db.select({
          id: businesses.id,
          name: businesses.name,
          category: businesses.category,
          followedAt: businessFollowers.createdAt
        }).from(businessFollowers).innerJoin(businesses, eq(businesses.id, businessFollowers.businessId)).where(eq(businessFollowers.userId, userId)).orderBy(desc(businessFollowers.createdAt)).limit(50);
        return follows;
      }
      async getUserLikedPosts(userId) {
        const likes = await db.select({
          postId: postLikes.postId,
          businessId: posts.businessId,
          likedAt: postLikes.createdAt
        }).from(postLikes).innerJoin(posts, eq(posts.id, postLikes.postId)).where(eq(postLikes.userId, userId)).orderBy(desc(postLikes.createdAt)).limit(50);
        return likes;
      }
      async getUserPurchaseHistory(userId) {
        const purchases = await db.select({
          orderId: orders.id,
          productId: orderItems.productId,
          productName: orderItems.productName,
          quantity: orderItems.quantity,
          createdAt: orders.createdAt
        }).from(orders).innerJoin(orderItems, eq(orderItems.orderId, orders.id)).where(
          and(
            eq(orders.userId, userId),
            eq(orders.status, "completed")
          )
        ).orderBy(desc(orders.createdAt)).limit(50);
        return purchases;
      }
      async getBusinessMetrics(businessId) {
        const productStats = await db.select({
          avgRating: sql2`AVG(CAST(${products.rating} AS DECIMAL))`,
          productCount: sql2`COUNT(*)`
        }).from(products).where(eq(products.businessId, businessId));
        const postStats = await db.select({
          totalLikes: sql2`SUM(${posts.likeCount})`,
          totalComments: sql2`SUM(${posts.commentCount})`,
          totalShares: sql2`SUM(${posts.shareCount})`,
          postCount: sql2`COUNT(*)`
        }).from(posts).where(eq(posts.businessId, businessId));
        const business = await this.getBusinessById(businessId);
        return {
          avgProductRating: productStats[0]?.avgRating || 0,
          productCount: productStats[0]?.productCount || 0,
          totalEngagement: (postStats[0]?.totalLikes || 0) + (postStats[0]?.totalComments || 0) + (postStats[0]?.totalShares || 0),
          postCount: postStats[0]?.postCount || 0,
          followerCount: business?.followerCount || 0,
          rating: business?.rating || "0",
          reviewCount: business?.reviewCount || 0
        };
      }
      async getOrderItemsWithProducts(orderId) {
        return await db.select({
          id: orderItems.id,
          orderId: orderItems.orderId,
          productId: orderItems.productId,
          productName: orderItems.productName,
          productPrice: orderItems.productPrice,
          quantity: orderItems.quantity,
          totalPrice: orderItems.totalPrice,
          product: products
        }).from(orderItems).leftJoin(products, eq(products.id, orderItems.productId)).where(eq(orderItems.orderId, orderId));
      }
      async updateOrderInvoiceNumber(orderId, invoiceNumber) {
        await db.update(orders).set({
          invoiceNumber,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(orders.id, orderId));
      }
      async createBusiness(businessData) {
        const [business] = await db.insert(businesses).values(businessData).returning();
        return business;
      }
      async updateBusiness(id, businessData) {
        const [business] = await db.update(businesses).set({
          ...businessData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(businesses.id, id)).returning();
        return business;
      }
      async deleteBusiness(id) {
        await db.delete(businesses).where(eq(businesses.id, id));
      }
      async getBusinessById(id) {
        const [business] = await db.select().from(businesses).where(eq(businesses.id, id));
        return business;
      }
      async getBusinesses(page = 1, limit = 20, category) {
        const offset = (page - 1) * limit;
        const conditions = [];
        if (category) {
          conditions.push(eq(businesses.category, category));
        }
        return await db.select().from(businesses).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(businesses.createdAt)).limit(limit).offset(offset);
      }
      async getFeaturedBusinesses(limit = 12) {
        return await db.select().from(businesses).orderBy(desc(businesses.rating), desc(businesses.createdAt)).limit(limit);
      }
      async getBusinessesByOwner(ownerId) {
        return await db.select().from(businesses).where(eq(businesses.ownerId, ownerId));
      }
      async searchBusinesses(query, category) {
        const conditions = [
          or(
            like(businesses.name, `%${query}%`),
            like(businesses.description, `%${query}%`),
            like(businesses.location, `%${query}%`)
          )
        ];
        if (category) {
          conditions.push(eq(businesses.category, category));
        }
        return await db.select().from(businesses).where(and(...conditions)).orderBy(desc(businesses.rating));
      }
      async getSpotlightBusinesses(type) {
        const today = /* @__PURE__ */ new Date();
        return await db.select({
          id: businesses.id,
          ownerId: businesses.ownerId,
          name: businesses.name,
          tagline: businesses.tagline,
          description: businesses.description,
          category: businesses.category,
          location: businesses.location,
          address: businesses.address,
          phone: businesses.phone,
          website: businesses.website,
          logoUrl: businesses.logoUrl,
          coverImageUrl: businesses.coverImageUrl,
          operatingHours: businesses.operatingHours,
          socialLinks: businesses.socialLinks,
          googlePlaceId: businesses.googlePlaceId,
          isVerified: businesses.isVerified,
          isActive: businesses.isActive,
          gmbVerified: businesses.gmbVerified,
          gmbConnected: businesses.gmbConnected,
          gmbAccountId: businesses.gmbAccountId,
          gmbLocationId: businesses.gmbLocationId,
          gmbSyncStatus: businesses.gmbSyncStatus,
          gmbLastSyncAt: businesses.gmbLastSyncAt,
          gmbLastErrorAt: businesses.gmbLastErrorAt,
          gmbLastError: businesses.gmbLastError,
          gmbDataSources: businesses.gmbDataSources,
          stripeAccountId: businesses.stripeAccountId,
          stripeOnboardingStatus: businesses.stripeOnboardingStatus,
          stripeChargesEnabled: businesses.stripeChargesEnabled,
          stripePayoutsEnabled: businesses.stripePayoutsEnabled,
          rating: businesses.rating,
          reviewCount: businesses.reviewCount,
          followerCount: businesses.followerCount,
          postCount: businesses.postCount,
          createdAt: businesses.createdAt,
          updatedAt: businesses.updatedAt
        }).from(businesses).innerJoin(spotlights, eq(spotlights.businessId, businesses.id)).where(
          and(
            eq(spotlights.type, type),
            eq(spotlights.isActive, true),
            sql2`${spotlights.startDate} <= ${today}`,
            sql2`${spotlights.endDate} >= ${today}`
          )
        ).orderBy(spotlights.position);
      }
      async followBusiness(userId, businessId) {
        await db.insert(businessFollowers).values({
          userId,
          businessId
        }).onConflictDoNothing();
        await db.update(businesses).set({
          followerCount: sql2`${businesses.followerCount} + 1`
        }).where(eq(businesses.id, businessId));
      }
      async unfollowBusiness(userId, businessId) {
        await db.delete(businessFollowers).where(
          and(
            eq(businessFollowers.userId, userId),
            eq(businessFollowers.businessId, businessId)
          )
        );
        await db.update(businesses).set({
          followerCount: sql2`GREATEST(${businesses.followerCount} - 1, 0)`
        }).where(eq(businesses.id, businessId));
      }
      async isFollowingBusiness(userId, businessId) {
        const [follow] = await db.select().from(businessFollowers).where(
          and(
            eq(businessFollowers.userId, userId),
            eq(businessFollowers.businessId, businessId)
          )
        );
        return !!follow;
      }
      async createProduct(productData) {
        const [product] = await db.insert(products).values(productData).returning();
        return product;
      }
      async updateProduct(id, productData) {
        const [product] = await db.update(products).set({
          ...productData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(products.id, id)).returning();
        return product;
      }
      async updateProductImages(productId, images) {
        const [product] = await db.update(products).set({
          images,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(products.id, productId)).returning();
        return product;
      }
      async getProductById(id) {
        const [product] = await db.select().from(products).where(eq(products.id, id));
        return product;
      }
      async getProducts(page = 1, limit = 20, category) {
        const offset = (page - 1) * limit;
        const conditions = [eq(products.isActive, true)];
        if (category) {
          conditions.push(eq(products.category, category));
        }
        return await db.select().from(products).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(products.createdAt)).limit(limit).offset(offset);
      }
      async getProductsByBusiness(businessId) {
        return await db.select().from(products).where(eq(products.businessId, businessId)).orderBy(desc(products.createdAt));
      }
      async searchProducts(query, options) {
        const {
          categories,
          minPrice,
          maxPrice,
          inStock,
          isDigital,
          minRating,
          tags,
          sort = "rating_desc",
          page = 1,
          pageSize = 24,
          includeTotal = false
        } = options || {};
        const conditions = [
          eq(products.isActive, true)
        ];
        const q = (query || "").trim();
        if (q) {
          const searchCondition = or(
            like(products.name, `%${q}%`),
            like(products.description, `%${q}%`)
          );
          if (searchCondition) {
            conditions.push(searchCondition);
          }
        }
        if (categories && categories.length > 0) {
          conditions.push(inArray(products.category, categories));
        }
        if (typeof isDigital === "boolean") {
          conditions.push(eq(products.isDigital, isDigital));
        }
        if (inStock) {
          conditions.push(sql2`${products.inventory} > 0`);
        }
        if (typeof minPrice === "number") {
          conditions.push(sql2`CAST(${products.price} AS DECIMAL) >= ${minPrice}`);
        }
        if (typeof maxPrice === "number") {
          conditions.push(sql2`CAST(${products.price} AS DECIMAL) <= ${maxPrice}`);
        }
        if (typeof minRating === "number") {
          conditions.push(sql2`CAST(${products.rating} AS DECIMAL) >= ${minRating}`);
        }
        if (tags && tags.length > 0) {
          const tagConds = tags.map((t) => sql2`${products.tags}::text ILIKE ${`%"${t}"%`}`);
          const tagCondition = or(...tagConds);
          if (tagCondition) {
            conditions.push(tagCondition);
          }
        }
        let orderByExpr = desc(products.rating);
        if (sort === "price_asc") orderByExpr = sql2`CAST(${products.price} AS DECIMAL) ASC`;
        if (sort === "price_desc") orderByExpr = sql2`CAST(${products.price} AS DECIMAL) DESC`;
        if (sort === "newest") orderByExpr = desc(products.createdAt);
        if (sort === "popular") orderByExpr = desc(products.reviewCount);
        const offset = Math.max(0, (page - 1) * pageSize);
        const queryBase = db.select().from(products).where(and(...conditions));
        const items = await queryBase.orderBy(orderByExpr).limit(pageSize).offset(offset);
        let total = 0;
        if (includeTotal) {
          const [row] = await db.select({ count: sql2`count(*)` }).from(products).where(and(...conditions));
          total = row?.count || 0;
        }
        return { items, total };
      }
      async getFeaturedProducts(limit = 8) {
        return await db.select().from(products).where(eq(products.isActive, true)).orderBy(desc(products.rating)).limit(limit);
      }
      async createPost(postData) {
        const [post] = await db.insert(posts).values(postData).returning();
        await db.update(businesses).set({
          postCount: sql2`${businesses.postCount} + 1`
        }).where(eq(businesses.id, postData.businessId));
        return post;
      }
      async getPostById(id) {
        const [post] = await db.select().from(posts).where(eq(posts.id, id));
        return post;
      }
      async getRecentPosts(limit = 20) {
        return await db.select().from(posts).where(eq(posts.isVisible, true)).orderBy(desc(posts.createdAt)).limit(limit);
      }
      async getPostsByBusiness(businessId) {
        return await db.select().from(posts).where(
          and(
            eq(posts.businessId, businessId),
            eq(posts.isVisible, true)
          )
        ).orderBy(desc(posts.createdAt));
      }
      async likePost(userId, postId) {
        await db.insert(postLikes).values({
          userId,
          postId
        }).onConflictDoNothing();
        await db.update(posts).set({
          likeCount: sql2`${posts.likeCount} + 1`
        }).where(eq(posts.id, postId));
      }
      async unlikePost(userId, postId) {
        await db.delete(postLikes).where(
          and(
            eq(postLikes.userId, userId),
            eq(postLikes.postId, postId)
          )
        );
        await db.update(posts).set({
          likeCount: sql2`GREATEST(${posts.likeCount} - 1, 0)`
        }).where(eq(posts.id, postId));
      }
      async isPostLiked(userId, postId) {
        const [like4] = await db.select().from(postLikes).where(
          and(
            eq(postLikes.userId, userId),
            eq(postLikes.postId, postId)
          )
        );
        return !!like4;
      }
      async createMessage(messageData) {
        const [message] = await db.insert(messages).values(messageData).returning();
        return message;
      }
      async getMessagesBetweenUsers(user1Id, user2Id) {
        return await db.select().from(messages).where(
          or(
            and(
              eq(messages.senderId, user1Id),
              eq(messages.receiverId, user2Id)
            ),
            and(
              eq(messages.senderId, user2Id),
              eq(messages.receiverId, user1Id)
            )
          )
        ).orderBy(desc(messages.createdAt));
      }
      async getConversations(userId) {
        const conversations = await db.selectDistinctOn([messages.senderId, messages.receiverId], {
          senderId: messages.senderId,
          receiverId: messages.receiverId,
          content: messages.content,
          createdAt: messages.createdAt,
          isRead: messages.isRead
        }).from(messages).where(
          or(
            eq(messages.senderId, userId),
            eq(messages.receiverId, userId)
          )
        ).orderBy(messages.senderId, messages.receiverId, desc(messages.createdAt));
        return conversations;
      }
      async markMessageAsRead(messageId, readAt) {
        await db.update(messages).set({
          isRead: true,
          readAt: readAt || /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(messages.id, messageId));
      }
      async getConversationMessages(conversationId, offset, limit) {
        const query = db.select().from(messages).where(eq(messages.conversationId, conversationId)).orderBy(desc(messages.createdAt));
        if (limit !== void 0) {
          query.limit(limit);
        }
        if (offset !== void 0) {
          query.offset(offset);
        }
        return await query;
      }
      async markMessagesAsDelivered(messageIds, deliveredAt) {
        if (messageIds.length === 0) return;
        await db.update(messages).set({
          isDelivered: true,
          deliveredAt: deliveredAt || /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(inArray(messages.id, messageIds));
      }
      async getUnreadMessageCount(userId) {
        const [result] = await db.select({ count: sql2`count(*)` }).from(messages).where(
          and(
            eq(messages.receiverId, userId),
            eq(messages.isRead, false)
          )
        );
        return result?.count || 0;
      }
      async getLatestMessageInConversation(conversationId) {
        const [message] = await db.select().from(messages).where(eq(messages.conversationId, conversationId)).orderBy(desc(messages.createdAt)).limit(1);
        return message;
      }
      async searchMessages(userId, query) {
        return await db.select().from(messages).where(
          and(
            or(
              eq(messages.senderId, userId),
              eq(messages.receiverId, userId)
            ),
            like(messages.content, `%${query}%`)
          )
        ).orderBy(desc(messages.createdAt)).limit(50);
      }
      async deleteMessage(messageId, userId) {
        await db.delete(messages).where(
          and(
            eq(messages.id, messageId),
            eq(messages.senderId, userId)
          )
        );
      }
      async getMessageById(messageId) {
        const [message] = await db.select().from(messages).where(eq(messages.id, messageId));
        return message;
      }
      async getCurrentSpotlights() {
        const [daily, weekly, monthly] = await Promise.all([
          this.getSpotlightBusinesses("daily"),
          this.getSpotlightBusinesses("weekly"),
          this.getSpotlightBusinesses("monthly")
        ]);
        return { daily, weekly, monthly };
      }
      // Cart operations
      async addToCart(userId, productId, quantity) {
        const [existingItem] = await db.select().from(cartItems).where(
          and(
            eq(cartItems.userId, userId),
            eq(cartItems.productId, productId)
          )
        );
        if (existingItem) {
          const [updatedItem] = await db.update(cartItems).set({ quantity: existingItem.quantity + quantity }).where(eq(cartItems.id, existingItem.id)).returning();
          return updatedItem;
        } else {
          const [cartItem] = await db.insert(cartItems).values({ userId, productId, quantity }).returning();
          return cartItem;
        }
      }
      async getCartItems(userId) {
        return await db.select({
          id: cartItems.id,
          userId: cartItems.userId,
          productId: cartItems.productId,
          quantity: cartItems.quantity,
          addedAt: cartItems.addedAt,
          product: {
            id: products.id,
            businessId: products.businessId,
            name: products.name,
            description: products.description,
            price: products.price,
            originalPrice: products.originalPrice,
            category: products.category,
            images: products.images,
            inventory: products.inventory,
            isActive: products.isActive,
            isDigital: products.isDigital,
            tags: products.tags,
            rating: products.rating,
            reviewCount: products.reviewCount,
            createdAt: products.createdAt,
            updatedAt: products.updatedAt
          }
        }).from(cartItems).innerJoin(products, eq(cartItems.productId, products.id)).where(eq(cartItems.userId, userId)).orderBy(desc(cartItems.addedAt));
      }
      async updateCartItemQuantity(userId, productId, quantity) {
        if (quantity <= 0) {
          await this.removeFromCart(userId, productId);
          return;
        }
        await db.update(cartItems).set({ quantity }).where(
          and(
            eq(cartItems.userId, userId),
            eq(cartItems.productId, productId)
          )
        );
      }
      async removeFromCart(userId, productId) {
        await db.delete(cartItems).where(
          and(
            eq(cartItems.userId, userId),
            eq(cartItems.productId, productId)
          )
        );
      }
      async clearCart(userId) {
        await db.delete(cartItems).where(eq(cartItems.userId, userId));
      }
      async getCartTotal(userId) {
        const cartItemsWithProducts = await this.getCartItems(userId);
        return cartItemsWithProducts.reduce(
          (total, item) => total + parseFloat(item.product.price) * item.quantity,
          0
        );
      }
      // Order operations
      async createOrder(orderData) {
        const [order] = await db.insert(orders).values(orderData).returning();
        return order;
      }
      async createOrderItems(orderItemsData) {
        return await db.insert(orderItems).values(orderItemsData).returning();
      }
      async getOrderById(orderId) {
        const [order] = await db.select().from(orders).where(eq(orders.id, orderId));
        if (!order) {
          return void 0;
        }
        const orderItemsWithProducts = await db.select({
          id: orderItems.id,
          orderId: orderItems.orderId,
          productId: orderItems.productId,
          productName: orderItems.productName,
          productPrice: orderItems.productPrice,
          quantity: orderItems.quantity,
          totalPrice: orderItems.totalPrice,
          createdAt: orderItems.createdAt,
          product: {
            id: products.id,
            businessId: products.businessId,
            name: products.name,
            description: products.description,
            price: products.price,
            originalPrice: products.originalPrice,
            category: products.category,
            images: products.images,
            inventory: products.inventory,
            isActive: products.isActive,
            isDigital: products.isDigital,
            tags: products.tags,
            rating: products.rating,
            reviewCount: products.reviewCount,
            createdAt: products.createdAt,
            updatedAt: products.updatedAt
          }
        }).from(orderItems).innerJoin(products, eq(orderItems.productId, products.id)).where(eq(orderItems.orderId, orderId));
        return {
          ...order,
          orderItems: orderItemsWithProducts
        };
      }
      async getOrdersByUser(userId) {
        return await db.select().from(orders).where(eq(orders.userId, userId)).orderBy(desc(orders.createdAt));
      }
      async updateOrderStatus(orderId, status) {
        await db.update(orders).set({
          status,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(orders.id, orderId));
        if (status === "processing") {
          await this.adjustInventoryForOrder(orderId);
        }
      }
      async adjustInventoryForOrder(orderId) {
        try {
          const orderItemsList = await db.select().from(orderItems).where(eq(orderItems.orderId, orderId));
          for (const item of orderItemsList) {
            await db.update(products).set({
              inventory: sql2`GREATEST(${products.inventory} - ${item.quantity}, 0)`,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq(products.id, item.productId));
          }
          console.log(`\u2705 Adjusted inventory for ${orderItemsList.length} products in order ${orderId}`);
        } catch (error) {
          console.error(`\u274C Failed to adjust inventory for order ${orderId}:`, error);
        }
      }
      // Payment operations
      async createPayment(paymentData) {
        const [payment] = await db.insert(payments).values(paymentData).returning();
        return payment;
      }
      async updatePaymentStatus(paymentId, status, paidAt, failureReason) {
        await db.update(payments).set({
          status,
          paidAt,
          failureReason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(payments.id, paymentId));
      }
      async getPaymentByStripeId(stripePaymentIntentId) {
        const [payment] = await db.select().from(payments).where(eq(payments.stripePaymentIntentId, stripePaymentIntentId));
        return payment;
      }
      // GMB Token operations
      async createGmbToken(tokenData) {
        const [token] = await db.insert(gmbTokens).values(tokenData).returning();
        return token;
      }
      async getGmbToken(businessId) {
        const [token] = await db.select().from(gmbTokens).where(and(
          eq(gmbTokens.businessId, businessId),
          eq(gmbTokens.isActive, true)
        ));
        return token;
      }
      async updateGmbToken(businessId, tokenData) {
        await db.update(gmbTokens).set({
          ...tokenData,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(gmbTokens.businessId, businessId));
      }
      async deactivateGmbToken(businessId) {
        await db.update(gmbTokens).set({
          isActive: false,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(gmbTokens.businessId, businessId));
      }
      // GMB Sync History operations
      async createGmbSyncHistory(syncData) {
        const [history] = await db.insert(gmbSyncHistory).values(syncData).returning();
        return history;
      }
      async getGmbSyncHistory(businessId) {
        return await db.select().from(gmbSyncHistory).where(eq(gmbSyncHistory.businessId, businessId)).orderBy(desc(gmbSyncHistory.createdAt));
      }
      async getRecentGmbSyncHistory(businessId, limit) {
        return await db.select().from(gmbSyncHistory).where(eq(gmbSyncHistory.businessId, businessId)).orderBy(desc(gmbSyncHistory.createdAt)).limit(limit);
      }
      // GMB Review operations
      async createGmbReview(reviewData) {
        const [review] = await db.insert(gmbReviews).values(reviewData).returning();
        return review;
      }
      async getGmbReviewByGmbId(businessId, gmbReviewId) {
        const [review] = await db.select().from(gmbReviews).where(and(
          eq(gmbReviews.businessId, businessId),
          eq(gmbReviews.gmbReviewId, gmbReviewId)
        ));
        return review;
      }
      async updateGmbReview(reviewId, updates) {
        await db.update(gmbReviews).set(updates).where(eq(gmbReviews.id, reviewId));
      }
      async getGmbReviewsByBusiness(businessId) {
        return await db.select().from(gmbReviews).where(and(
          eq(gmbReviews.businessId, businessId),
          eq(gmbReviews.isVisible, true)
        )).orderBy(desc(gmbReviews.reviewTime));
      }
      // Business GMB Status operations
      async updateBusinessGmbStatus(businessId, updates) {
        await db.update(businesses).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(businesses.id, businessId));
      }
      // Stripe Connect operations
      async updateBusinessStripeFields(businessId, fields) {
        try {
          await db.update(businesses).set({
            ...fields,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(businesses.id, businessId));
        } catch (error) {
          console.error("Error updating business Stripe fields:", error);
          throw error;
        }
      }
      // GMB Integration Statistics
      async getGMBIntegrationStats() {
        const [connectedResult] = await db.select({ count: sql2`count(*)` }).from(businesses).where(eq(businesses.gmbConnected, true));
        const [verifiedResult] = await db.select({ count: sql2`count(*)` }).from(businesses).where(eq(businesses.gmbVerified, true));
        const [syncResult] = await db.select({ count: sql2`count(*)` }).from(gmbSyncHistory);
        const recentSyncActivity = await db.select().from(gmbSyncHistory).orderBy(desc(gmbSyncHistory.createdAt)).limit(10);
        const [errorResult] = await db.select({ count: sql2`count(*)` }).from(gmbSyncHistory).where(eq(gmbSyncHistory.status, "error"));
        const errorRate = syncResult.count > 0 ? errorResult.count / syncResult.count * 100 : 0;
        return {
          totalConnectedBusinesses: connectedResult.count,
          totalVerifiedBusinesses: verifiedResult.count,
          totalSyncOperations: syncResult.count,
          recentSyncActivity,
          errorRates: {
            totalErrors: errorResult.count,
            errorPercentage: Math.round(errorRate * 100) / 100
          }
        };
      }
      // Enhanced spotlight operations with algorithms
      async calculateEngagementMetrics(businessId) {
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const sevenDaysAgo = /* @__PURE__ */ new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const [business] = await db.select().from(businesses).where(eq(businesses.id, businessId));
        if (!business) {
          throw new Error("Business not found");
        }
        const recentPosts = await db.select().from(posts).where(
          and(
            eq(posts.businessId, businessId),
            sql2`${posts.createdAt} >= ${sevenDaysAgo}`
          )
        );
        const totalEngagement = recentPosts.reduce(
          (sum2, post) => sum2 + (post.likeCount || 0) + (post.commentCount || 0),
          0
        );
        const postsEngagement = recentPosts.length > 0 ? totalEngagement / recentPosts.length : 0;
        const existingMetrics = await this.getEngagementMetrics(businessId);
        const currentFollowerCount = business.followerCount || 0;
        const previousFollowerCount = existingMetrics?.businessId ? currentFollowerCount - (existingMetrics.followersGrowth || 0) : 0;
        const followersGrowth = currentFollowerCount - previousFollowerCount;
        const metrics = {
          businessId,
          followersGrowth,
          postsEngagement: postsEngagement.toString(),
          recentActivity: recentPosts.length,
          productViews: 0,
          // Would be calculated from analytics if available
          profileViews: 0,
          // Would be calculated from analytics if available  
          orderCount: 0
          // Would be calculated from actual orders if available
        };
        return await this.updateEngagementMetrics(businessId, metrics);
      }
      async updateEngagementMetrics(businessId, metrics) {
        const [updated] = await db.insert(engagementMetrics).values({
          businessId,
          ...metrics
        }).onConflictDoUpdate({
          target: engagementMetrics.businessId,
          set: {
            ...metrics,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return updated;
      }
      async getEngagementMetrics(businessId) {
        const [metrics] = await db.select().from(engagementMetrics).where(eq(engagementMetrics.businessId, businessId));
        return metrics;
      }
      async getAllEngagementMetrics() {
        return await db.select().from(engagementMetrics).orderBy(desc(engagementMetrics.updatedAt));
      }
      // Spotlight history tracking
      async createSpotlightHistory(history) {
        const [created] = await db.insert(spotlightHistory).values(history).returning();
        return created;
      }
      async getSpotlightHistory(businessId) {
        return await db.select().from(spotlightHistory).where(eq(spotlightHistory.businessId, businessId)).orderBy(desc(spotlightHistory.createdAt));
      }
      async getRecentSpotlightHistory(type, days) {
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setDate(cutoffDate.getDate() - days);
        return await db.select().from(spotlightHistory).where(
          and(
            eq(spotlightHistory.type, type),
            sql2`${spotlightHistory.startDate} >= ${cutoffDate}`
          )
        ).orderBy(desc(spotlightHistory.startDate));
      }
      // Intelligent spotlight selection algorithms
      async selectDailySpotlights() {
        const eligibleBusinesses = await this.getEligibleBusinesses("daily");
        const businessesWithScores = await Promise.all(
          eligibleBusinesses.map(async (business) => {
            const score = await this.getBusinessScore(business.id);
            return { business, score };
          })
        );
        const selectedBusinesses = businessesWithScores.sort((a, b) => b.score - a.score).slice(0, 3).map((item) => item.business);
        await this.archiveExpiredSpotlights();
        const today = /* @__PURE__ */ new Date();
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        for (let i = 0; i < selectedBusinesses.length; i++) {
          const business = selectedBusinesses[i];
          const score = businessesWithScores.find((item) => item.business.id === business.id)?.score || 0;
          await db.insert(spotlights).values({
            businessId: business.id,
            type: "daily",
            position: i + 1,
            startDate: today,
            endDate: tomorrow,
            isActive: true
          });
          await this.createSpotlightHistory({
            businessId: business.id,
            type: "daily",
            position: i + 1,
            startDate: today,
            endDate: tomorrow,
            totalScore: score.toString()
          });
          await this.updateEngagementMetrics(business.id, {
            lastFeaturedDaily: today
          });
        }
        return selectedBusinesses;
      }
      async selectWeeklySpotlights() {
        const eligibleBusinesses = await this.getEligibleBusinesses("weekly");
        const businessesWithScores = await Promise.all(
          eligibleBusinesses.map(async (business) => {
            const score = await this.getBusinessScore(business.id);
            return { business, score };
          })
        );
        const businessesByCategory = businessesWithScores.reduce((acc, item) => {
          const category = item.business.category || "uncategorized";
          if (!acc[category]) acc[category] = [];
          acc[category].push(item);
          return acc;
        }, {});
        const selectedBusinesses = [];
        const categories = Object.keys(businessesByCategory);
        for (let i = 0; i < Math.min(5, categories.length); i++) {
          const category = categories[i];
          const categoryBusinesses = businessesByCategory[category].sort((a, b) => b.score - a.score);
          if (categoryBusinesses.length > 0 && selectedBusinesses.length < 5) {
            selectedBusinesses.push(categoryBusinesses[0].business);
          }
        }
        const remainingBusinesses = businessesWithScores.filter((item) => !selectedBusinesses.some((selected) => selected.id === item.business.id)).sort((a, b) => b.score - a.score);
        while (selectedBusinesses.length < 5 && remainingBusinesses.length > 0) {
          selectedBusinesses.push(remainingBusinesses.shift().business);
        }
        const today = /* @__PURE__ */ new Date();
        const nextWeek = new Date(today);
        nextWeek.setDate(nextWeek.getDate() + 7);
        for (let i = 0; i < selectedBusinesses.length; i++) {
          const business = selectedBusinesses[i];
          const score = businessesWithScores.find((item) => item.business.id === business.id)?.score || 0;
          await db.insert(spotlights).values({
            businessId: business.id,
            type: "weekly",
            position: i + 1,
            startDate: today,
            endDate: nextWeek,
            isActive: true
          });
          await this.createSpotlightHistory({
            businessId: business.id,
            type: "weekly",
            position: i + 1,
            startDate: today,
            endDate: nextWeek,
            totalScore: score.toString()
          });
          await this.updateEngagementMetrics(business.id, {
            lastFeaturedWeekly: today
          });
        }
        return selectedBusinesses;
      }
      async selectMonthlySpotlight() {
        const currentMonth = (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
        const voteCounts = await this.getMonthlyVoteCounts(currentMonth);
        const eligibleBusinesses = await this.getEligibleBusinesses("monthly");
        const businessesWithScores = await Promise.all(
          eligibleBusinesses.map(async (business) => {
            const voteCount = voteCounts.find((v) => v.businessId === business.id)?.voteCount || 0;
            const algorithmScore = await this.getBusinessScore(business.id);
            const normalizedVotes = Math.min(voteCount / 10, 100);
            const combinedScore = normalizedVotes * 0.7 + algorithmScore * 0.3;
            return { business, score: combinedScore, voteCount };
          })
        );
        const winner = businessesWithScores.sort((a, b) => b.score - a.score)[0];
        if (!winner) {
          return [];
        }
        const today = /* @__PURE__ */ new Date();
        const nextMonth = new Date(today);
        nextMonth.setMonth(nextMonth.getMonth() + 1);
        await db.insert(spotlights).values({
          businessId: winner.business.id,
          type: "monthly",
          position: 1,
          startDate: today,
          endDate: nextMonth,
          isActive: true
        });
        await this.createSpotlightHistory({
          businessId: winner.business.id,
          type: "monthly",
          position: 1,
          startDate: today,
          endDate: nextMonth,
          totalScore: winner.score.toString()
        });
        await this.updateEngagementMetrics(winner.business.id, {
          lastFeaturedMonthly: today
        });
        return [winner.business];
      }
      async getBusinessScore(businessId) {
        const business = await this.getBusinessById(businessId);
        if (!business) return 0;
        const metrics = await this.getEngagementMetrics(businessId);
        const engagementScore = metrics?.postsEngagement ? Math.min(parseFloat(metrics.postsEngagement), 100) : 0;
        const now = /* @__PURE__ */ new Date();
        const lastFeatured = metrics?.lastFeaturedDaily || metrics?.lastFeaturedWeekly || metrics?.lastFeaturedMonthly;
        let recencyScore = 100;
        if (lastFeatured) {
          const daysSinceLastFeatured = Math.floor((now.getTime() - lastFeatured.getTime()) / (1e3 * 60 * 60 * 24));
          recencyScore = Math.min(daysSinceLastFeatured * 2, 100);
        }
        const reviewsScore = Math.min((business.reviewCount || 0) * 5, 100);
        const growthScore = metrics?.followersGrowth ? Math.min((metrics.followersGrowth || 0) * 2, 100) : 0;
        const followerScore = Math.min(business.followerCount || 0, 100);
        const totalScore = engagementScore * 0.3 + recencyScore * 0.25 + reviewsScore * 0.2 + growthScore * 0.15 + followerScore * 0.1;
        return Math.round(totalScore);
      }
      async getEligibleBusinesses(type) {
        const now = /* @__PURE__ */ new Date();
        let cooldownDays = 1;
        if (type === "weekly") cooldownDays = 7;
        if (type === "monthly") cooldownDays = 30;
        const cooldownDate = new Date(now);
        cooldownDate.setDate(cooldownDate.getDate() - cooldownDays);
        const [verifiedCountRow] = await db.select({ count: sql2`count(*)` }).from(businesses).where(eq(businesses.isVerified, true));
        const requireVerified = (verifiedCountRow?.count || 0) > 0;
        const allBusinesses = await db.select().from(businesses).where(
          and(
            eq(businesses.isActive, true),
            requireVerified ? eq(businesses.isVerified, true) : sql2`TRUE`
          )
        );
        const eligibleBusinesses = [];
        for (const business of allBusinesses) {
          const currentSpotlight = await db.select().from(spotlights).where(
            and(
              eq(spotlights.businessId, business.id),
              eq(spotlights.isActive, true),
              sql2`${spotlights.endDate} > ${now}`
            )
          );
          if (currentSpotlight.length > 0) continue;
          const recentHistory = await db.select().from(spotlightHistory).where(
            and(
              eq(spotlightHistory.businessId, business.id),
              eq(spotlightHistory.type, type),
              sql2`${spotlightHistory.endDate} > ${cooldownDate}`
            )
          );
          if (recentHistory.length === 0) {
            eligibleBusinesses.push(business);
          }
        }
        return eligibleBusinesses;
      }
      // Spotlight voting (for monthly spotlight)
      async createSpotlightVote(vote) {
        const [created] = await db.insert(spotlightVotes).values(vote).returning();
        return created;
      }
      async getSpotlightVotes(businessId, month) {
        return await db.select().from(spotlightVotes).where(
          and(
            eq(spotlightVotes.businessId, businessId),
            eq(spotlightVotes.month, month)
          )
        );
      }
      async getMonthlyVoteCounts(month) {
        const votes = await db.select({
          businessId: spotlightVotes.businessId,
          voteCount: sql2`count(*)`.as("voteCount")
        }).from(spotlightVotes).where(eq(spotlightVotes.month, month)).groupBy(spotlightVotes.businessId).orderBy(desc(sql2`count(*)`));
        return votes;
      }
      async hasUserVoted(userId, month) {
        const [vote] = await db.select().from(spotlightVotes).where(
          and(
            eq(spotlightVotes.userId, userId),
            eq(spotlightVotes.month, month)
          )
        );
        return !!vote;
      }
      // Get which business the user voted for in a specific month
      async getUserVoteForMonth(userId, month) {
        const [vote] = await db.select().from(spotlightVotes).where(
          and(
            eq(spotlightVotes.userId, userId),
            eq(spotlightVotes.month, month)
          )
        );
        return vote;
      }
      // Get eligible businesses for voting with vote counts and trend data
      async getEligibleForVoting(limit = 20) {
        const currentMonth = (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
        const eligible = await this.getEligibleBusinesses("monthly");
        const voteCounts = await this.getMonthlyVoteCounts(currentMonth);
        const voteMap = new Map(voteCounts.map((v) => [v.businessId, v.voteCount]));
        const enrichedBusinesses = await Promise.all(
          eligible.slice(0, limit).map(async (business) => {
            const voteCount = voteMap.get(business.id) || 0;
            const trendScore = Math.min(100, voteCount * 10 + (business.averageRating || 0) * 15);
            return {
              ...business,
              voteCount,
              trendScore,
              isEligible: true
            };
          })
        );
        return enrichedBusinesses.sort((a, b) => b.voteCount - a.voteCount);
      }
      // Get voting statistics for the current month
      async getVotingStats(month) {
        const voteCounts = await this.getMonthlyVoteCounts(month);
        const [totalVotersRow] = await db.select({ count: sql2`count(distinct ${spotlightVotes.userId})` }).from(spotlightVotes).where(eq(spotlightVotes.month, month));
        const totalVotes = voteCounts.reduce((sum2, v) => sum2 + v.voteCount, 0);
        const totalVoters = totalVotersRow?.count || 0;
        const participatingBusinesses = voteCounts.length;
        const now = /* @__PURE__ */ new Date();
        const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        const daysRemaining = Math.max(0, Math.ceil((lastDayOfMonth.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24)));
        return {
          totalVotes,
          totalVoters,
          participatingBusinesses,
          daysRemaining,
          month,
          topBusinesses: voteCounts.slice(0, 3).map((v, index2) => ({
            businessId: v.businessId,
            voteCount: v.voteCount,
            rank: index2 + 1
          }))
        };
      }
      // Get all votes by a specific user for a month
      async getUserVotes(userId, month) {
        return await db.select().from(spotlightVotes).where(
          and(
            eq(spotlightVotes.userId, userId),
            eq(spotlightVotes.month, month)
          )
        );
      }
      // Community Leaderboard Methods
      async getTopBusinesses(limit = 10) {
        const topBusinesses = await db.select({
          id: businesses.id,
          name: businesses.name,
          logoUrl: businesses.logoUrl,
          description: businesses.description,
          averageRating: businesses.averageRating,
          totalReviews: businesses.totalReviews,
          totalOrders: businesses.totalOrders,
          followers: businesses.followers,
          city: businesses.city,
          state: businesses.state
        }).from(businesses).where(
          and(
            eq(businesses.isActive, true),
            sql2`${businesses.averageRating} > 0`
          )
        ).orderBy(
          desc(sql2`
          (${businesses.averageRating} * 20) +
          (LEAST(${businesses.totalReviews}, 100) * 0.5) +
          (LEAST(${businesses.totalOrders}, 50) * 1.0) +
          (LEAST(${businesses.followers}, 200) * 0.3)
        `)
        ).limit(limit);
        return topBusinesses.map((business, index2) => ({
          ...business,
          rank: index2 + 1,
          score: (business.averageRating || 0) * 20 + Math.min(business.totalReviews || 0, 100) * 0.5 + Math.min(business.totalOrders || 0, 50) * 1 + Math.min(business.followers || 0, 200) * 0.3
        }));
      }
      async getTopVoters(limit = 10) {
        const topVoters = await db.select({
          userId: spotlightVotes.userId,
          voteCount: sql2`count(*)`.as("voteCount"),
          user: {
            firstName: users.firstName,
            lastName: users.lastName,
            profileImage: users.profileImage
          }
        }).from(spotlightVotes).leftJoin(users, eq(spotlightVotes.userId, users.id)).groupBy(spotlightVotes.userId, users.id).orderBy(desc(sql2`count(*)`)).limit(limit);
        return topVoters.map((voter, index2) => ({
          id: voter.userId,
          name: `${voter.user?.firstName || "Unknown"} ${voter.user?.lastName || "User"}`,
          avatar: voter.user?.profileImage,
          count: voter.voteCount,
          rank: index2 + 1
        }));
      }
      async getTopReviewers(limit = 10) {
        const topReviewers = await db.select({
          userId: businessReviews.userId,
          reviewCount: sql2`count(*)`.as("reviewCount"),
          avgRating: sql2`avg(${businessReviews.rating})`.as("avgRating"),
          user: {
            firstName: users.firstName,
            lastName: users.lastName,
            profileImage: users.profileImage
          }
        }).from(businessReviews).leftJoin(users, eq(businessReviews.userId, users.id)).groupBy(businessReviews.userId, users.id).orderBy(desc(sql2`count(*)`)).limit(limit);
        return topReviewers.map((reviewer, index2) => ({
          id: reviewer.userId,
          name: `${reviewer.user?.firstName || "Unknown"} ${reviewer.user?.lastName || "User"}`,
          avatar: reviewer.user?.profileImage,
          count: reviewer.reviewCount,
          avgRating: reviewer.avgRating ? Number(reviewer.avgRating).toFixed(1) : "0.0",
          rank: index2 + 1
        }));
      }
      async getTopBuyers(limit = 10) {
        const topBuyers = await db.select({
          userId: orders.userId,
          orderCount: sql2`count(distinct ${orders.id})`.as("orderCount"),
          totalSpent: sql2`sum(${orders.total})`.as("totalSpent"),
          user: {
            firstName: users.firstName,
            lastName: users.lastName,
            profileImage: users.profileImage
          }
        }).from(orders).leftJoin(users, eq(orders.userId, users.id)).where(eq(orders.status, "completed")).groupBy(orders.userId, users.id).orderBy(desc(sql2`sum(${orders.total})`)).limit(limit);
        return topBuyers.map((buyer, index2) => ({
          id: buyer.userId,
          name: `${buyer.user?.firstName || "Unknown"} ${buyer.user?.lastName || "User"}`,
          avatar: buyer.user?.profileImage,
          count: buyer.orderCount,
          totalSpent: buyer.totalSpent ? Number(buyer.totalSpent).toFixed(2) : "0.00",
          rank: index2 + 1
        }));
      }
      async getTrendingBusinesses(limit = 10) {
        const sevenDaysAgo = /* @__PURE__ */ new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const trendingBusinesses = await db.select({
          id: businesses.id,
          name: businesses.name,
          logoUrl: businesses.logoUrl,
          description: businesses.description,
          category: businesses.category,
          averageRating: businesses.averageRating,
          totalReviews: businesses.totalReviews,
          totalOrders: businesses.totalOrders,
          followers: businesses.followers,
          city: businesses.city,
          state: businesses.state,
          createdAt: businesses.createdAt
        }).from(businesses).where(eq(businesses.isActive, true)).orderBy(
          desc(sql2`
          (CASE WHEN ${businesses.createdAt} > ${sevenDaysAgo} THEN 50 ELSE 0 END) +
          (${businesses.averageRating} * 15) +
          (LEAST(${businesses.totalReviews}, 50) * 0.8) +
          (LEAST(${businesses.totalOrders}, 30) * 1.2) +
          (LEAST(${businesses.followers}, 100) * 0.5)
        `)
        ).limit(limit);
        return trendingBusinesses.map((business, index2) => {
          const isNew = business.createdAt && new Date(business.createdAt) > sevenDaysAgo;
          const trendScore = Math.min(100, Math.round(
            (isNew ? 50 : 0) + (business.averageRating || 0) * 15 + Math.min(business.totalReviews || 0, 50) * 0.8 + Math.min(business.totalOrders || 0, 30) * 1.2 + Math.min(business.followers || 0, 100) * 0.5
          ));
          return {
            ...business,
            trendScore,
            isNew,
            rank: index2 + 1
          };
        });
      }
      async rotateSpotlights() {
        const now = /* @__PURE__ */ new Date();
        const currentTime = now.getTime();
        if (this.rotationInProgress.has("global")) {
          console.warn("Spotlight rotation already in progress, skipping...");
          return;
        }
        try {
          this.rotationInProgress.add("global");
          console.log("Starting spotlight rotation process...");
          const lastRotation = this.lastRotationTimes.get("global");
          const MIN_ROTATION_INTERVAL = 60 * 1e3;
          if (lastRotation && currentTime - lastRotation < MIN_ROTATION_INTERVAL) {
            console.warn(`Rotation triggered too soon. Last rotation: ${new Date(lastRotation).toISOString()}`);
            return;
          }
          this.lastRotationTimes.set("global", currentTime);
          let rotationsPerformed = 0;
          if (await this.shouldRotateSpotlight("daily", now)) {
            console.log("Performing daily spotlight rotation...");
            await this.selectDailySpotlights();
            rotationsPerformed++;
          }
          if (await this.shouldRotateSpotlight("weekly", now)) {
            console.log("Performing weekly spotlight rotation...");
            await this.selectWeeklySpotlights();
            rotationsPerformed++;
          }
          if (await this.shouldRotateSpotlight("monthly", now)) {
            console.log("Performing monthly spotlight rotation...");
            await this.selectMonthlySpotlight();
            rotationsPerformed++;
          }
          if (rotationsPerformed === 0) {
            console.log("No spotlight rotations needed at this time.");
          } else {
            console.log(`Completed ${rotationsPerformed} spotlight rotation(s).`);
          }
          await this.archiveExpiredSpotlights();
        } catch (error) {
          console.error("Error during spotlight rotation:", error);
          throw error;
        } finally {
          this.rotationInProgress.delete("global");
        }
      }
      // SECURITY: Enhanced rotation timing validation
      async shouldRotateSpotlight(type, now) {
        const lastRotation = await db.select().from(spotlights).where(eq(spotlights.type, type)).orderBy(desc(spotlights.createdAt)).limit(1);
        if (!lastRotation.length) {
          return true;
        }
        if (!lastRotation[0].createdAt) {
          return true;
        }
        const lastRotationTime = new Date(lastRotation[0].createdAt).getTime();
        const currentTime = now.getTime();
        const timeDiff = currentTime - lastRotationTime;
        const intervals = {
          daily: 20 * 60 * 60 * 1e3,
          // 20 hours (allows for some flexibility)
          weekly: 6.5 * 24 * 60 * 60 * 1e3,
          // 6.5 days 
          monthly: 25 * 24 * 60 * 60 * 1e3
          // 25 days (monthly is more flexible due to voting)
        };
        const shouldRotate = timeDiff > intervals[type];
        if (!shouldRotate) {
          const nextRotation = new Date(lastRotationTime + intervals[type]);
          console.log(`${type} rotation not due yet. Next rotation: ${nextRotation.toISOString()}`);
        }
        return shouldRotate;
      }
      // SECURITY: Manual rotation validation for admin use
      async canPerformManualRotation() {
        if (this.rotationInProgress.has("global")) {
          return { canRotate: false, reason: "Rotation already in progress" };
        }
        const lastRotation = this.lastRotationTimes.get("global");
        const MIN_MANUAL_INTERVAL = 30 * 1e3;
        if (lastRotation && Date.now() - lastRotation < MIN_MANUAL_INTERVAL) {
          const nextAllowed = new Date(lastRotation + MIN_MANUAL_INTERVAL);
          return {
            canRotate: false,
            reason: `Manual rotation cooling down. Next allowed: ${nextAllowed.toISOString()}`
          };
        }
        return { canRotate: true };
      }
      async archiveExpiredSpotlights() {
        const now = /* @__PURE__ */ new Date();
        await db.update(spotlights).set({ isActive: false }).where(
          and(
            eq(spotlights.isActive, true),
            sql2`${spotlights.endDate} <= ${now}`
          )
        );
      }
      async createApiKey(apiKeyData) {
        const [apiKey2] = await db.insert(apiKeys).values(apiKeyData).returning();
        return apiKey2;
      }
      async getApiKeyByHash(keyHash) {
        const [apiKey2] = await db.select().from(apiKeys).where(eq(apiKeys.keyHash, keyHash)).limit(1);
        return apiKey2;
      }
      async updateApiKeyLastUsed(keyId) {
        await db.update(apiKeys).set({
          lastUsedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(apiKeys.id, keyId));
      }
      // ========================================
      // ADMIN METHODS - Platform Management
      // ========================================
      async getAllUsers() {
        return await db.select().from(users).orderBy(desc(users.createdAt));
      }
      async getAllBusinesses() {
        return await db.select().from(businesses).orderBy(desc(businesses.createdAt));
      }
      async getAllOrders() {
        return await db.select().from(orders).orderBy(desc(orders.createdAt));
      }
      async getAllPosts() {
        return await db.select().from(posts).orderBy(desc(posts.createdAt));
      }
      async getAllProducts() {
        return await db.select().from(products).orderBy(desc(products.createdAt));
      }
      async updateUser(userId, updates) {
        const [user] = await db.update(users).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(users.id, userId)).returning();
        return user;
      }
      // ====================================================================
      // PHASE 4: BLOG STORAGE METHODS
      // ====================================================================
      // Blog Posts
      async getBlogPosts(filters) {
        const {
          status = "published",
          categoryId,
          tag,
          authorId,
          featured,
          limit = 20,
          offset = 0,
          orderBy = "publishedAt",
          order = "desc"
        } = filters;
        let query = db.select({
          post: blogPosts,
          author: {
            id: users.id,
            firstName: users.firstName,
            lastName: users.lastName,
            profileImageUrl: users.profileImageUrl
          },
          category: {
            id: blogCategories.id,
            name: blogCategories.name,
            slug: blogCategories.slug,
            color: blogCategories.color
          }
        }).from(blogPosts).leftJoin(users, eq(blogPosts.authorId, users.id)).leftJoin(blogCategories, eq(blogPosts.categoryId, blogCategories.id)).$dynamic();
        const conditions = [];
        if (status) {
          conditions.push(eq(blogPosts.status, status));
        }
        if (categoryId) {
          conditions.push(eq(blogPosts.categoryId, categoryId));
        }
        if (authorId) {
          conditions.push(eq(blogPosts.authorId, authorId));
        }
        if (featured !== void 0) {
          conditions.push(eq(blogPosts.isFeatured, featured));
        }
        if (conditions.length > 0) {
          query = query.where(and(...conditions));
        }
        const orderColumn = orderBy === "publishedAt" ? blogPosts.publishedAt : orderBy === "viewCount" ? blogPosts.viewCount : orderBy === "likeCount" ? blogPosts.likeCount : blogPosts.createdAt;
        query = query.orderBy(order === "desc" ? desc(orderColumn) : orderColumn);
        query = query.limit(limit).offset(offset);
        const results = await query;
        return results.map((r) => ({
          ...r.post,
          author: r.author,
          category: r.category
        }));
      }
      async getBlogPost(id) {
        const results = await db.select({
          post: blogPosts,
          author: {
            id: users.id,
            firstName: users.firstName,
            lastName: users.lastName,
            profileImageUrl: users.profileImageUrl
          },
          category: {
            id: blogCategories.id,
            name: blogCategories.name,
            slug: blogCategories.slug,
            color: blogCategories.color
          }
        }).from(blogPosts).leftJoin(users, eq(blogPosts.authorId, users.id)).leftJoin(blogCategories, eq(blogPosts.categoryId, blogCategories.id)).where(eq(blogPosts.id, id)).limit(1);
        if (results.length === 0) return null;
        const result = results[0];
        return {
          ...result.post,
          author: result.author,
          category: result.category
        };
      }
      async getBlogPostBySlug(slug) {
        const results = await db.select({
          post: blogPosts,
          author: {
            id: users.id,
            firstName: users.firstName,
            lastName: users.lastName,
            profileImageUrl: users.profileImageUrl
          },
          category: {
            id: blogCategories.id,
            name: blogCategories.name,
            slug: blogCategories.slug,
            color: blogCategories.color
          }
        }).from(blogPosts).leftJoin(users, eq(blogPosts.authorId, users.id)).leftJoin(blogCategories, eq(blogPosts.categoryId, blogCategories.id)).where(eq(blogPosts.slug, slug)).limit(1);
        if (results.length === 0) return null;
        const result = results[0];
        return {
          ...result.post,
          author: result.author,
          category: result.category
        };
      }
      async createBlogPost(data) {
        const [post] = await db.insert(blogPosts).values({
          ...data,
          publishedAt: data.status === "published" ? /* @__PURE__ */ new Date() : data.publishedAt
        }).returning();
        return post;
      }
      async updateBlogPost(id, data) {
        const [post] = await db.update(blogPosts).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(blogPosts.id, id)).returning();
        return post;
      }
      async deleteBlogPost(id) {
        await db.delete(blogPosts).where(eq(blogPosts.id, id));
      }
      async getRelatedBlogPosts(postId, limit) {
        const post = await this.getBlogPost(postId);
        if (!post) return [];
        const postTags = await db.select({ tagId: blogPostTags.tagId }).from(blogPostTags).where(eq(blogPostTags.postId, postId));
        const tagIds = postTags.map((pt) => pt.tagId);
        let query = db.select({
          post: blogPosts,
          author: {
            id: users.id,
            firstName: users.firstName,
            lastName: users.lastName,
            profileImageUrl: users.profileImageUrl
          }
        }).from(blogPosts).leftJoin(users, eq(blogPosts.authorId, users.id)).where(
          and(
            eq(blogPosts.status, "published"),
            sql2`${blogPosts.id} != ${postId}`,
            // Exclude current post
            or(
              eq(blogPosts.categoryId, post.categoryId),
              tagIds.length > 0 ? sql2`${blogPosts.id} IN (
                  SELECT ${blogPostTags.postId}
                  FROM ${blogPostTags}
                  WHERE ${blogPostTags.tagId} IN ${tagIds}
                )` : void 0
            )
          )
        ).orderBy(desc(blogPosts.publishedAt)).limit(limit);
        const results = await query;
        return results.map((r) => ({
          ...r.post,
          author: r.author
        }));
      }
      async addTagsToBlogPost(postId, tags) {
        for (const tagName of tags) {
          const slug = tagName.toLowerCase().replace(/\s+/g, "-");
          let [tag] = await db.select().from(blogTags).where(eq(blogTags.slug, slug)).limit(1);
          if (!tag) {
            [tag] = await db.insert(blogTags).values({ name: tagName, slug }).returning();
          }
          try {
            await db.insert(blogPostTags).values({ postId, tagId: tag.id });
            await db.update(blogTags).set({ postCount: sql2`${blogTags.postCount} + 1` }).where(eq(blogTags.id, tag.id));
          } catch (error) {
          }
        }
      }
      async updateBlogPostTags(postId, tags) {
        const currentTags = await db.select({ tagId: blogPostTags.tagId }).from(blogPostTags).where(eq(blogPostTags.postId, postId));
        const currentTagIds = currentTags.map((t) => t.tagId);
        if (currentTagIds.length > 0) {
          await db.delete(blogPostTags).where(eq(blogPostTags.postId, postId));
          await db.update(blogTags).set({ postCount: sql2`${blogTags.postCount} - 1` }).where(inArray(blogTags.id, currentTagIds));
        }
        await this.addTagsToBlogPost(postId, tags);
      }
      // Categories
      async getBlogCategories() {
        return await db.select().from(blogCategories).where(eq(blogCategories.isActive, true)).orderBy(blogCategories.name);
      }
      async createBlogCategory(data) {
        const [category] = await db.insert(blogCategories).values(data).returning();
        return category;
      }
      // Tags
      async getBlogTags(filters) {
        const { limit = 50, popular = false } = filters;
        let query = db.select().from(blogTags).$dynamic();
        if (popular) {
          query = query.orderBy(desc(blogTags.postCount));
        } else {
          query = query.orderBy(blogTags.name);
        }
        return await query.limit(limit);
      }
      // Comments
      async getBlogComments(postId) {
        const results = await db.select({
          comment: blogComments,
          author: {
            id: users.id,
            firstName: users.firstName,
            lastName: users.lastName,
            profileImageUrl: users.profileImageUrl
          }
        }).from(blogComments).leftJoin(users, eq(blogComments.authorId, users.id)).where(eq(blogComments.postId, postId)).orderBy(blogComments.createdAt);
        return results.map((r) => ({
          ...r.comment,
          author: r.author
        }));
      }
      async getBlogComment(id) {
        const [comment] = await db.select().from(blogComments).where(eq(blogComments.id, id)).limit(1);
        return comment || null;
      }
      async createBlogComment(data) {
        const [comment] = await db.insert(blogComments).values(data).returning();
        await db.update(blogPosts).set({ commentCount: sql2`${blogPosts.commentCount} + 1` }).where(eq(blogPosts.id, data.postId));
        if (data.parentCommentId) {
          await db.update(blogComments).set({ replyCount: sql2`${blogComments.replyCount} + 1` }).where(eq(blogComments.id, data.parentCommentId));
        }
        return comment;
      }
      async updateBlogComment(id, data) {
        const [comment] = await db.update(blogComments).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(blogComments.id, id)).returning();
        return comment;
      }
      async deleteBlogComment(id) {
        const comment = await this.getBlogComment(id);
        if (!comment) return;
        await db.update(blogPosts).set({ commentCount: sql2`${blogPosts.commentCount} - 1` }).where(eq(blogPosts.id, comment.postId));
        if (comment.parentCommentId) {
          await db.update(blogComments).set({ replyCount: sql2`${blogComments.replyCount} - 1` }).where(eq(blogComments.id, comment.parentCommentId));
        }
        await db.delete(blogComments).where(eq(blogComments.id, id));
      }
      // Reactions
      async getBlogReactions(postId) {
        return await db.select().from(blogReactions).where(eq(blogReactions.postId, postId));
      }
      async upsertBlogReaction(data) {
        const [existing] = await db.select().from(blogReactions).where(
          and(
            eq(blogReactions.postId, data.postId),
            eq(blogReactions.userId, data.userId),
            eq(blogReactions.reactionType, data.reactionType)
          )
        ).limit(1);
        if (existing) {
          const [updated] = await db.update(blogReactions).set({
            count: data.count || existing.count + 1,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(blogReactions.id, existing.id)).returning();
          return updated;
        } else {
          const [reaction] = await db.insert(blogReactions).values(data).returning();
          await db.update(blogPosts).set({ likeCount: sql2`${blogPosts.likeCount} + 1` }).where(eq(blogPosts.id, data.postId));
          return reaction;
        }
      }
      async deleteBlogReaction(postId, userId, reactionType) {
        await db.delete(blogReactions).where(
          and(
            eq(blogReactions.postId, postId),
            eq(blogReactions.userId, userId),
            eq(blogReactions.reactionType, reactionType)
          )
        );
        await db.update(blogPosts).set({ likeCount: sql2`${blogPosts.likeCount} - 1` }).where(eq(blogPosts.id, postId));
      }
      // Bookmarks
      async getBlogBookmarks(userId) {
        const results = await db.select({
          bookmark: blogBookmarks,
          post: {
            id: blogPosts.id,
            title: blogPosts.title,
            slug: blogPosts.slug,
            excerpt: blogPosts.excerpt,
            featuredImageUrl: blogPosts.featuredImageUrl,
            publishedAt: blogPosts.publishedAt
          }
        }).from(blogBookmarks).leftJoin(blogPosts, eq(blogBookmarks.postId, blogPosts.id)).where(eq(blogBookmarks.userId, userId)).orderBy(desc(blogBookmarks.createdAt));
        return results.map((r) => ({
          ...r.bookmark,
          post: r.post
        }));
      }
      async createBlogBookmark(data) {
        const [bookmark] = await db.insert(blogBookmarks).values(data).returning();
        await db.update(blogPosts).set({ bookmarkCount: sql2`${blogPosts.bookmarkCount} + 1` }).where(eq(blogPosts.id, data.postId));
        return bookmark;
      }
      async deleteBlogBookmark(postId, userId) {
        await db.delete(blogBookmarks).where(
          and(
            eq(blogBookmarks.postId, postId),
            eq(blogBookmarks.userId, userId)
          )
        );
        await db.update(blogPosts).set({ bookmarkCount: sql2`${blogPosts.bookmarkCount} - 1` }).where(eq(blogPosts.id, postId));
      }
      // Subscriptions
      async createBlogSubscription(data) {
        const [subscription] = await db.insert(blogSubscriptions).values(data).returning();
        return subscription;
      }
      async unsubscribeBlog(token) {
        await db.update(blogSubscriptions).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(blogSubscriptions.unsubscribeToken, token));
      }
      // Analytics
      async trackBlogAnalytics(data) {
        await db.insert(blogAnalytics).values(data);
        if (data.viewType === "page_view") {
          await db.update(blogPosts).set({ viewCount: sql2`${blogPosts.viewCount} + 1` }).where(eq(blogPosts.id, data.postId));
          if (data.sessionId) {
            const existingViews = await db.select().from(blogAnalytics).where(
              and(
                eq(blogAnalytics.postId, data.postId),
                eq(blogAnalytics.sessionId, data.sessionId)
              )
            ).limit(1);
            if (existingViews.length === 0) {
              await db.update(blogPosts).set({ uniqueViewCount: sql2`${blogPosts.uniqueViewCount} + 1` }).where(eq(blogPosts.id, data.postId));
            }
          }
        }
      }
      async getBlogPostAnalytics(postId) {
        const [post] = await db.select({
          viewCount: blogPosts.viewCount,
          uniqueViewCount: blogPosts.uniqueViewCount,
          likeCount: blogPosts.likeCount,
          commentCount: blogPosts.commentCount,
          bookmarkCount: blogPosts.bookmarkCount,
          shareCount: blogPosts.shareCount,
          readCompletionRate: blogPosts.readCompletionRate
        }).from(blogPosts).where(eq(blogPosts.id, postId)).limit(1);
        const analyticsData = await db.select().from(blogAnalytics).where(eq(blogAnalytics.postId, postId));
        const totalViews = analyticsData.filter((a) => a.viewType === "page_view").length;
        const avgReadTime = analyticsData.reduce((sum2, a) => sum2 + (a.timeSpentSeconds || 0), 0) / (totalViews || 1);
        const trafficSources = {};
        analyticsData.forEach((a) => {
          const source = a.utmSource || a.referrer || "direct";
          trafficSources[source] = (trafficSources[source] || 0) + 1;
        });
        const trafficSourcesArray = Object.entries(trafficSources).map(([source, visits]) => ({
          source,
          visits,
          percentage: visits / totalViews * 100
        })).sort((a, b) => b.visits - a.visits);
        const deviceBreakdown = {
          desktop: analyticsData.filter((a) => a.deviceType === "desktop").length,
          mobile: analyticsData.filter((a) => a.deviceType === "mobile").length,
          tablet: analyticsData.filter((a) => a.deviceType === "tablet").length
        };
        const geographicData = {};
        analyticsData.forEach((a) => {
          if (a.country) {
            geographicData[a.country] = (geographicData[a.country] || 0) + 1;
          }
        });
        const geographicDataArray = Object.entries(geographicData).map(([country, visits]) => ({
          country,
          visits
        })).sort((a, b) => b.visits - a.visits);
        return {
          overview: {
            totalViews: post.viewCount,
            uniqueViews: post.uniqueViewCount,
            avgReadTime: Math.floor(avgReadTime),
            readCompletionRate: post.readCompletionRate,
            totalReactions: post.likeCount,
            totalComments: post.commentCount,
            totalBookmarks: post.bookmarkCount,
            totalShares: post.shareCount
          },
          trafficSources: trafficSourcesArray,
          deviceBreakdown,
          geographicData: geographicDataArray,
          engagementMetrics: {
            avgScrollDepth: 0,
            // TODO: Calculate from scroll events
            bounceRate: 0,
            // TODO: Calculate
            avgTimeOnPage: Math.floor(avgReadTime)
          }
        };
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/utils/retry.ts
async function retryWithBackoff(fn, options = {}) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  let lastError;
  for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {
    try {
      const result = await fn();
      if (attempt > 1) {
        logger.info("\u2705 Retry successful", {
          attempt,
          totalAttempts: opts.maxAttempts
        });
      }
      return result;
    } catch (error) {
      lastError = error;
      if (options.shouldRetry && !options.shouldRetry(lastError)) {
        logger.debug("\u{1F6AB} Error not retryable, throwing immediately", {
          error: lastError.message
        });
        throw lastError;
      }
      if (attempt === opts.maxAttempts) {
        logger.error("\u274C All retry attempts exhausted", {
          attempts: opts.maxAttempts,
          finalError: lastError.message
        });
        throw lastError;
      }
      const delay = Math.min(
        opts.initialDelayMs * Math.pow(opts.backoffMultiplier, attempt - 1),
        opts.maxDelayMs
      );
      logger.warn(`\u26A0\uFE0F  Retry attempt ${attempt}/${opts.maxAttempts} failed, retrying in ${delay}ms`, {
        error: lastError.message,
        attempt,
        maxAttempts: opts.maxAttempts,
        delayMs: delay
      });
      if (options.onRetry) {
        try {
          options.onRetry(lastError, attempt);
        } catch (callbackError) {
          logger.error("\u274C onRetry callback failed:", {
            error: callbackError.message
          });
        }
      }
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  throw lastError || new Error("Retry failed for unknown reason");
}
function isRetryableError(error) {
  const message = error.message.toLowerCase();
  if (message.includes("timeout") || message.includes("econnrefused") || message.includes("econnreset") || message.includes("etimedout") || message.includes("network") || message.includes("socket hang up")) {
    return true;
  }
  if (message.match(/5\d{2}/)) {
    return true;
  }
  if (message.includes("connection") && (message.includes("lost") || message.includes("closed"))) {
    return true;
  }
  return false;
}
async function retryDatabaseOperation(operationName, fn) {
  return retryWithBackoff(fn, {
    maxAttempts: 3,
    initialDelayMs: 500,
    maxDelayMs: 5e3,
    shouldRetry: isRetryableError,
    onRetry: (error, attempt) => {
      logger.warn(`\u{1F504} Retrying database operation: ${operationName}`, {
        attempt,
        error: error.message
      });
    }
  });
}
async function retryExternalApi(apiName, fn) {
  return retryWithBackoff(fn, {
    maxAttempts: 3,
    initialDelayMs: 1e3,
    maxDelayMs: 1e4,
    shouldRetry: (error) => {
      if (isRetryableError(error)) return true;
      const message = error.message.toLowerCase();
      if (message.includes("discovery") || message.includes("well-known") || message.includes("issuer")) {
        return true;
      }
      return false;
    },
    onRetry: (error, attempt) => {
      logger.warn(`\u{1F504} Retrying external API: ${apiName}`, {
        attempt,
        error: error.message
      });
    }
  });
}
var DEFAULT_OPTIONS;
var init_retry = __esm({
  "server/utils/retry.ts"() {
    "use strict";
    init_monitoring();
    DEFAULT_OPTIONS = {
      maxAttempts: 3,
      initialDelayMs: 1e3,
      maxDelayMs: 1e4,
      backoffMultiplier: 2
    };
  }
});

// server/utils/circuitBreaker.ts
var DEFAULT_OPTIONS2, CircuitBreaker;
var init_circuitBreaker = __esm({
  "server/utils/circuitBreaker.ts"() {
    "use strict";
    init_monitoring();
    DEFAULT_OPTIONS2 = {
      failureThreshold: 5,
      successThreshold: 2,
      timeout: 6e4,
      // 1 minute
      name: "CircuitBreaker"
    };
    CircuitBreaker = class {
      constructor(options = {}) {
        this.cachedResult = null;
        this.options = { ...DEFAULT_OPTIONS2, ...options };
        this.state = {
          state: "CLOSED" /* CLOSED */,
          failureCount: 0,
          successCount: 0,
          lastFailureTime: 0,
          lastSuccessTime: 0
        };
      }
      /**
       * Execute a function with circuit breaker protection
       */
      async execute(fn) {
        if (this.state.state === "OPEN" /* OPEN */) {
          const timeSinceLastFailure = Date.now() - this.state.lastFailureTime;
          if (timeSinceLastFailure >= this.options.timeout) {
            logger.info(`\u{1F504} ${this.options.name}: Transitioning to HALF_OPEN (timeout reached)`, {
              timeout: this.options.timeout,
              timeSinceLastFailure
            });
            this.transitionTo("HALF_OPEN" /* HALF_OPEN */);
          } else {
            logger.warn(`\u26A1 ${this.options.name}: Circuit is OPEN, using cached result`, {
              timeUntilRetry: this.options.timeout - timeSinceLastFailure
            });
            if (this.cachedResult) {
              return this.cachedResult;
            }
            throw new Error(`Circuit breaker is OPEN for ${this.options.name}. Service unavailable.`);
          }
        }
        try {
          const result = await fn();
          this.onSuccess(result);
          return result;
        } catch (error) {
          this.onFailure(error);
          throw error;
        }
      }
      onSuccess(result) {
        this.state.lastSuccessTime = Date.now();
        this.cachedResult = result;
        if (this.state.state === "HALF_OPEN" /* HALF_OPEN */) {
          this.state.successCount++;
          logger.info(`\u2705 ${this.options.name}: Success in HALF_OPEN (${this.state.successCount}/${this.options.successThreshold})`, {
            successCount: this.state.successCount,
            threshold: this.options.successThreshold
          });
          if (this.state.successCount >= this.options.successThreshold) {
            logger.info(`\u{1F513} ${this.options.name}: Circuit closing (threshold reached)`);
            this.transitionTo("CLOSED" /* CLOSED */);
          }
        } else if (this.state.state === "CLOSED" /* CLOSED */) {
          this.state.failureCount = 0;
        }
      }
      onFailure(error) {
        this.state.lastFailureTime = Date.now();
        this.state.failureCount++;
        logger.warn(`\u274C ${this.options.name}: Failure (${this.state.failureCount}/${this.options.failureThreshold})`, {
          error: error.message,
          failureCount: this.state.failureCount,
          threshold: this.options.failureThreshold
        });
        if (this.state.state === "HALF_OPEN" /* HALF_OPEN */) {
          logger.error(`\u{1F512} ${this.options.name}: Opening circuit (failed in HALF_OPEN)`);
          this.transitionTo("OPEN" /* OPEN */);
        } else if (this.state.state === "CLOSED" /* CLOSED */ && this.state.failureCount >= this.options.failureThreshold) {
          logger.error(`\u{1F512} ${this.options.name}: Opening circuit (threshold reached)`, {
            failureCount: this.state.failureCount,
            threshold: this.options.failureThreshold
          });
          this.transitionTo("OPEN" /* OPEN */);
        }
      }
      transitionTo(newState) {
        const oldState = this.state.state;
        if (oldState === newState) {
          return;
        }
        this.state.state = newState;
        if (newState === "CLOSED" /* CLOSED */) {
          this.state.failureCount = 0;
          this.state.successCount = 0;
        } else if (newState === "HALF_OPEN" /* HALF_OPEN */) {
          this.state.successCount = 0;
        }
        logger.info(`\u{1F504} ${this.options.name}: State transition: ${oldState} \u2192 ${newState}`);
        if (this.options.onStateChange) {
          try {
            this.options.onStateChange(oldState, newState);
          } catch (error) {
            logger.error(`\u274C ${this.options.name}: State change callback failed`, {
              error: error.message
            });
          }
        }
      }
      /**
       * Get current circuit state for monitoring
       */
      getState() {
        return {
          ...this.state,
          hasCachedResult: this.cachedResult !== null
        };
      }
      /**
       * Manually reset the circuit breaker
       */
      reset() {
        logger.info(`\u{1F504} ${this.options.name}: Manual reset`);
        this.state = {
          state: "CLOSED" /* CLOSED */,
          failureCount: 0,
          successCount: 0,
          lastFailureTime: 0,
          lastSuccessTime: 0
        };
        this.cachedResult = null;
      }
      /**
       * Get metrics for monitoring
       */
      getMetrics() {
        const totalRequests = this.state.failureCount + this.state.successCount;
        const failureRate = totalRequests > 0 ? this.state.failureCount / totalRequests * 100 : 0;
        return {
          state: this.state.state,
          failureCount: this.state.failureCount,
          successCount: this.state.successCount,
          totalRequests,
          failureRate: failureRate.toFixed(2) + "%",
          lastFailure: this.state.lastFailureTime ? new Date(this.state.lastFailureTime).toISOString() : null,
          lastSuccess: this.state.lastSuccessTime ? new Date(this.state.lastSuccessTime).toISOString() : null,
          hasCachedResult: this.cachedResult !== null
        };
      }
    };
  }
});

// server/metrics/authMetrics.ts
var AuthMetricsCollector, authMetrics;
var init_authMetrics = __esm({
  "server/metrics/authMetrics.ts"() {
    "use strict";
    init_monitoring();
    AuthMetricsCollector = class {
      constructor() {
        this.metrics = [];
        this.maxMetrics = 1e4;
        // Keep last 10k metrics in memory
        this.metricsWindow = 36e5;
        // 1 hour
        // Counters
        this.loginAttempts = { success: 0, failure: 0 };
        this.sessionErrors = { deserialize: 0, store: 0, expired: 0 };
        this.oidcOperations = { discovery: 0, token: 0, userinfo: 0 };
        this.activeSessions = /* @__PURE__ */ new Set();
      }
      /**
       * Record a login attempt
       */
      recordLoginAttempt(result, duration, userId, error) {
        this.loginAttempts[result]++;
        this.addMetric({
          timestamp: Date.now(),
          operation: "login",
          result,
          duration,
          userId,
          error
        });
        logger.info(`\u{1F4CA} Auth Metric: Login ${result}`, {
          duration: `${duration}ms`,
          userId,
          totalSuccess: this.loginAttempts.success,
          totalFailure: this.loginAttempts.failure
        });
      }
      /**
       * Record OIDC operation (discovery, token exchange, userinfo)
       */
      recordOidcOperation(step, result, duration, error) {
        if (result === "success") {
          this.oidcOperations[step]++;
        }
        this.addMetric({
          timestamp: Date.now(),
          operation: `oidc_${step}`,
          result,
          duration,
          error
        });
        logger.debug(`\u{1F4CA} Auth Metric: OIDC ${step} ${result}`, {
          duration: `${duration}ms`,
          error
        });
      }
      /**
       * Record session error
       */
      recordSessionError(type, error, userId) {
        this.sessionErrors[type]++;
        this.addMetric({
          timestamp: Date.now(),
          operation: `session_error_${type}`,
          result: "failure",
          error,
          userId
        });
        logger.warn(`\u{1F4CA} Auth Metric: Session error (${type})`, {
          type,
          error,
          userId,
          totalErrors: this.sessionErrors[type]
        });
      }
      /**
       * Record active session
       */
      addActiveSession(sessionId) {
        this.activeSessions.add(sessionId);
      }
      /**
       * Remove active session
       */
      removeActiveSession(sessionId) {
        this.activeSessions.delete(sessionId);
      }
      /**
       * Record user upsert operation
       */
      recordUserUpsert(result, duration, userId, error) {
        this.addMetric({
          timestamp: Date.now(),
          operation: "user_upsert",
          result,
          duration,
          userId,
          error
        });
        logger.debug(`\u{1F4CA} Auth Metric: User upsert ${result}`, {
          duration: `${duration}ms`,
          userId
        });
      }
      /**
       * Record user serialization
       */
      recordSerialization(result, userId, error) {
        this.addMetric({
          timestamp: Date.now(),
          operation: "serialize",
          result,
          userId,
          error
        });
        if (result === "failure") {
          logger.error(`\u{1F4CA} Auth Metric: Serialization failed`, { userId, error });
        }
      }
      /**
       * Record user deserialization
       */
      recordDeserialization(result, userId, error) {
        this.addMetric({
          timestamp: Date.now(),
          operation: "deserialize",
          result,
          userId,
          error
        });
        if (result === "failure") {
          logger.warn(`\u{1F4CA} Auth Metric: Deserialization failed`, { userId, error });
        }
      }
      /**
       * Add metric to collection
       */
      addMetric(metric) {
        this.metrics.push(metric);
        if (this.metrics.length > this.maxMetrics) {
          const cutoff = Date.now() - this.metricsWindow;
          this.metrics = this.metrics.filter((m) => m.timestamp > cutoff);
        }
      }
      /**
       * Get metrics summary for monitoring
       */
      getMetrics() {
        const now = Date.now();
        const recentMetrics = this.metrics.filter((m) => now - m.timestamp < this.metricsWindow);
        const loginSuccessRate = this.loginAttempts.success + this.loginAttempts.failure > 0 ? this.loginAttempts.success / (this.loginAttempts.success + this.loginAttempts.failure) * 100 : 100;
        const loginDurations = recentMetrics.filter((m) => m.operation === "login" && m.duration).map((m) => m.duration);
        const avgLoginDuration = loginDurations.length > 0 ? loginDurations.reduce((a, b) => a + b, 0) / loginDurations.length : 0;
        const recentErrors = recentMetrics.filter((m) => m.result === "failure").slice(-10).map((m) => ({
          operation: m.operation,
          error: m.error,
          timestamp: new Date(m.timestamp).toISOString(),
          userId: m.userId
        }));
        return {
          overview: {
            activeSessions: this.activeSessions.size,
            loginSuccessRate: loginSuccessRate.toFixed(2) + "%",
            avgLoginDuration: avgLoginDuration.toFixed(0) + "ms",
            totalMetrics: recentMetrics.length
          },
          counters: {
            loginAttempts: this.loginAttempts,
            sessionErrors: this.sessionErrors,
            oidcOperations: this.oidcOperations
          },
          recentErrors,
          health: {
            status: loginSuccessRate >= 95 ? "healthy" : loginSuccessRate >= 80 ? "degraded" : "unhealthy",
            issues: [
              this.sessionErrors.store > 10 && "High session store errors",
              this.sessionErrors.deserialize > 20 && "High deserialization errors",
              loginSuccessRate < 80 && "Low login success rate"
            ].filter(Boolean)
          }
        };
      }
      /**
       * Get Prometheus-style metrics
       */
      getPrometheusMetrics() {
        const metrics = this.getMetrics();
        const lines = [];
        lines.push("# HELP auth_login_attempts_total Total number of login attempts");
        lines.push("# TYPE auth_login_attempts_total counter");
        lines.push(`auth_login_attempts_total{result="success"} ${this.loginAttempts.success}`);
        lines.push(`auth_login_attempts_total{result="failure"} ${this.loginAttempts.failure}`);
        lines.push("# HELP auth_session_errors_total Total number of session errors");
        lines.push("# TYPE auth_session_errors_total counter");
        lines.push(`auth_session_errors_total{type="deserialize"} ${this.sessionErrors.deserialize}`);
        lines.push(`auth_session_errors_total{type="store"} ${this.sessionErrors.store}`);
        lines.push(`auth_session_errors_total{type="expired"} ${this.sessionErrors.expired}`);
        lines.push("# HELP auth_oidc_operations_total Total number of OIDC operations");
        lines.push("# TYPE auth_oidc_operations_total counter");
        lines.push(`auth_oidc_operations_total{step="discovery"} ${this.oidcOperations.discovery}`);
        lines.push(`auth_oidc_operations_total{step="token"} ${this.oidcOperations.token}`);
        lines.push(`auth_oidc_operations_total{step="userinfo"} ${this.oidcOperations.userinfo}`);
        lines.push("# HELP auth_active_sessions_gauge Number of active sessions");
        lines.push("# TYPE auth_active_sessions_gauge gauge");
        lines.push(`auth_active_sessions_gauge ${this.activeSessions.size}`);
        return lines.join("\n");
      }
      /**
       * Reset all metrics (for testing)
       */
      reset() {
        this.metrics = [];
        this.loginAttempts = { success: 0, failure: 0 };
        this.sessionErrors = { deserialize: 0, store: 0, expired: 0 };
        this.oidcOperations = { discovery: 0, token: 0, userinfo: 0 };
        this.activeSessions.clear();
        logger.info("\u{1F4CA} Auth metrics reset");
      }
    };
    authMetrics = new AuthMetricsCollector();
  }
});

// server/auth/index.ts
var auth_exports = {};
__export(auth_exports, {
  getOidcCircuitBreakerStatus: () => getOidcCircuitBreakerStatus,
  getRegisteredStrategies: () => getRegisteredStrategies,
  initializeAuth: () => initializeAuth,
  isAuthenticated: () => isAuthenticated
});
import * as client from "openid-client";
import { Strategy } from "openid-client/passport";
import passport from "passport";
async function getOidcConfig(config2) {
  logger.info("\u{1F527} Fetching OIDC configuration...");
  logger.info(`   - Issuer: ${config2.issuerUrl}`);
  logger.info(`   - Client ID (from config.replId): ${config2.replId}`);
  logger.info(`   - Client ID (from process.env.REPL_ID): ${process.env.REPL_ID}`);
  const start = Date.now();
  try {
    const oidcConfig = await oidcCircuitBreaker.execute(async () => {
      return await retryExternalApi(
        "Replit OIDC Discovery",
        async () => {
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("OIDC discovery timeout (10s)")), 1e4);
          });
          const discoveryPromise = client.discovery(
            new URL(config2.issuerUrl),
            config2.replId
          );
          return await Promise.race([discoveryPromise, timeoutPromise]);
        }
      );
    });
    const duration = Date.now() - start;
    authMetrics.recordOidcOperation("discovery", "success", duration);
    logger.info("\u2705 OIDC configuration retrieved successfully");
    logger.info("   - OIDC Config Details:", {
      issuer: oidcConfig[client.customFetch] ? "has custom fetch" : "no custom fetch",
      clientId: config2.replId
    });
    return oidcConfig;
  } catch (error) {
    const duration = Date.now() - start;
    authMetrics.recordOidcOperation("discovery", "failure", duration, error.message);
    captureAuthError(error, {
      operation: "OIDC Discovery",
      additionalData: {
        issuer: config2.issuerUrl,
        clientId: config2.replId,
        duration
      }
    });
    logger.error("\u274C OIDC configuration failed after all retries:", {
      message: error.message,
      issuer: config2.issuerUrl,
      clientId: config2.replId
    });
    throw new Error(`Failed to fetch OIDC configuration: ${error.message}`);
  }
}
function updateUserSession(user, tokens) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}
async function upsertUser(claims) {
  logger.info(`\u{1F510} Upserting user:`, {
    email: claims["email"],
    replitId: claims["sub"],
    allClaims: JSON.stringify(claims)
  });
  const start = Date.now();
  try {
    const userData = {
      id: claims["sub"],
      email: claims["email"],
      firstName: claims["first_name"],
      lastName: claims["last_name"],
      profileImageUrl: claims["profile_image_url"] || claims["profile_image"]
    };
    logger.info(`\u{1F4DD} User data to upsert:`, userData);
    const result = await retryDatabaseOperation(
      `upsert user ${userData.email}`,
      async () => {
        return await storage.upsertUser(userData);
      }
    );
    const duration = Date.now() - start;
    authMetrics.recordUserUpsert("success", duration, result.user.id);
    trackAuthSuccess("User Upsert", result.user.id, duration, { isNewUser: result.isNewUser });
    logger.info(`\u2705 User upserted successfully:`, {
      id: result.user.id,
      email: result.user.email,
      isNewUser: result.isNewUser
    });
    return result;
  } catch (error) {
    const duration = Date.now() - start;
    authMetrics.recordUserUpsert("failure", duration, void 0, error.message);
    captureAuthError(error, {
      operation: "User Upsert",
      userId: claims["sub"],
      additionalData: {
        email: claims["email"],
        duration
      }
    });
    logger.error("\u274C User upsert failed after all retries:", {
      message: error.message,
      stack: error.stack,
      email: claims["email"],
      userData: JSON.stringify({
        id: claims["sub"],
        email: claims["email"],
        firstName: claims["first_name"],
        lastName: claims["last_name"]
      })
    });
    throw new Error(`Failed to create/update user: ${error.message}`);
  }
}
async function registerStrategy(domain, config2, oidcConfig) {
  const strategyName = `replitauth:${domain}`;
  if (registeredStrategies.has(strategyName)) {
    logger.debug(`   - Strategy ${strategyName} already registered, skipping`);
    return;
  }
  logger.info(`   - Registering strategy: ${strategyName}`);
  try {
    let callbackURL;
    if (domain === "localhost" || domain === "127.0.0.1") {
      callbackURL = `http://${domain}:${config2.port}/api/auth/callback`;
    } else {
      callbackURL = `https://${domain}/api/auth/callback`;
    }
    logger.info(`   - Strategy config: callbackURL=${callbackURL}, scope="openid email profile"`);
    logger.info(`   - Using REPL_ID as client: ${config2.replId}`);
    const strategy = new Strategy(
      {
        config: oidcConfig,
        callbackURL,
        scope: "openid email profile"
      },
      async (tokens, done) => {
        try {
          logger.info("\u{1F510} Strategy verify callback started:", {
            hasClaims: !!tokens.claims(),
            domain
          });
          const claims = tokens.claims();
          logger.info("\u{1F4CB} OAuth claims received:", {
            sub: claims.sub,
            email: claims.email,
            first_name: claims.first_name,
            last_name: claims.last_name,
            allClaimKeys: Object.keys(claims)
          });
          const result = await upsertUser(claims);
          const user = result.user;
          const isNewUser = result.isNewUser;
          updateUserSession(user, tokens);
          logger.info("\u2705 Strategy verify callback successful, calling done(null, user)", {
            userId: user.id,
            isNewUser
          });
          done(null, user, { isNewUser });
        } catch (error) {
          logger.error("\u274C Strategy verify error:", {
            message: error.message,
            stack: error.stack,
            domain
          });
          done(error);
        }
      }
    );
    passport.use(strategyName, strategy);
    registeredStrategies.add(strategyName);
    logger.info(`\u2705 Strategy registered: ${strategyName} with callback ${callbackURL}`);
  } catch (error) {
    logger.error(`\u274C Failed to register strategy ${strategyName}:`, {
      message: error.message
    });
    throw error;
  }
}
async function initializeAuth(config2) {
  logger.info("\u{1F510} Initializing authentication system...");
  try {
    const oidcConfig = await getOidcConfig(config2);
    logger.info(`\u{1F527} Registering Passport strategies for ${config2.replitDomains.length} domain(s)...`);
    for (const domain of config2.replitDomains) {
      await registerStrategy(domain, config2, oidcConfig);
    }
    logger.info("\u{1F527} Configuring Passport serialization...");
    passport.serializeUser((user, done) => {
      const userId = user?.user?.id || user?.id;
      if (!userId) {
        authMetrics.recordSerialization("failure", void 0, "No user ID found");
        logger.error("\u274C Cannot serialize user - no ID found!", {
          userType: typeof user,
          userKeys: user ? Object.keys(user) : "null",
          user: JSON.stringify(user)
        });
        return done(new Error("User ID is required for serialization"));
      }
      authMetrics.recordSerialization("success", userId);
      logger.info("\u2705 Serializing user for session:", {
        userId,
        email: user?.email || user?.user?.email,
        hasId: !!userId
      });
      done(null, userId);
    });
    passport.deserializeUser(async (id, done) => {
      try {
        logger.debug("\u{1F513} Deserializing user:", { id });
        let user = await retryDatabaseOperation(
          `deserialize user ${id}`,
          async () => await storage.getUser(id)
        ).catch((error) => {
          logger.warn("\u26A0\uFE0F  Failed to deserialize user by ID, will try fallback", {
            id,
            error: error.message
          });
          authMetrics.recordSessionError("deserialize", error.message, id);
          return null;
        });
        if (user) {
          authMetrics.recordDeserialization("success", user.id);
          logger.debug("\u2705 User deserialized successfully by ID");
          return done(null, user);
        }
        if (id.includes("@")) {
          logger.info("\u{1F504} ID looks like email, attempting email lookup", { possibleEmail: id });
          user = await retryDatabaseOperation(
            `deserialize user by email ${id}`,
            async () => await storage.getUserByEmail(id)
          ).catch(() => null);
          if (user) {
            authMetrics.recordDeserialization("success", user.id);
            logger.info("\u2705 User recovered via email lookup");
            return done(null, user);
          }
        }
        authMetrics.recordDeserialization("failure", id, "User not found");
        logger.warn("\u26A0\uFE0F  User not found after all deserialization attempts", {
          id,
          attempts: ["by ID", "by email (if applicable)"]
        });
        return done(null, false);
      } catch (error) {
        authMetrics.recordDeserialization("failure", id, error.message);
        logger.error("\u274C Critical deserialization error:", {
          message: error.message,
          id,
          stack: error.stack
        });
        return done(null, false);
      }
    });
    logger.info("\u2705 Authentication system initialized successfully");
    logger.info(`   - Registered strategies: ${Array.from(registeredStrategies).join(", ")}`);
  } catch (error) {
    logger.error("\u274C Authentication initialization failed:", {
      message: error.message,
      stack: error.stack
    });
    throw error;
  }
}
function isAuthenticated(req, res, next) {
  if (req.isAuthenticated()) {
    return next();
  }
  logger.debug("\u{1F513} Unauthenticated request blocked");
  res.status(401).json({ error: "Authentication required" });
}
function getRegisteredStrategies() {
  return new Set(registeredStrategies);
}
function getOidcCircuitBreakerStatus() {
  return oidcCircuitBreaker.getMetrics();
}
var registeredStrategies, oidcCircuitBreaker;
var init_auth = __esm({
  "server/auth/index.ts"() {
    "use strict";
    init_storage();
    init_monitoring();
    init_retry();
    init_circuitBreaker();
    init_authMetrics();
    init_authSentry();
    registeredStrategies = /* @__PURE__ */ new Set();
    oidcCircuitBreaker = new CircuitBreaker({
      failureThreshold: 5,
      successThreshold: 2,
      timeout: 3e5,
      // 5 minutes
      name: "OIDC Discovery",
      onStateChange: (oldState, newState) => {
        captureCircuitBreakerEvent("OIDC Discovery", oldState, newState, oidcCircuitBreaker.getMetrics());
        if (newState === "OPEN" /* OPEN */) {
          logger.error("\u{1F6A8} CRITICAL ALERT: OIDC circuit breaker is OPEN - authentication may be degraded!");
        } else if (newState === "CLOSED" /* CLOSED */ && oldState === "HALF_OPEN" /* HALF_OPEN */) {
          logger.info("\u2705 OIDC circuit breaker recovered - authentication fully operational");
        }
      }
    });
  }
});

// server/rateLimiter.ts
import rateLimit from "express-rate-limit";
import RedisStore from "rate-limit-redis";
function rateLimiter(options) {
  const store = redis.status === "ready" ? new RedisStore({
    client: redis,
    prefix: `rl:${options.keyPrefix || "default"}:`
  }) : void 0;
  return rateLimit({
    windowMs: options.windowMs,
    max: options.max,
    message: options.message || "Too many requests, please try again later.",
    standardHeaders: true,
    legacyHeaders: false,
    store,
    keyGenerator: options.keyGenerator || ((req) => {
      return req.user?.claims?.sub || req.ip || "anonymous";
    }),
    skipFailedRequests: false,
    skipSuccessfulRequests: options.skipSuccessfulRequests || false,
    // Disable IPv6 validation since we're using user IDs primarily
    validate: false
  });
}
var generalApiRateLimit, authRateLimit, businessActionRateLimit, votingRateLimit, adminActionRateLimit, searchRateLimit, uploadRateLimit, checkoutRateLimit;
var init_rateLimiter = __esm({
  "server/rateLimiter.ts"() {
    "use strict";
    init_redis();
    generalApiRateLimit = rateLimiter({
      windowMs: 15 * 60 * 1e3,
      max: 100,
      keyPrefix: "general"
    });
    authRateLimit = rateLimiter({
      windowMs: 15 * 60 * 1e3,
      max: 5,
      keyPrefix: "auth",
      message: "Too many authentication attempts, please try again later."
    });
    businessActionRateLimit = rateLimiter({
      windowMs: 60 * 60 * 1e3,
      max: 50,
      keyPrefix: "business",
      skipSuccessfulRequests: true
    });
    votingRateLimit = rateLimiter({
      windowMs: 24 * 60 * 60 * 1e3,
      max: 10,
      keyPrefix: "voting",
      message: "You have reached your daily voting limit."
    });
    adminActionRateLimit = rateLimiter({
      windowMs: 60 * 60 * 1e3,
      max: 200,
      keyPrefix: "admin"
    });
    searchRateLimit = rateLimiter({
      windowMs: 60 * 1e3,
      max: 30,
      keyPrefix: "search"
    });
    uploadRateLimit = rateLimiter({
      windowMs: 60 * 60 * 1e3,
      max: 10,
      keyPrefix: "upload",
      message: "Upload limit reached. Please try again later."
    });
    checkoutRateLimit = rateLimiter({
      windowMs: 60 * 60 * 1e3,
      max: 5,
      keyPrefix: "checkout",
      message: "Too many checkout attempts. Please try again later."
    });
  }
});

// server/adminAuth.ts
var isAdmin, adminRateLimit;
var init_adminAuth = __esm({
  "server/adminAuth.ts"() {
    "use strict";
    init_storage();
    init_rateLimiter();
    isAdmin = async (req, res, next) => {
      try {
        const user = req.user;
        if (!user) {
          return res.status(401).json({ message: "Not authenticated" });
        }
        const isUserAdmin = await storage.isUserAdmin(user.id);
        if (!isUserAdmin) {
          return res.status(403).json({ message: "Admin access required" });
        }
        next();
      } catch (error) {
        console.error("Admin auth error:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    };
    adminRateLimit = rateLimiter({
      windowMs: 15 * 60 * 1e3,
      // 15 minutes
      max: 100,
      // Limit each IP to 100 requests per windowMs
      keyPrefix: "admin",
      message: "Too many admin requests, please try again later"
    });
  }
});

// server/rateLimit.ts
var generalAPIRateLimit, strictRateLimit, businessActionRateLimit2, publicEndpointRateLimit, votingRateLimit2;
var init_rateLimit = __esm({
  "server/rateLimit.ts"() {
    "use strict";
    init_rateLimiter();
    generalAPIRateLimit = rateLimiter({
      windowMs: 15 * 60 * 1e3,
      max: 100,
      keyGenerator: (req) => {
        const user = req.user;
        return user?.id || req.ip || "anonymous";
      }
    });
    strictRateLimit = rateLimiter({
      windowMs: 15 * 60 * 1e3,
      max: 10,
      keyGenerator: (req) => {
        const user = req.user;
        return user?.id || req.ip || "anonymous";
      }
    });
    businessActionRateLimit2 = rateLimiter({
      windowMs: 15 * 60 * 1e3,
      max: 30,
      keyGenerator: (req) => {
        const user = req.user;
        return user?.id || req.ip || "anonymous";
      }
    });
    publicEndpointRateLimit = rateLimiter({
      windowMs: 15 * 60 * 1e3,
      max: 200,
      keyGenerator: (req) => req.ip || "anonymous"
    });
    votingRateLimit2 = rateLimiter({
      windowMs: 60 * 60 * 1e3,
      max: 5,
      keyGenerator: (req) => {
        const user = req.user;
        return user?.id || req.ip || "anonymous";
      },
      message: "You can only vote 5 times per hour"
    });
  }
});

// server/objectAcl.ts
function isPermissionAllowed(requested, granted) {
  if (requested === "read" /* READ */) {
    return ["read" /* READ */, "write" /* WRITE */].includes(granted);
  }
  return granted === "write" /* WRITE */;
}
function createObjectAccessGroup(group) {
  switch (group.type) {
    // Implement the case for each type of access group to instantiate.
    //
    // For example:
    // case "USER_LIST":
    //   return new UserListAccessGroup(group.id);
    // case "EMAIL_DOMAIN":
    //   return new EmailDomainAccessGroup(group.id);
    // case "GROUP_MEMBER":
    //   return new GroupMemberAccessGroup(group.id);
    // case "SUBSCRIBER":
    //   return new SubscriberAccessGroup(group.id);
    default:
      throw new Error(`Unknown access group type: ${group.type}`);
  }
}
async function setObjectAclPolicy(objectFile, aclPolicy) {
  const [exists] = await objectFile.exists();
  if (!exists) {
    throw new Error(`Object not found: ${objectFile.name}`);
  }
  await objectFile.setMetadata({
    metadata: {
      [ACL_POLICY_METADATA_KEY]: JSON.stringify(aclPolicy)
    }
  });
}
async function getObjectAclPolicy(objectFile) {
  const [metadata] = await objectFile.getMetadata();
  const aclPolicy = metadata?.metadata?.[ACL_POLICY_METADATA_KEY];
  if (!aclPolicy) {
    return null;
  }
  return JSON.parse(aclPolicy);
}
async function canAccessObject({
  userId,
  objectFile,
  requestedPermission
}) {
  const aclPolicy = await getObjectAclPolicy(objectFile);
  if (!aclPolicy) {
    return false;
  }
  if (aclPolicy.visibility === "public" && requestedPermission === "read" /* READ */) {
    return true;
  }
  if (!userId) {
    return false;
  }
  if (aclPolicy.owner === userId) {
    return true;
  }
  for (const rule of aclPolicy.aclRules || []) {
    const accessGroup = createObjectAccessGroup(rule.group);
    if (await accessGroup.hasMember(userId) && isPermissionAllowed(requestedPermission, rule.permission)) {
      return true;
    }
  }
  return false;
}
var ACL_POLICY_METADATA_KEY;
var init_objectAcl = __esm({
  "server/objectAcl.ts"() {
    "use strict";
    ACL_POLICY_METADATA_KEY = "custom:aclPolicy";
  }
});

// server/objectStorage.ts
import { randomUUID } from "crypto";
function parseObjectPath(path6) {
  if (!path6.startsWith("/")) {
    path6 = `/${path6}`;
  }
  const pathParts = path6.split("/");
  if (pathParts.length < 3) {
    throw new Error("Invalid path: must contain at least a bucket name");
  }
  const bucketName = pathParts[1];
  const objectName = pathParts.slice(2).join("/");
  return {
    bucketName,
    objectName
  };
}
async function signObjectURL({
  bucketName,
  objectName,
  method,
  ttlSec
}) {
  const request = {
    bucket_name: bucketName,
    object_name: objectName,
    method,
    expires_at: new Date(Date.now() + ttlSec * 1e3).toISOString()
  };
  const response = await fetch(
    `${REPLIT_SIDECAR_ENDPOINT}/object-storage/signed-object-url`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(request)
    }
  );
  if (!response.ok) {
    throw new Error(
      `Failed to sign object URL, errorcode: ${response.status}, make sure you're running on Replit`
    );
  }
  const { signed_url: signedURL } = await response.json();
  return signedURL;
}
var REPLIT_SIDECAR_ENDPOINT, SimpleFile, SimpleBucket, objectStorageClient, ObjectNotFoundError, ObjectStorageService;
var init_objectStorage = __esm({
  "server/objectStorage.ts"() {
    "use strict";
    init_objectAcl();
    REPLIT_SIDECAR_ENDPOINT = "http://127.0.0.1:1106";
    SimpleFile = class {
      constructor(name, bucket, fullPath) {
        this.name = name;
        this.bucket = bucket;
        this.fullPath = fullPath;
      }
      async exists() {
        try {
          const response = await fetch(
            `${REPLIT_SIDECAR_ENDPOINT}/object-storage/object-exists`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ object_path: this.fullPath })
            }
          );
          const result = await response.json();
          return [result.exists || false];
        } catch {
          return [false];
        }
      }
      async getMetadata() {
        try {
          const response = await fetch(
            `${REPLIT_SIDECAR_ENDPOINT}/object-storage/object-metadata`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ object_path: this.fullPath })
            }
          );
          if (response.ok) {
            const result = await response.json();
            return [{
              metadata: result.metadata || {},
              contentType: result.content_type || this.inferContentType(),
              size: result.size?.toString() || "0"
            }];
          }
        } catch (error) {
          console.error("Error getting metadata:", error);
        }
        return [{
          metadata: {},
          contentType: this.inferContentType(),
          size: "0"
        }];
      }
      inferContentType() {
        const ext = this.name.toLowerCase().split(".").pop();
        switch (ext) {
          case "jpg":
          case "jpeg":
            return "image/jpeg";
          case "png":
            return "image/png";
          case "gif":
            return "image/gif";
          case "webp":
            return "image/webp";
          case "svg":
            return "image/svg+xml";
          default:
            return "application/octet-stream";
        }
      }
      async setMetadata(metadata) {
        try {
          const response = await fetch(
            `${REPLIT_SIDECAR_ENDPOINT}/object-storage/set-object-metadata`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                object_path: this.fullPath,
                metadata: metadata.metadata
              })
            }
          );
          if (!response.ok) {
            throw new Error(`Failed to set metadata: ${response.status}`);
          }
        } catch (error) {
          console.error("Error setting metadata:", error);
          throw error;
        }
      }
      createReadStream() {
        const { Readable } = __require("stream");
        const objectPath = this.fullPath;
        let started = false;
        const stream = new Readable({
          async read() {
            if (started) {
              return;
            }
            started = true;
            try {
              const response = await fetch(
                `${REPLIT_SIDECAR_ENDPOINT}/object-storage/download-object`,
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ object_path: objectPath })
                  // Use captured objectPath
                }
              );
              if (response.ok && response.body) {
                const reader = response.body.getReader();
                const pump = async () => {
                  try {
                    const { value, done } = await reader.read();
                    if (done) {
                      this.push(null);
                    } else {
                      this.push(Buffer.from(value));
                      setImmediate(() => pump());
                    }
                  } catch (error) {
                    this.emit("error", error);
                  }
                };
                pump();
              } else {
                const errorText = await response.text();
                this.emit("error", new Error(`Failed to download object: ${response.status} - ${errorText}`));
              }
            } catch (error) {
              this.emit("error", error);
            }
          }
        });
        return stream;
      }
    };
    SimpleBucket = class {
      constructor(name) {
        this.name = name;
      }
      file(objectName) {
        const fullPath = `/${this.name}/${objectName}`;
        return new SimpleFile(objectName, { name: this.name }, fullPath);
      }
    };
    objectStorageClient = {
      bucket(bucketName) {
        return new SimpleBucket(bucketName);
      }
    };
    ObjectNotFoundError = class _ObjectNotFoundError extends Error {
      constructor() {
        super("Object not found");
        this.name = "ObjectNotFoundError";
        Object.setPrototypeOf(this, _ObjectNotFoundError.prototype);
      }
    };
    ObjectStorageService = class {
      constructor() {
      }
      // Gets the public object search paths.
      getPublicObjectSearchPaths() {
        const pathsStr = process.env.PUBLIC_OBJECT_SEARCH_PATHS || "";
        const paths = Array.from(
          new Set(
            pathsStr.split(",").map((path6) => path6.trim()).filter((path6) => path6.length > 0)
          )
        );
        if (paths.length === 0) {
          throw new Error(
            "PUBLIC_OBJECT_SEARCH_PATHS not set. Create a bucket in 'Object Storage' tool and set PUBLIC_OBJECT_SEARCH_PATHS env var (comma-separated paths)."
          );
        }
        return paths;
      }
      // Gets the private object directory.
      getPrivateObjectDir() {
        const dir = process.env.PRIVATE_OBJECT_DIR || "";
        if (!dir) {
          throw new Error(
            "PRIVATE_OBJECT_DIR not set. Create a bucket in 'Object Storage' tool and set PRIVATE_OBJECT_DIR env var."
          );
        }
        return dir;
      }
      // Search for a public object from the search paths.
      async searchPublicObject(filePath) {
        for (const searchPath of this.getPublicObjectSearchPaths()) {
          const fullPath = `${searchPath}/${filePath}`;
          const { bucketName, objectName } = parseObjectPath(fullPath);
          const bucket = objectStorageClient.bucket(bucketName);
          const file = bucket.file(objectName);
          const [exists] = await file.exists();
          if (exists) {
            return file;
          }
        }
        return null;
      }
      // Downloads an object to the response.
      async downloadObject(file, res, cacheTtlSec = 3600) {
        try {
          const [metadata] = await file.getMetadata();
          const aclPolicy = await getObjectAclPolicy(file);
          const isPublic = aclPolicy?.visibility === "public";
          res.set({
            "Content-Type": metadata.contentType || "application/octet-stream",
            "Content-Length": metadata.size,
            "Cache-Control": `${isPublic ? "public" : "private"}, max-age=${cacheTtlSec}`
          });
          const stream = file.createReadStream();
          stream.on("error", (err) => {
            console.error("Stream error:", err);
            if (!res.headersSent) {
              res.status(500).json({ error: "Error streaming file" });
            }
          });
          stream.pipe(res);
        } catch (error) {
          console.error("Error downloading file:", error);
          if (!res.headersSent) {
            res.status(500).json({ error: "Error downloading file" });
          }
        }
      }
      // Gets the upload URL for an object entity with safe key generation.
      async getObjectEntityUploadURL() {
        const privateObjectDir = this.getPrivateObjectDir();
        if (!privateObjectDir) {
          throw new Error(
            "PRIVATE_OBJECT_DIR not set. Create a bucket in 'Object Storage' tool and set PRIVATE_OBJECT_DIR env var."
          );
        }
        const objectId = this.generateSafeObjectKey();
        const fullPath = `${privateObjectDir}/uploads/${objectId}`;
        const { bucketName, objectName } = parseObjectPath(fullPath);
        return signObjectURL({
          bucketName,
          objectName,
          method: "PUT",
          ttlSec: 900
        });
      }
      // Gets the upload URL for a product image in the public directory
      async getProductImageUploadURL(businessId, productId, filename) {
        const publicObjectSearchPaths = this.getPublicObjectSearchPaths();
        if (!publicObjectSearchPaths || publicObjectSearchPaths.length === 0) {
          throw new Error(
            "PUBLIC_OBJECT_SEARCH_PATHS not set. Create a bucket in 'Object Storage' tool and set PUBLIC_OBJECT_SEARCH_PATHS env var."
          );
        }
        const publicPath = publicObjectSearchPaths[0];
        const objectId = this.generateSafeObjectKey();
        const sanitizedFilename = filename.replace(/[^a-zA-Z0-9.\-]/g, "-");
        const objectKey = `products/${businessId}/${productId}/${objectId}-${sanitizedFilename}`;
        const fullPath = `${publicPath}/${objectKey}`;
        const { bucketName, objectName } = parseObjectPath(fullPath);
        const uploadUrl = await signObjectURL({
          bucketName,
          objectName,
          method: "PUT",
          ttlSec: 300
        });
        return {
          uploadUrl,
          publicPath: `/public-objects/${objectKey}`
        };
      }
      // Gets the object entity file from the object path.
      async getObjectEntityFile(objectPath) {
        if (!objectPath.startsWith("/objects/")) {
          throw new ObjectNotFoundError();
        }
        const parts = objectPath.slice(1).split("/");
        if (parts.length < 2) {
          throw new ObjectNotFoundError();
        }
        const entityId = parts.slice(1).join("/");
        let entityDir = this.getPrivateObjectDir();
        if (!entityDir.endsWith("/")) {
          entityDir = `${entityDir}/`;
        }
        const objectEntityPath = `${entityDir}${entityId}`;
        const { bucketName, objectName } = parseObjectPath(objectEntityPath);
        const bucket = objectStorageClient.bucket(bucketName);
        const objectFile = bucket.file(objectName);
        const [exists] = await objectFile.exists();
        if (!exists) {
          throw new ObjectNotFoundError();
        }
        return objectFile;
      }
      normalizeObjectEntityPath(rawPath) {
        if (!rawPath.startsWith("https://storage.googleapis.com/")) {
          return rawPath;
        }
        const url = new URL(rawPath);
        const rawObjectPath = url.pathname;
        let objectEntityDir = this.getPrivateObjectDir();
        if (!objectEntityDir.endsWith("/")) {
          objectEntityDir = `${objectEntityDir}/`;
        }
        if (!rawObjectPath.startsWith(objectEntityDir)) {
          return rawObjectPath;
        }
        const entityId = rawObjectPath.slice(objectEntityDir.length);
        return `/objects/${entityId}`;
      }
      // Tries to set the ACL policy for the object entity and return the normalized path.
      async trySetObjectEntityAclPolicy(rawPath, aclPolicy) {
        const normalizedPath = this.normalizeObjectEntityPath(rawPath);
        if (!normalizedPath.startsWith("/")) {
          return normalizedPath;
        }
        const objectFile = await this.getObjectEntityFile(normalizedPath);
        await setObjectAclPolicy(objectFile, aclPolicy);
        return normalizedPath;
      }
      // Checks if the user can access the object entity.
      async canAccessObjectEntity({
        userId,
        objectFile,
        requestedPermission
      }) {
        return canAccessObject({
          userId,
          objectFile,
          requestedPermission: requestedPermission ?? "read" /* READ */
        });
      }
      // Extract object ID from object path for public URL generation
      extractObjectIdFromPath(objectPath) {
        const parts = objectPath.split("/");
        if (parts.length >= 4 && parts[1] === "objects" && parts[2] === "uploads") {
          return parts[3];
        }
        return parts[parts.length - 1] || "unknown";
      }
      // Generate sanitized object key for uploads
      generateSafeObjectKey() {
        const objectId = randomUUID();
        return objectId.replace(/[^a-zA-Z0-9\-]/g, "-");
      }
    };
  }
});

// server/apiResponse.ts
var ApiResponse, asyncHandler;
var init_apiResponse = __esm({
  "server/apiResponse.ts"() {
    "use strict";
    ApiResponse = class {
      /**
       * Send a successful response
       */
      static success(res, data = null, message = "Success") {
        return res.json({
          success: true,
          message,
          data
        });
      }
      /**
       * Send a generic error response
       */
      static error(res, statusCode, code, message, details) {
        return res.status(statusCode).json({
          success: false,
          error: {
            code,
            message,
            ...details && { details }
          }
        });
      }
      /**
       * 400 Bad Request - Validation Error
       */
      static badRequest(res, message = "Bad Request", details) {
        return this.error(res, 400, "BAD_REQUEST", message, details);
      }
      /**
       * 400 Bad Request - Zod Validation Error
       */
      static zodValidation(res, error, req) {
        const details = error.errors.map((err) => ({
          field: err.path.join("."),
          message: err.message,
          code: err.code
        }));
        return this.error(res, 400, "VALIDATION_ERROR", "Validation failed", details);
      }
      /**
       * 401 Unauthorized
       */
      static unauthorized(res, message = "Unauthorized") {
        return this.error(res, 401, "UNAUTHORIZED", message);
      }
      /**
       * 403 Forbidden
       */
      static forbidden(res, message = "Forbidden") {
        return this.error(res, 403, "FORBIDDEN", message);
      }
      /**
       * 404 Not Found
       */
      static notFound(res, message = "Resource not found") {
        return this.error(res, 404, "NOT_FOUND", message);
      }
      /**
       * 409 Conflict
       */
      static conflict(res, message = "Conflict") {
        return this.error(res, 409, "CONFLICT", message);
      }
      /**
       * 429 Too Many Requests
       */
      static tooManyRequests(res, message = "Too many requests, please try again later") {
        return this.error(res, 429, "RATE_LIMIT_EXCEEDED", message);
      }
      /**
       * 500 Internal Server Error
       */
      static internalError(res, message = "Internal server error", details) {
        const isProd = process.env.NODE_ENV === "production";
        return this.error(
          res,
          500,
          "INTERNAL_ERROR",
          message,
          isProd ? void 0 : details
        );
      }
      /**
       * 502 Bad Gateway
       */
      static badGateway(res, message = "Bad gateway") {
        return this.error(res, 502, "BAD_GATEWAY", message);
      }
      /**
       * 503 Service Unavailable
       */
      static serviceUnavailable(res, message = "Service temporarily unavailable") {
        return this.error(res, 503, "SERVICE_UNAVAILABLE", message);
      }
    };
    asyncHandler = (fn) => {
      return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
      };
    };
  }
});

// server/gmbErrorHandler.ts
var gmbErrorHandler_exports = {};
__export(gmbErrorHandler_exports, {
  GMBErrorHandler: () => GMBErrorHandler,
  GMBErrorType: () => GMBErrorType,
  gmbErrorHandler: () => gmbErrorHandler
});
var GMBErrorType, GMBErrorHandler, gmbErrorHandler;
var init_gmbErrorHandler = __esm({
  "server/gmbErrorHandler.ts"() {
    "use strict";
    init_storage();
    GMBErrorType = /* @__PURE__ */ ((GMBErrorType3) => {
      GMBErrorType3["RATE_LIMIT_EXCEEDED"] = "RATE_LIMIT_EXCEEDED";
      GMBErrorType3["QUOTA_EXCEEDED"] = "QUOTA_EXCEEDED";
      GMBErrorType3["INVALID_CREDENTIALS"] = "INVALID_CREDENTIALS";
      GMBErrorType3["TOKEN_EXPIRED"] = "TOKEN_EXPIRED";
      GMBErrorType3["LOCATION_NOT_FOUND"] = "LOCATION_NOT_FOUND";
      GMBErrorType3["PERMISSION_DENIED"] = "PERMISSION_DENIED";
      GMBErrorType3["API_UNAVAILABLE"] = "API_UNAVAILABLE";
      GMBErrorType3["NETWORK_ERROR"] = "NETWORK_ERROR";
      GMBErrorType3["INVALID_REQUEST"] = "INVALID_REQUEST";
      GMBErrorType3["SYNC_CONFLICT"] = "SYNC_CONFLICT";
      GMBErrorType3["DATA_VALIDATION_ERROR"] = "DATA_VALIDATION_ERROR";
      GMBErrorType3["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      return GMBErrorType3;
    })(GMBErrorType || {});
    GMBErrorHandler = class _GMBErrorHandler {
      constructor() {
        this.defaultRetryConfig = {
          maxRetries: 3,
          baseDelay: 1e3,
          maxDelay: 3e4,
          backoffMultiplier: 2,
          jitter: true
        };
        this.circuitBreaker = {
          isOpen: false,
          failures: 0,
          lastFailureTime: 0,
          threshold: 5,
          timeout: 6e4
          // 1 minute
        };
      }
      static getInstance() {
        if (!_GMBErrorHandler.instance) {
          _GMBErrorHandler.instance = new _GMBErrorHandler();
        }
        return _GMBErrorHandler.instance;
      }
      /**
       * Parse and classify GMB API errors
       */
      parseGMBError(error) {
        if (error.response?.data?.error) {
          const gmbError = error.response.data.error;
          return this.classifyError(gmbError.code, gmbError.message, error);
        }
        if (error.response?.status) {
          return this.classifyHttpError(error.response.status, error.response.statusText, error);
        }
        if (error.code === "ECONNABORTED" || error.code === "ENOTFOUND") {
          return {
            type: "NETWORK_ERROR" /* NETWORK_ERROR */,
            message: "Network connection failed",
            retryable: true,
            originalError: error
          };
        }
        return {
          type: "UNKNOWN_ERROR" /* UNKNOWN_ERROR */,
          message: error.message || "Unknown error occurred",
          retryable: false,
          originalError: error
        };
      }
      classifyError(code, message, originalError) {
        switch (code) {
          case 429:
          case "RATE_LIMIT_EXCEEDED":
            return {
              type: "RATE_LIMIT_EXCEEDED" /* RATE_LIMIT_EXCEEDED */,
              message: "Rate limit exceeded. Please try again later.",
              code,
              retryable: true,
              retryAfter: this.extractRetryAfter(originalError),
              originalError
            };
          case 403:
          case "QUOTA_EXCEEDED":
            return {
              type: "QUOTA_EXCEEDED" /* QUOTA_EXCEEDED */,
              message: "API quota exceeded. Please try again tomorrow.",
              code,
              retryable: false,
              originalError
            };
          case 401:
          case "UNAUTHENTICATED":
            return {
              type: "INVALID_CREDENTIALS" /* INVALID_CREDENTIALS */,
              message: "Invalid or expired credentials.",
              code,
              retryable: false,
              originalError
            };
          case "PERMISSION_DENIED":
            return {
              type: "PERMISSION_DENIED" /* PERMISSION_DENIED */,
              message: "Insufficient permissions to access this resource.",
              code,
              retryable: false,
              originalError
            };
          case 404:
          case "NOT_FOUND":
            return {
              type: "LOCATION_NOT_FOUND" /* LOCATION_NOT_FOUND */,
              message: "Business location not found in Google My Business.",
              code,
              retryable: false,
              originalError
            };
          case 503:
          case "UNAVAILABLE":
            return {
              type: "API_UNAVAILABLE" /* API_UNAVAILABLE */,
              message: "Google My Business API is temporarily unavailable.",
              code,
              retryable: true,
              retryAfter: 60,
              originalError
            };
          default:
            return {
              type: "UNKNOWN_ERROR" /* UNKNOWN_ERROR */,
              message: message || "Unknown error occurred",
              code,
              retryable: false,
              originalError
            };
        }
      }
      classifyHttpError(status, statusText, originalError) {
        switch (status) {
          case 429:
            return {
              type: "RATE_LIMIT_EXCEEDED" /* RATE_LIMIT_EXCEEDED */,
              message: "Too many requests. Please slow down.",
              code: status,
              retryable: true,
              retryAfter: this.extractRetryAfter(originalError),
              originalError
            };
          case 401:
            return {
              type: "TOKEN_EXPIRED" /* TOKEN_EXPIRED */,
              message: "Authentication token has expired.",
              code: status,
              retryable: false,
              originalError
            };
          case 403:
            return {
              type: "PERMISSION_DENIED" /* PERMISSION_DENIED */,
              message: "Access forbidden. Check API permissions.",
              code: status,
              retryable: false,
              originalError
            };
          case 404:
            return {
              type: "LOCATION_NOT_FOUND" /* LOCATION_NOT_FOUND */,
              message: "Resource not found.",
              code: status,
              retryable: false,
              originalError
            };
          case 500:
          case 502:
          case 503:
          case 504:
            return {
              type: "API_UNAVAILABLE" /* API_UNAVAILABLE */,
              message: "Google services are temporarily unavailable.",
              code: status,
              retryable: true,
              retryAfter: 30,
              originalError
            };
          default:
            return {
              type: "UNKNOWN_ERROR" /* UNKNOWN_ERROR */,
              message: statusText || "HTTP error occurred",
              code: status,
              retryable: status >= 500,
              originalError
            };
        }
      }
      extractRetryAfter(error) {
        const retryAfterHeader = error.response?.headers?.["retry-after"];
        if (retryAfterHeader) {
          const retryAfter = parseInt(retryAfterHeader, 10);
          return isNaN(retryAfter) ? void 0 : retryAfter;
        }
        return void 0;
      }
      /**
       * Execute function with retry logic and error handling
       */
      async withRetry(operation, config2 = {}, context = {}) {
        const retryConfig = { ...this.defaultRetryConfig, ...config2 };
        if (this.isCircuitBreakerOpen()) {
          throw new Error("Circuit breaker is open. Service temporarily unavailable.");
        }
        let lastError = null;
        for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {
          try {
            const result = await operation();
            this.resetCircuitBreaker();
            await this.logOperation({
              type: "success",
              attempt: attempt + 1,
              context
            });
            return result;
          } catch (error) {
            lastError = this.parseGMBError(error);
            await this.logError(lastError, {
              attempt: attempt + 1,
              maxRetries: retryConfig.maxRetries,
              ...context
            });
            this.recordFailure();
            if (!lastError.retryable || attempt >= retryConfig.maxRetries) {
              break;
            }
            const delay = this.calculateDelay(attempt, retryConfig, lastError.retryAfter);
            await this.sleep(delay);
          }
        }
        throw lastError?.originalError || new Error("Operation failed after retries");
      }
      calculateDelay(attempt, config2, retryAfter) {
        if (retryAfter) {
          return retryAfter * 1e3;
        }
        let delay = config2.baseDelay * Math.pow(config2.backoffMultiplier, attempt);
        if (config2.jitter) {
          delay = delay * (0.5 + Math.random() * 0.5);
        }
        return Math.min(delay, config2.maxDelay);
      }
      sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      /**
       * Circuit breaker implementation
       */
      isCircuitBreakerOpen() {
        if (this.circuitBreaker.isOpen) {
          if (Date.now() - this.circuitBreaker.lastFailureTime > this.circuitBreaker.timeout) {
            this.resetCircuitBreaker();
            return false;
          }
          return true;
        }
        return false;
      }
      recordFailure() {
        this.circuitBreaker.failures++;
        this.circuitBreaker.lastFailureTime = Date.now();
        if (this.circuitBreaker.failures >= this.circuitBreaker.threshold) {
          this.circuitBreaker.isOpen = true;
          console.warn("GMB Circuit breaker opened due to repeated failures");
        }
      }
      resetCircuitBreaker() {
        this.circuitBreaker.isOpen = false;
        this.circuitBreaker.failures = 0;
        this.circuitBreaker.lastFailureTime = 0;
      }
      /**
       * Log error for monitoring and debugging
       */
      async logError(error, context) {
        const logEntry = {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          level: "error",
          service: "gmb",
          error_type: error.type,
          error_message: error.message,
          error_code: error.code,
          retryable: error.retryable,
          retry_after: error.retryAfter,
          context,
          stack: error.originalError?.stack
        };
        console.error("GMB Error:", JSON.stringify(logEntry, null, 2));
        try {
          await storage.createGmbSyncHistory({
            businessId: context.businessId || "unknown",
            syncType: context.operation || "unknown",
            status: "error",
            errorMessage: error.message,
            errorCode: error.code?.toString(),
            details: logEntry,
            createdAt: /* @__PURE__ */ new Date()
          });
        } catch (dbError) {
          console.error("Failed to log error to database:", dbError);
        }
      }
      /**
       * Log successful operation for monitoring
       */
      async logOperation(data) {
        const logEntry = {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          level: "info",
          service: "gmb",
          type: data.type,
          attempt: data.attempt,
          context: data.context
        };
        console.info("GMB Operation:", JSON.stringify(logEntry, null, 2));
        if (data.type === "success" && data.context.businessId) {
          try {
            await storage.createGmbSyncHistory({
              businessId: data.context.businessId,
              syncType: data.context.operation || "unknown",
              status: "success",
              details: logEntry,
              createdAt: /* @__PURE__ */ new Date()
            });
          } catch (dbError) {
            console.error("Failed to log success to database:", dbError);
          }
        }
      }
      /**
       * Health check for GMB integration
       */
      getHealthStatus() {
        let status = "healthy";
        if (this.circuitBreaker.isOpen) {
          status = "unhealthy";
        } else if (this.circuitBreaker.failures > 0) {
          status = "degraded";
        }
        return {
          status,
          circuitBreaker: { ...this.circuitBreaker },
          lastCheck: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      /**
       * Validate data consistency between local and GMB data
       */
      validateDataConsistency(localData, gmbData) {
        const conflicts = [];
        const criticalFields = ["name", "address", "phone"];
        const importantFields = ["website", "category"];
        const minorFields = ["description"];
        for (const field of criticalFields) {
          if (localData[field] && gmbData[field] && localData[field] !== gmbData[field]) {
            conflicts.push({
              field,
              local: localData[field],
              gmb: gmbData[field],
              severity: "high"
            });
          }
        }
        for (const field of importantFields) {
          if (localData[field] && gmbData[field] && localData[field] !== gmbData[field]) {
            conflicts.push({
              field,
              local: localData[field],
              gmb: gmbData[field],
              severity: "medium"
            });
          }
        }
        for (const field of minorFields) {
          if (localData[field] && gmbData[field] && localData[field] !== gmbData[field]) {
            conflicts.push({
              field,
              local: localData[field],
              gmb: gmbData[field],
              severity: "low"
            });
          }
        }
        return {
          isConsistent: conflicts.length === 0,
          conflicts
        };
      }
    };
    gmbErrorHandler = GMBErrorHandler.getInstance();
  }
});

// server/gmbService.ts
import { OAuth2Client } from "google-auth-library";
import crypto from "crypto";
var GMB_CLIENT_ID, GMB_CLIENT_SECRET, GMB_REDIRECT_URI, GMB_SCOPES, RATE_LIMIT, GMBService, gmbService;
var init_gmbService = __esm({
  "server/gmbService.ts"() {
    "use strict";
    init_storage();
    init_gmbErrorHandler();
    GMB_CLIENT_ID = process.env.GMB_CLIENT_ID;
    GMB_CLIENT_SECRET = process.env.GMB_CLIENT_SECRET;
    GMB_REDIRECT_URI = process.env.GMB_REDIRECT_URI || `${process.env.REPLIT_URL || "http://localhost:5000"}/api/gmb/oauth/callback`;
    GMB_SCOPES = [
      "https://www.googleapis.com/auth/business.manage"
    ];
    RATE_LIMIT = {
      maxRequests: 100,
      windowMs: 60 * 1e3,
      // 1 minute
      requests: /* @__PURE__ */ new Map()
    };
    GMBService = class {
      constructor() {
        const isDemoMode = !GMB_CLIENT_ID || !GMB_CLIENT_SECRET;
        if (isDemoMode) {
          console.warn("GMB API credentials not configured. Running in demo mode.");
          this.oauth2Client = new OAuth2Client(
            "demo-client-id",
            "demo-client-secret",
            GMB_REDIRECT_URI
          );
        } else {
          this.oauth2Client = new OAuth2Client(
            GMB_CLIENT_ID,
            GMB_CLIENT_SECRET,
            GMB_REDIRECT_URI
          );
        }
        if (!process.env.GMB_ENCRYPTION_KEY) {
          if (process.env.NODE_ENV === "production" && GMB_CLIENT_ID && GMB_CLIENT_SECRET) {
            throw new Error(
              `GMB_ENCRYPTION_KEY must be set in production when GMB is fully configured (both GMB_CLIENT_ID and GMB_CLIENT_SECRET present).
Generate a secure key with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
Example: GMB_ENCRYPTION_KEY=a1b2c3d4e5f6789012345678901234567890123456789012345678901234abcd`
            );
          }
          this.encryptionKey = crypto.randomBytes(32).toString("hex");
          console.warn("\u26A0\uFE0F  Using temporary encryption key. Set GMB_ENCRYPTION_KEY environment variable for persistent token encryption.");
        } else {
          const key = process.env.GMB_ENCRYPTION_KEY;
          if (!/^[0-9a-fA-F]{64}$/.test(key)) {
            throw new Error(
              "GMB_ENCRYPTION_KEY must be exactly 64 hexadecimal characters (32 bytes).\nCurrent key length: " + key.length + ` characters
Generate a valid key with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
Example: GMB_ENCRYPTION_KEY=a1b2c3d4e5f6789012345678901234567890123456789012345678901234abcd`
            );
          }
          this.encryptionKey = key;
        }
      }
      /**
       * Check if GMB integration is available
       */
      isAvailable() {
        return !!(GMB_CLIENT_ID && GMB_CLIENT_SECRET);
      }
      /**
       * Generate OAuth 2.0 authorization URL
       */
      generateAuthUrl(state) {
        return this.oauth2Client.generateAuthUrl({
          access_type: "offline",
          scope: GMB_SCOPES,
          prompt: "consent",
          // Forces refresh token
          state
          // Can include business ID for tracking
        });
      }
      /**
       * Exchange authorization code for tokens
       */
      async exchangeCodeForTokens(code, businessId, userId) {
        if (!this.isAvailable()) {
          throw new Error("GMB integration is not available in demo mode. Please configure GMB_CLIENT_ID and GMB_CLIENT_SECRET.");
        }
        return await gmbErrorHandler.withRetry(
          async () => {
            const { tokens } = await this.oauth2Client.getToken(code);
            if (!tokens.access_token || !tokens.refresh_token) {
              throw new Error("Failed to obtain valid tokens from Google");
            }
            const encryptedAccessToken = this.encryptToken(tokens.access_token);
            const encryptedRefreshToken = this.encryptToken(tokens.refresh_token);
            const expiresAt = /* @__PURE__ */ new Date();
            expiresAt.setSeconds(expiresAt.getSeconds() + (tokens.expiry_date ? (tokens.expiry_date - Date.now()) / 1e3 : 3600));
            const tokenData = {
              businessId,
              userId,
              accessToken: encryptedAccessToken,
              refreshToken: encryptedRefreshToken,
              tokenType: tokens.token_type || "Bearer",
              expiresAt,
              scope: GMB_SCOPES.join(" "),
              isActive: true
            };
            await storage.createGmbToken(tokenData);
            await storage.updateBusinessGmbStatus(businessId, {
              gmbConnected: true,
              gmbSyncStatus: "connected"
            });
            await this.logSyncEvent(businessId, "oauth_connect", "success", {
              message: "Successfully connected to Google My Business"
            });
          },
          { maxRetries: 2 },
          {
            businessId,
            operation: "oauth_connect",
            userId
          }
        );
      }
      /**
       * Get valid access token for a business (refresh if needed)
       */
      async getValidAccessToken(businessId) {
        const tokenRecord = await storage.getGmbToken(businessId);
        if (!tokenRecord || !tokenRecord.isActive) {
          throw new Error("No active GMB token found for business");
        }
        const now = /* @__PURE__ */ new Date();
        if (tokenRecord.expiresAt <= now) {
          await this.refreshAccessToken(businessId);
          return this.getValidAccessToken(businessId);
        }
        return await this.decryptToken(tokenRecord.accessToken, businessId);
      }
      /**
       * Refresh access token using refresh token
       */
      async refreshAccessToken(businessId) {
        try {
          const tokenRecord = await storage.getGmbToken(businessId);
          if (!tokenRecord) {
            throw new Error("No token record found");
          }
          const refreshToken = await this.decryptToken(tokenRecord.refreshToken, businessId);
          this.oauth2Client.setCredentials({
            refresh_token: refreshToken
          });
          const { credentials } = await this.oauth2Client.refreshAccessToken();
          if (!credentials.access_token) {
            throw new Error("Failed to refresh access token");
          }
          const expiresAt = /* @__PURE__ */ new Date();
          expiresAt.setSeconds(expiresAt.getSeconds() + (credentials.expiry_date ? (credentials.expiry_date - Date.now()) / 1e3 : 3600));
          await storage.updateGmbToken(businessId, {
            accessToken: this.encryptToken(credentials.access_token),
            expiresAt,
            updatedAt: /* @__PURE__ */ new Date()
          });
        } catch (error) {
          await this.logSyncEvent(businessId, "token_refresh", "error", {
            error: error.message
          });
          await storage.updateGmbToken(businessId, { isActive: false });
          throw new Error(`Failed to refresh access token: ${error.message}`);
        }
      }
      /**
       * Get Google My Business accounts for authenticated user
       */
      async getBusinessAccounts(businessId) {
        if (!this.isAvailable()) {
          return [
            {
              name: "accounts/demo-account-123",
              accountName: "Demo Business Account",
              accountNumber: "123456789",
              role: "OWNER",
              state: "VERIFIED",
              type: "BUSINESS",
              verificationState: "VERIFIED",
              vettedState: "VETTED"
            }
          ];
        }
        return await gmbErrorHandler.withRetry(
          async () => {
            await this.checkRateLimit(businessId);
            const accessToken = await this.getValidAccessToken(businessId);
            const response = await fetch("https://mybusinessaccountmanagement.googleapis.com/v1/accounts", {
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              }
            });
            if (!response.ok) {
              const error = new Error(`API request failed: ${response.status} ${response.statusText}`);
              error.response = { status: response.status, statusText: response.statusText };
              throw error;
            }
            const data = await response.json();
            return data.accounts || [];
          },
          { maxRetries: 3 },
          {
            businessId,
            operation: "get_accounts"
          }
        );
      }
      /**
       * Get business locations for an account
       */
      async getBusinessLocations(businessId, accountName) {
        if (!this.isAvailable()) {
          const business = await storage.getBusinessById(businessId);
          const businessName = business?.name || "Demo Business";
          const businessAddress = business?.address || "123 Demo Street, Demo City, FL 33101";
          return [
            {
              name: `accounts/demo-account-123/locations/demo-location-${businessId}`,
              title: businessName,
              storefrontAddress: {
                addressLines: [businessAddress.split(",")[0]?.trim()],
                locality: "Miami",
                administrativeArea: "FL",
                postalCode: "33101",
                regionCode: "US"
              },
              phoneNumbers: {
                primary: business?.phone || "(555) 123-4567"
              },
              websiteUri: business?.website || "https://demo-business.com",
              metadata: {
                placeId: business?.googlePlaceId || `demo-place-${businessId}`,
                mapsUri: "https://maps.google.com/demo"
              },
              categories: {
                primary: {
                  displayName: business?.category || "Local Business",
                  categoryId: "gcid:local_business"
                }
              },
              locationState: {
                isGoogleUpdated: false,
                isVerified: true,
                isPublished: true
              }
            }
          ];
        }
        return await gmbErrorHandler.withRetry(
          async () => {
            await this.checkRateLimit(businessId);
            const accessToken = await this.getValidAccessToken(businessId);
            const response = await fetch(`https://mybusinessbusinessinformation.googleapis.com/v1/${accountName}/locations`, {
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              }
            });
            if (!response.ok) {
              const error = new Error(`API request failed: ${response.status} ${response.statusText}`);
              error.response = { status: response.status, statusText: response.statusText };
              throw error;
            }
            const data = await response.json();
            return data.locations || [];
          },
          { maxRetries: 3 },
          {
            businessId,
            operation: "get_locations",
            accountName
          }
        );
      }
      /**
       * Get detailed location information
       */
      async getLocationDetails(businessId, locationName) {
        if (!this.isAvailable()) {
          const business = await storage.getBusinessById(businessId);
          return {
            name: locationName,
            title: business?.name || "Demo Business",
            storefrontAddress: {
              addressLines: [business?.address?.split(",")[0]?.trim() || "123 Demo Street"],
              locality: business?.location?.split(",")[0]?.trim() || "Miami",
              administrativeArea: "FL",
              postalCode: "33101",
              regionCode: "US"
            },
            phoneNumbers: {
              primary: business?.phone || "(555) 123-4567"
            },
            websiteUri: business?.website || "https://demo-business.com",
            regularHours: {
              periods: [
                { openDay: "MONDAY", openTime: "09:00", closeTime: "17:00" },
                { openDay: "TUESDAY", openTime: "09:00", closeTime: "17:00" },
                { openDay: "WEDNESDAY", openTime: "09:00", closeTime: "17:00" },
                { openDay: "THURSDAY", openTime: "09:00", closeTime: "17:00" },
                { openDay: "FRIDAY", openTime: "09:00", closeTime: "17:00" },
                { openDay: "SATURDAY", openTime: "10:00", closeTime: "14:00" }
              ]
            },
            categories: {
              primary: {
                displayName: business?.category || "Local Business",
                categoryId: "gcid:local_business"
              },
              additionalCategories: []
            },
            metadata: {
              placeId: business?.googlePlaceId || `demo-place-${businessId}`,
              mapsUri: "https://maps.google.com/demo",
              newReviewUri: "https://search.google.com/local/writereview?placeid=demo"
            },
            profile: {
              description: business?.description || "Welcome to our business!"
            },
            locationState: {
              isGoogleUpdated: false,
              isVerified: true,
              isPublished: true,
              canModifyServiceList: true,
              canHaveFoodMenus: false
            }
          };
        }
        await this.checkRateLimit(businessId);
        try {
          const accessToken = await this.getValidAccessToken(businessId);
          const response = await fetch(`https://mybusinessbusinessinformation.googleapis.com/v1/${locationName}`, {
            headers: {
              "Authorization": `Bearer ${accessToken}`,
              "Content-Type": "application/json"
            }
          });
          if (!response.ok) {
            throw new Error(`API request failed: ${response.status} ${response.statusText}`);
          }
          return await response.json();
        } catch (error) {
          await this.logSyncEvent(businessId, "get_location_details", "error", {
            error: error.message
          });
          throw error;
        }
      }
      /**
       * Get reviews for a location
       */
      async getLocationReviews(businessId, locationName) {
        if (!this.isAvailable()) {
          const now = (/* @__PURE__ */ new Date()).toISOString();
          const daysAgo = (days) => new Date(Date.now() - days * 24 * 60 * 60 * 1e3).toISOString();
          return [
            {
              reviewId: `demo-review-1-${businessId}`,
              reviewer: {
                displayName: "John Smith",
                profilePhotoUrl: "https://lh3.googleusercontent.com/a/demo-photo1"
              },
              starRating: "FIVE",
              comment: "Excellent service! The team was very professional and delivered exactly what I needed. Highly recommend!",
              createTime: daysAgo(7),
              updateTime: daysAgo(7),
              reviewReply: {
                comment: "Thank you so much for your kind words, John! We're thrilled to hear you had a great experience.",
                updateTime: daysAgo(6)
              }
            },
            {
              reviewId: `demo-review-2-${businessId}`,
              reviewer: {
                displayName: "Sarah Johnson",
                profilePhotoUrl: "https://lh3.googleusercontent.com/a/demo-photo2"
              },
              starRating: "FOUR",
              comment: "Good experience overall. The product quality is great, though delivery took a bit longer than expected.",
              createTime: daysAgo(14),
              updateTime: daysAgo(14),
              reviewReply: null
            },
            {
              reviewId: `demo-review-3-${businessId}`,
              reviewer: {
                displayName: "Mike Wilson",
                profilePhotoUrl: "https://lh3.googleusercontent.com/a/demo-photo3"
              },
              starRating: "FIVE",
              comment: "Amazing! Best experience I've had with a local business. Will definitely be back!",
              createTime: daysAgo(30),
              updateTime: daysAgo(30),
              reviewReply: {
                comment: "We appreciate your business, Mike! Looking forward to serving you again soon.",
                updateTime: daysAgo(29)
              }
            }
          ];
        }
        return await gmbErrorHandler.withRetry(
          async () => {
            await this.checkRateLimit(businessId);
            const accessToken = await this.getValidAccessToken(businessId);
            const response = await fetch(`https://mybusiness.googleapis.com/v4/${locationName}/reviews`, {
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              }
            });
            if (!response.ok) {
              const error = new Error(`API request failed: ${response.status} ${response.statusText}`);
              error.response = { status: response.status, statusText: response.statusText };
              throw error;
            }
            const data = await response.json();
            return data.reviews || [];
          },
          { maxRetries: 3 },
          {
            businessId,
            operation: "get_reviews",
            locationName
          }
        );
      }
      /**
       * Sync business data from GMB
       */
      async syncBusinessData(businessId) {
        const startTime = Date.now();
        let itemsProcessed = 0;
        let itemsUpdated = 0;
        let itemsErrors = 0;
        const changes = {};
        try {
          await storage.updateBusinessGmbStatus(businessId, {
            gmbSyncStatus: "syncing",
            gmbLastSyncAt: /* @__PURE__ */ new Date()
          });
          if (!this.isAvailable()) {
            const business = await storage.getBusinessById(businessId);
            changes.businessInfo = {
              name: business?.name,
              phone: business?.phone,
              website: business?.website,
              category: business?.category,
              source: "demo_sync"
            };
            changes.reviews = {
              newCount: 3,
              averageRating: 4.7
            };
            itemsProcessed = 5;
            itemsUpdated = 2;
            await storage.updateBusinessGmbStatus(businessId, {
              gmbVerified: true,
              gmbConnected: true,
              gmbAccountId: "demo-account-123",
              gmbLocationId: `demo-location-${businessId}`,
              gmbSyncStatus: "success",
              gmbLastSyncAt: /* @__PURE__ */ new Date(),
              gmbLastError: null,
              gmbLastErrorAt: null
            });
            const duration2 = Date.now() - startTime;
            await this.logSyncEvent(businessId, "full_sync", "success", {
              changes,
              itemsProcessed,
              itemsUpdated,
              itemsErrors,
              durationMs: duration2
            });
            return { success: true, changes };
          }
          const accounts = await this.getBusinessAccounts(businessId);
          itemsProcessed++;
          let matchedLocation = null;
          for (const account of accounts) {
            const locations = await this.getBusinessLocations(businessId, account.name);
            itemsProcessed += locations.length;
            for (const location of locations) {
              if (await this.isLocationMatch(businessId, location)) {
                matchedLocation = location;
                break;
              }
            }
            if (matchedLocation) break;
          }
          if (!matchedLocation) {
            throw new Error("No matching GMB location found for this business");
          }
          const locationDetails = await this.getLocationDetails(businessId, matchedLocation.name);
          itemsProcessed++;
          const businessUpdates = await this.mapGmbDataToBusiness(locationDetails);
          if (Object.keys(businessUpdates).length > 0) {
            await storage.updateBusiness(businessId, businessUpdates);
            changes.businessInfo = businessUpdates;
            itemsUpdated++;
          }
          const reviews2 = await this.getLocationReviews(businessId, matchedLocation.name);
          const newReviews = await this.syncReviews(businessId, reviews2);
          if (newReviews.length > 0) {
            changes.reviews = { newCount: newReviews.length };
            itemsUpdated += newReviews.length;
          }
          itemsProcessed += reviews2.length;
          await storage.updateBusinessGmbStatus(businessId, {
            gmbVerified: true,
            gmbConnected: true,
            gmbAccountId: matchedLocation.name.split("/")[1],
            gmbLocationId: matchedLocation.name.split("/")[3],
            gmbSyncStatus: "success",
            gmbLastSyncAt: /* @__PURE__ */ new Date(),
            gmbLastError: null,
            gmbLastErrorAt: null
          });
          const duration = Date.now() - startTime;
          await this.logSyncEvent(businessId, "full_sync", "success", {
            changes,
            itemsProcessed,
            itemsUpdated,
            itemsErrors,
            durationMs: duration
          });
          return { success: true, changes };
        } catch (error) {
          itemsErrors++;
          const duration = Date.now() - startTime;
          await storage.updateBusinessGmbStatus(businessId, {
            gmbSyncStatus: "error",
            gmbLastError: error.message,
            gmbLastErrorAt: /* @__PURE__ */ new Date()
          });
          await this.logSyncEvent(businessId, "full_sync", "error", {
            error: error.message,
            itemsProcessed,
            itemsUpdated,
            itemsErrors,
            durationMs: duration
          });
          throw error;
        }
      }
      /**
       * Check if GMB location matches our business
       */
      async isLocationMatch(businessId, gmbLocation) {
        const business = await storage.getBusinessById(businessId);
        if (!business) return false;
        if (business.googlePlaceId && gmbLocation.metadata?.placeId) {
          return business.googlePlaceId === gmbLocation.metadata.placeId;
        }
        const businessName = business.name.toLowerCase().trim();
        const gmbName = gmbLocation.title?.toLowerCase().trim() || "";
        const nameMatch = businessName === gmbName || businessName.includes(gmbName) || gmbName.includes(businessName);
        const businessAddress = business.address?.toLowerCase().trim() || "";
        const gmbAddress = gmbLocation.storefrontAddress?.addressLines?.join(" ").toLowerCase().trim() || "";
        const addressMatch = businessAddress && gmbAddress && (businessAddress.includes(gmbAddress) || gmbAddress.includes(businessAddress));
        return nameMatch && (addressMatch || !businessAddress);
      }
      /**
       * Map GMB location data to our business schema
       */
      async mapGmbDataToBusiness(gmbLocation) {
        const updates = {};
        if (gmbLocation.title) {
          updates.name = gmbLocation.title;
        }
        if (gmbLocation.phoneNumbers?.primary) {
          updates.phone = gmbLocation.phoneNumbers.primary;
        }
        if (gmbLocation.websiteUri) {
          updates.website = gmbLocation.websiteUri;
        }
        if (gmbLocation.storefrontAddress) {
          const address = gmbLocation.storefrontAddress;
          const fullAddress = [
            address.addressLines?.join(", "),
            address.locality,
            address.administrativeArea,
            address.postalCode
          ].filter(Boolean).join(", ");
          updates.address = fullAddress;
          updates.location = `${address.locality}, ${address.administrativeArea}`;
        }
        if (gmbLocation.regularHours) {
          updates.operatingHours = this.formatOperatingHours(gmbLocation.regularHours);
        }
        if (gmbLocation.categories?.primary) {
          updates.category = gmbLocation.categories.primary.displayName;
        }
        updates.gmbDataSources = {
          name: gmbLocation.title ? "gmb" : "local",
          phone: gmbLocation.phoneNumbers?.primary ? "gmb" : "local",
          website: gmbLocation.websiteUri ? "gmb" : "local",
          address: gmbLocation.storefrontAddress ? "gmb" : "local",
          operatingHours: gmbLocation.regularHours ? "gmb" : "local",
          category: gmbLocation.categories?.primary ? "gmb" : "local"
        };
        return updates;
      }
      /**
       * Format operating hours from GMB format
       */
      formatOperatingHours(regularHours) {
        const formatted = {};
        for (const period of regularHours.periods || []) {
          if (period.openDay && period.openTime && period.closeTime) {
            const day = this.mapGmbDayToWeekday(period.openDay);
            formatted[day] = {
              open: period.openTime,
              close: period.closeTime,
              isClosed: false
            };
          }
        }
        return formatted;
      }
      /**
       * Map GMB day format to our weekday format
       */
      mapGmbDayToWeekday(gmbDay) {
        const mapping = {
          "MONDAY": "monday",
          "TUESDAY": "tuesday",
          "WEDNESDAY": "wednesday",
          "THURSDAY": "thursday",
          "FRIDAY": "friday",
          "SATURDAY": "saturday",
          "SUNDAY": "sunday"
        };
        return mapping[gmbDay] || gmbDay.toLowerCase();
      }
      /**
       * Sync reviews from GMB
       */
      async syncReviews(businessId, gmbReviews2) {
        const newReviews = [];
        for (const gmbReview of gmbReviews2) {
          try {
            const existingReview = await storage.getGmbReviewByGmbId(businessId, gmbReview.reviewId);
            if (!existingReview) {
              const ratingMap = {
                "ONE": 1,
                "TWO": 2,
                "THREE": 3,
                "FOUR": 4,
                "FIVE": 5
              };
              const reviewData = {
                businessId,
                gmbReviewId: gmbReview.reviewId,
                reviewerName: gmbReview.reviewer?.displayName || "Anonymous",
                reviewerPhotoUrl: gmbReview.reviewer?.profilePhotoUrl || null,
                rating: ratingMap[gmbReview.starRating] || 5,
                comment: gmbReview.comment || "",
                reviewTime: new Date(gmbReview.createTime),
                replyComment: gmbReview.reviewReply?.comment || null,
                replyTime: gmbReview.reviewReply?.updateTime ? new Date(gmbReview.reviewReply.updateTime) : null,
                gmbCreateTime: new Date(gmbReview.createTime),
                gmbUpdateTime: new Date(gmbReview.updateTime)
              };
              await storage.createGmbReview(reviewData);
              newReviews.push(reviewData);
            } else {
              if (gmbReview.reviewReply?.comment && !existingReview.replyComment) {
                await storage.updateGmbReview(existingReview.id, {
                  replyComment: gmbReview.reviewReply.comment,
                  replyTime: gmbReview.reviewReply?.updateTime ? new Date(gmbReview.reviewReply.updateTime) : null,
                  lastSyncedAt: /* @__PURE__ */ new Date()
                });
              }
            }
          } catch (error) {
            console.error("Error syncing review:", error);
          }
        }
        return newReviews;
      }
      /**
       * Rate limiting check
       */
      async checkRateLimit(businessId) {
        const now = Date.now();
        const windowStart = now - RATE_LIMIT.windowMs;
        if (!RATE_LIMIT.requests.has(businessId)) {
          RATE_LIMIT.requests.set(businessId, []);
        }
        const requests = RATE_LIMIT.requests.get(businessId);
        const validRequests = requests.filter((time) => time > windowStart);
        if (validRequests.length >= RATE_LIMIT.maxRequests) {
          throw new Error("Rate limit exceeded. Please try again later.");
        }
        validRequests.push(now);
        RATE_LIMIT.requests.set(businessId, validRequests);
      }
      /**
       * Log sync events for audit trail
       */
      async logSyncEvent(businessId, syncType, status, details) {
        try {
          const syncData = {
            businessId,
            syncType,
            status,
            dataTypes: details.changes ? Object.keys(details.changes) : [],
            changes: details.changes || null,
            errorDetails: details.error || null,
            itemsProcessed: details.itemsProcessed || 0,
            itemsUpdated: details.itemsUpdated || 0,
            itemsErrors: details.itemsErrors || 0,
            durationMs: details.durationMs || null,
            triggeredBy: "manual",
            gmbApiVersion: "v4.9"
          };
          await storage.createGmbSyncHistory(syncData);
        } catch (error) {
          console.error("Failed to log sync event:", error);
        }
      }
      /**
       * Encrypt token for secure storage using AES-256-GCM (authenticated encryption)
       * Format: v2:iv:ciphertext:authTag (all hex-encoded)
       */
      encryptToken(token) {
        const iv = crypto.randomBytes(12);
        const keyBuffer = Buffer.from(this.encryptionKey, "hex");
        const cipher = crypto.createCipheriv("aes-256-gcm", keyBuffer, iv);
        let encrypted = cipher.update(token, "utf8", "hex");
        encrypted += cipher.final("hex");
        const authTag = cipher.getAuthTag();
        return `v2:${iv.toString("hex")}:${encrypted}:${authTag.toString("hex")}`;
      }
      /**
       * Decrypt token from storage with backward compatibility
       * Supports v2 (AES-256-GCM), legacy CBC (iv:ciphertext), and oldest password-based formats
       * Automatically migrates legacy tokens to v2 format
       */
      async decryptToken(encryptedToken, businessId) {
        if (encryptedToken.startsWith("v2:")) {
          return this.decryptTokenV2(encryptedToken);
        }
        if (encryptedToken.includes(":")) {
          const parts = encryptedToken.split(":");
          if (parts.length === 2) {
            const decrypted = this.decryptTokenLegacyCBC(encryptedToken);
            if (businessId && decrypted) {
              try {
                const reencrypted = this.encryptToken(decrypted);
                const tokenRecord = await storage.getGmbToken(businessId);
                if (tokenRecord) {
                  const isAccessToken = tokenRecord.accessToken === encryptedToken;
                  const isRefreshToken = tokenRecord.refreshToken === encryptedToken;
                  if (isAccessToken) {
                    await storage.updateGmbToken(businessId, {
                      accessToken: reencrypted,
                      updatedAt: /* @__PURE__ */ new Date()
                    });
                    console.info(`\u2713 Migrated access token from legacy CBC to v2 format for business ${businessId}`);
                  } else if (isRefreshToken) {
                    await storage.updateGmbToken(businessId, {
                      refreshToken: reencrypted,
                      updatedAt: /* @__PURE__ */ new Date()
                    });
                    console.info(`\u2713 Migrated refresh token from legacy CBC to v2 format for business ${businessId}`);
                  }
                }
              } catch (migrationError) {
                console.error("Failed to migrate CBC token to v2 format:", migrationError);
              }
            }
            return decrypted;
          }
        }
        return await this.decryptTokenLegacyPassword(encryptedToken, businessId);
      }
      /**
       * Decrypt v2 token using AES-256-GCM
       */
      decryptTokenV2(encryptedToken) {
        const parts = encryptedToken.split(":");
        if (parts.length !== 4 || parts[0] !== "v2") {
          throw new Error("Invalid v2 token format");
        }
        const iv = Buffer.from(parts[1], "hex");
        const encryptedData = parts[2];
        const authTag = Buffer.from(parts[3], "hex");
        const keyBuffer = Buffer.from(this.encryptionKey, "hex");
        const decipher = crypto.createDecipheriv("aes-256-gcm", keyBuffer, iv);
        decipher.setAuthTag(authTag);
        let decrypted = decipher.update(encryptedData, "hex", "utf8");
        decrypted += decipher.final("utf8");
        return decrypted;
      }
      /**
       * Decrypt legacy CBC token using AES-256-CBC with explicit IV (for backward compatibility)
       * Format: iv:ciphertext
       */
      decryptTokenLegacyCBC(encryptedToken) {
        const parts = encryptedToken.split(":");
        if (parts.length !== 2) {
          throw new Error("Invalid legacy CBC token format");
        }
        const iv = Buffer.from(parts[0], "hex");
        const encryptedData = parts[1];
        const keyBuffer = Buffer.from(this.encryptionKey, "hex");
        const decipher = crypto.createDecipheriv("aes-256-cbc", keyBuffer, iv);
        let decrypted = decipher.update(encryptedData, "hex", "utf8");
        decrypted += decipher.final("utf8");
        return decrypted;
      }
      /**
       * Decrypt oldest legacy token using password-based KDF (for backward compatibility)
       * Format: single hex string (no IV, no colons)
       * Uses OpenSSL-compatible password-based key derivation
       */
      async decryptTokenLegacyPassword(encryptedToken, businessId) {
        try {
          if (!/^[0-9a-fA-F]+$/.test(encryptedToken)) {
            throw new Error("Invalid token format: not a valid hex string");
          }
          const decipher = crypto.createDecipher("aes-256-cbc", this.encryptionKey);
          let decrypted = decipher.update(encryptedToken, "hex", "utf8");
          decrypted += decipher.final("utf8");
          if (businessId && decrypted) {
            try {
              const reencrypted = this.encryptToken(decrypted);
              const tokenRecord = await storage.getGmbToken(businessId);
              if (tokenRecord) {
                const isAccessToken = tokenRecord.accessToken === encryptedToken;
                const isRefreshToken = tokenRecord.refreshToken === encryptedToken;
                if (isAccessToken) {
                  await storage.updateGmbToken(businessId, {
                    accessToken: reencrypted,
                    updatedAt: /* @__PURE__ */ new Date()
                  });
                  console.info(`\u2713 Migrated access token from oldest password-based format to v2 for business ${businessId}`);
                } else if (isRefreshToken) {
                  await storage.updateGmbToken(businessId, {
                    refreshToken: reencrypted,
                    updatedAt: /* @__PURE__ */ new Date()
                  });
                  console.info(`\u2713 Migrated refresh token from oldest password-based format to v2 for business ${businessId}`);
                }
              }
            } catch (migrationError) {
              console.error("Failed to migrate password-based token to v2 format:", migrationError);
            }
          }
          return decrypted;
        } catch (error) {
          throw new Error("Failed to decrypt token: invalid format or encryption key");
        }
      }
      /**
       * Disconnect GMB integration for a business
       */
      async disconnectBusiness(businessId) {
        try {
          await storage.updateGmbToken(businessId, { isActive: false });
          await storage.updateBusinessGmbStatus(businessId, {
            gmbConnected: false,
            gmbVerified: false,
            gmbSyncStatus: "disconnected",
            gmbAccountId: null,
            gmbLocationId: null
          });
          await this.logSyncEvent(businessId, "disconnect", "success", {
            message: "Successfully disconnected from Google My Business"
          });
        } catch (error) {
          await this.logSyncEvent(businessId, "disconnect", "error", {
            error: error.message
          });
          throw error;
        }
      }
      /**
       * Get sync status for a business
       */
      async getSyncStatus(businessId) {
        const business = await storage.getBusinessById(businessId);
        const token = await storage.getGmbToken(businessId);
        const recentSyncHistory = await storage.getRecentGmbSyncHistory(businessId, 5);
        return {
          connected: business?.gmbConnected || false,
          verified: business?.gmbVerified || false,
          syncStatus: business?.gmbSyncStatus || "none",
          lastSync: business?.gmbLastSyncAt,
          lastError: business?.gmbLastError,
          lastErrorAt: business?.gmbLastErrorAt,
          tokenValid: token?.isActive && token.expiresAt > /* @__PURE__ */ new Date(),
          accountId: business?.gmbAccountId,
          locationId: business?.gmbLocationId,
          recentHistory: recentSyncHistory
        };
      }
    };
    gmbService = new GMBService();
  }
});

// server/businessVerificationService.ts
var BusinessVerificationService, businessVerificationService;
var init_businessVerificationService = __esm({
  "server/businessVerificationService.ts"() {
    "use strict";
    init_gmbService();
    init_storage();
    BusinessVerificationService = class {
      /**
       * Search for potential GMB matches for a local business
       */
      async searchGMBMatches(businessId) {
        try {
          const business = await storage.getBusinessById(businessId);
          if (!business) {
            throw new Error("Business not found");
          }
          if (business.googlePlaceId) {
            const directMatch = await this.findByPlaceId(business.googlePlaceId, businessId);
            if (directMatch) {
              return {
                exactMatches: [directMatch],
                partialMatches: [],
                confidence: "high"
              };
            }
          }
          const searchResults = await this.searchByNameAndLocation(business);
          const { exactMatches, partialMatches } = this.analyzeMatches(business, searchResults);
          const confidence = this.calculateConfidence(exactMatches, partialMatches);
          return {
            exactMatches,
            partialMatches,
            confidence
          };
        } catch (error) {
          console.error("Error searching GMB matches:", error);
          throw new Error(`Failed to search GMB matches: ${error.message}`);
        }
      }
      /**
       * Find GMB listing by Google Place ID
       */
      async findByPlaceId(placeId, businessId) {
        try {
          const token = await storage.getGmbToken(businessId);
          if (!token || !token.isActive) {
            return null;
          }
          const accounts = await gmbService.getBusinessAccounts(businessId);
          for (const account of accounts) {
            const locations = await gmbService.getBusinessLocations(businessId, account.name);
            for (const location of locations) {
              if (location.metadata?.placeId === placeId) {
                const details = await gmbService.getLocationDetails(businessId, location.name);
                return {
                  ...details,
                  matchType: "place_id",
                  confidence: "high"
                };
              }
            }
          }
          return null;
        } catch (error) {
          console.error("Error finding by Place ID:", error);
          return null;
        }
      }
      /**
       * Search GMB by business name and location
       */
      async searchByNameAndLocation(business) {
        const results = [];
        try {
          const allBusinesses = await storage.getBusinessesByOwner(business.ownerId);
          for (const b of allBusinesses) {
            if (b.gmbConnected) {
              try {
                const accounts = await gmbService.getBusinessAccounts(b.id);
                for (const account of accounts) {
                  const locations = await gmbService.getBusinessLocations(b.id, account.name);
                  const potentialMatches = locations.filter(
                    (location) => this.isLocationPotentialMatch(business, location)
                  );
                  for (const location of potentialMatches) {
                    const details = await gmbService.getLocationDetails(b.id, location.name);
                    results.push(details);
                  }
                }
              } catch (error) {
                console.error(`Error searching GMB for business ${b.id}:`, error);
              }
            }
          }
        } catch (error) {
          console.error("Error in searchByNameAndLocation:", error);
        }
        return results;
      }
      /**
       * Check if a GMB location is a potential match for our business
       */
      isLocationPotentialMatch(business, gmbLocation) {
        const businessName = business.name.toLowerCase().trim();
        const gmbName = gmbLocation.title?.toLowerCase().trim() || "";
        const nameMatch = this.calculateNameSimilarity(businessName, gmbName) > 0.6;
        const locationMatch = this.isLocationSimilar(business, gmbLocation);
        return nameMatch || locationMatch;
      }
      /**
       * Calculate name similarity between two strings
       */
      calculateNameSimilarity(name1, name2) {
        if (!name1 || !name2) return 0;
        const longer = name1.length > name2.length ? name1 : name2;
        const shorter = name1.length > name2.length ? name2 : name1;
        if (longer.length === 0) return 1;
        const distance = this.levenshteinDistance(longer, shorter);
        return (longer.length - distance) / longer.length;
      }
      /**
       * Calculate Levenshtein distance between two strings
       */
      levenshteinDistance(str1, str2) {
        const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
        for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
        for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
        for (let j = 1; j <= str2.length; j++) {
          for (let i = 1; i <= str1.length; i++) {
            const substitutionCost = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(
              matrix[j][i - 1] + 1,
              // insertion
              matrix[j - 1][i] + 1,
              // deletion
              matrix[j - 1][i - 1] + substitutionCost
              // substitution
            );
          }
        }
        return matrix[str2.length][str1.length];
      }
      /**
       * Check if business location is similar to GMB location
       */
      isLocationSimilar(business, gmbLocation) {
        if (!business.location && !business.address) return false;
        if (!gmbLocation.storefrontAddress) return false;
        const businessLocation = (business.location || business.address || "").toLowerCase();
        const gmbAddress = gmbLocation.storefrontAddress.addressLines?.join(" ").toLowerCase() || "";
        const gmbCity = gmbLocation.storefrontAddress.locality?.toLowerCase() || "";
        return businessLocation.includes(gmbCity) || gmbAddress.includes(businessLocation) || this.calculateNameSimilarity(businessLocation, gmbAddress) > 0.5;
      }
      /**
       * Analyze GMB search results and categorize matches
       */
      analyzeMatches(business, searchResults) {
        const exactMatches = [];
        const partialMatches = [];
        for (const result of searchResults) {
          const matchScore = this.calculateMatchScore(business, result);
          if (matchScore >= 0.9) {
            exactMatches.push({ ...result, matchScore, matchType: "exact" });
          } else if (matchScore >= 0.6) {
            partialMatches.push({ ...result, matchScore, matchType: "partial" });
          }
        }
        return { exactMatches, partialMatches };
      }
      /**
       * Calculate overall match score between business and GMB location
       */
      calculateMatchScore(business, gmbLocation) {
        let totalScore = 0;
        let criteria = 0;
        const nameScore = this.calculateNameSimilarity(
          business.name.toLowerCase(),
          gmbLocation.title?.toLowerCase() || ""
        );
        totalScore += nameScore * 0.4;
        criteria++;
        if (business.phone && gmbLocation.phoneNumbers?.primary) {
          const phoneMatch = this.normalizePhone(business.phone) === this.normalizePhone(gmbLocation.phoneNumbers.primary) ? 1 : 0;
          totalScore += phoneMatch * 0.25;
          criteria++;
        }
        if (business.address && gmbLocation.storefrontAddress) {
          const addressScore = this.calculateAddressSimilarity(business, gmbLocation);
          totalScore += addressScore * 0.25;
          criteria++;
        }
        if (business.category && gmbLocation.categories?.primary) {
          const categoryScore = this.calculateCategorySimilarity(
            business.category,
            gmbLocation.categories.primary.displayName
          );
          totalScore += categoryScore * 0.1;
          criteria++;
        }
        return criteria > 0 ? totalScore / criteria : 0;
      }
      /**
       * Normalize phone number for comparison
       */
      normalizePhone(phone) {
        return phone.replace(/\D/g, "").slice(-10);
      }
      /**
       * Calculate address similarity score
       */
      calculateAddressSimilarity(business, gmbLocation) {
        const businessAddress = business.address?.toLowerCase().trim() || "";
        const gmbAddress = gmbLocation.storefrontAddress?.addressLines?.join(" ").toLowerCase().trim() || "";
        if (!businessAddress || !gmbAddress) return 0;
        return this.calculateNameSimilarity(businessAddress, gmbAddress);
      }
      /**
       * Calculate category similarity score
       */
      calculateCategorySimilarity(localCategory, gmbCategory) {
        const local = localCategory.toLowerCase().trim();
        const gmb = gmbCategory.toLowerCase().trim();
        if (local === gmb) return 1;
        if (local.includes(gmb) || gmb.includes(local)) return 0.7;
        return this.calculateNameSimilarity(local, gmb);
      }
      /**
       * Calculate overall confidence level
       */
      calculateConfidence(exactMatches, partialMatches) {
        if (exactMatches.length > 0) {
          return exactMatches.length === 1 ? "high" : "medium";
        }
        if (partialMatches.length > 0) {
          return partialMatches.length <= 2 ? "medium" : "low";
        }
        return "none";
      }
      /**
       * Initiate verification process for a business with a selected GMB listing
       */
      async initiateVerification(businessId, gmbLocationName) {
        try {
          const business = await storage.getBusinessById(businessId);
          if (!business) {
            throw new Error("Business not found");
          }
          const locationDetails = await gmbService.getLocationDetails(businessId, gmbLocationName);
          await storage.updateBusinessGmbStatus(businessId, {
            gmbConnected: true,
            gmbAccountId: gmbLocationName.split("/")[1],
            // Extract account ID
            gmbLocationId: gmbLocationName.split("/")[3],
            // Extract location ID
            gmbSyncStatus: "verification_pending"
          });
          const gmbData = await this.extractBusinessDataFromGMB(locationDetails);
          if (Object.keys(gmbData).length > 0) {
            const validUpdates = Object.entries(gmbData).reduce((acc, [key, value]) => {
              if (value !== void 0 && value !== null && value !== "") {
                acc[key] = value;
              }
              return acc;
            }, {});
            if (Object.keys(validUpdates).length > 0) {
              await storage.updateBusiness(businessId, validUpdates);
            }
          }
          const verificationId = `ver_${Date.now()}_${businessId}`;
          return {
            success: true,
            verificationId,
            message: "Verification initiated successfully. GMB data has been synced to your profile."
          };
        } catch (error) {
          console.error("Error initiating verification:", error);
          throw new Error(`Failed to initiate verification: ${error.message}`);
        }
      }
      /**
       * Complete verification process
       */
      async completeVerification(businessId) {
        try {
          await gmbService.syncBusinessData(businessId);
          await storage.updateBusinessGmbStatus(businessId, {
            gmbVerified: true,
            gmbSyncStatus: "verified"
          });
          await storage.createGmbSyncHistory({
            businessId,
            syncType: "verification_complete",
            status: "success",
            dataTypes: ["verification"],
            changes: { verified: true },
            errorDetails: null,
            itemsProcessed: 1,
            itemsUpdated: 1,
            itemsErrors: 0,
            durationMs: null,
            triggeredBy: "manual",
            gmbApiVersion: "v4.9"
          });
        } catch (error) {
          await storage.updateBusinessGmbStatus(businessId, {
            gmbSyncStatus: "verification_failed",
            gmbLastError: error.message,
            gmbLastErrorAt: /* @__PURE__ */ new Date()
          });
          throw error;
        }
      }
      /**
       * Get verification status for a business
       */
      async getVerificationStatus(businessId) {
        const business = await storage.getBusinessById(businessId);
        if (!business) {
          throw new Error("Business not found");
        }
        return {
          isVerified: business.gmbVerified || false,
          isConnected: business.gmbConnected || false,
          syncStatus: business.gmbSyncStatus || "none",
          lastSync: business.gmbLastSyncAt,
          lastError: business.gmbLastError,
          accountId: business.gmbAccountId,
          locationId: business.gmbLocationId
        };
      }
      /**
       * Extract business data from GMB location for updating local profile
       */
      async extractBusinessDataFromGMB(gmbLocation) {
        const updates = {};
        if (gmbLocation.title) {
          updates.name = gmbLocation.title;
        }
        if (gmbLocation.phoneNumbers?.primary) {
          updates.phone = gmbLocation.phoneNumbers.primary;
        }
        if (gmbLocation.websiteUri) {
          updates.website = gmbLocation.websiteUri;
        }
        if (gmbLocation.storefrontAddress) {
          const address = gmbLocation.storefrontAddress;
          const fullAddress = [
            address.addressLines?.join(", "),
            address.locality,
            address.administrativeArea,
            address.postalCode
          ].filter(Boolean).join(", ");
          updates.address = fullAddress;
          updates.location = `${address.locality}, ${address.administrativeArea}`;
        }
        if (gmbLocation.categories?.primary) {
          updates.category = gmbLocation.categories.primary.displayName;
        }
        if (gmbLocation.regularHours) {
          updates.operatingHours = this.formatOperatingHours(gmbLocation.regularHours);
        }
        updates.gmbDataSources = {
          name: gmbLocation.title ? "gmb" : "local",
          phone: gmbLocation.phoneNumbers?.primary ? "gmb" : "local",
          website: gmbLocation.websiteUri ? "gmb" : "local",
          address: gmbLocation.storefrontAddress ? "gmb" : "local",
          operatingHours: gmbLocation.regularHours ? "gmb" : "local",
          category: gmbLocation.categories?.primary ? "gmb" : "local"
        };
        if (gmbLocation.metadata?.placeId) {
          updates.googlePlaceId = gmbLocation.metadata.placeId;
        }
        return updates;
      }
      /**
       * Format operating hours from GMB format to our format
       */
      formatOperatingHours(regularHours) {
        const formatted = {};
        for (const period of regularHours.periods || []) {
          if (period.openDay && period.openTime && period.closeTime) {
            const day = this.mapGmbDayToWeekday(period.openDay);
            formatted[day] = {
              open: period.openTime,
              close: period.closeTime,
              isClosed: false
            };
          }
        }
        return formatted;
      }
      /**
       * Map GMB day format to our weekday format
       */
      mapGmbDayToWeekday(gmbDay) {
        const mapping = {
          "MONDAY": "monday",
          "TUESDAY": "tuesday",
          "WEDNESDAY": "wednesday",
          "THURSDAY": "thursday",
          "FRIDAY": "friday",
          "SATURDAY": "saturday",
          "SUNDAY": "sunday"
        };
        return mapping[gmbDay] || gmbDay.toLowerCase();
      }
      /**
       * Remove GMB verification for a business
       */
      async removeVerification(businessId) {
        try {
          await storage.updateBusinessGmbStatus(businessId, {
            gmbVerified: false,
            gmbConnected: false,
            gmbSyncStatus: "disconnected",
            gmbAccountId: null,
            gmbLocationId: null,
            gmbLastError: null,
            gmbLastErrorAt: null
          });
          await storage.deactivateGmbToken(businessId);
          await storage.createGmbSyncHistory({
            businessId,
            syncType: "verification_removed",
            status: "success",
            dataTypes: ["verification"],
            changes: { verified: false, connected: false },
            errorDetails: null,
            itemsProcessed: 1,
            itemsUpdated: 1,
            itemsErrors: 0,
            durationMs: null,
            triggeredBy: "manual",
            gmbApiVersion: "v4.9"
          });
        } catch (error) {
          console.error("Error removing verification:", error);
          throw new Error(`Failed to remove verification: ${error.message}`);
        }
      }
    };
    businessVerificationService = new BusinessVerificationService();
  }
});

// server/dataSyncService.ts
var DataSyncService, dataSyncService;
var init_dataSyncService = __esm({
  "server/dataSyncService.ts"() {
    "use strict";
    init_gmbService();
    init_storage();
    DataSyncService = class {
      /**
       * Perform comprehensive data synchronization for a business
       */
      async performFullSync(businessId, options = {}) {
        const {
          forceUpdate = false,
          syncPhotos = true,
          syncReviews = true,
          syncBusinessInfo = true,
          conflictResolution = "merge"
        } = options;
        const startTime = Date.now();
        const syncSummary = {
          businessInfoUpdated: false,
          photosImported: 0,
          reviewsImported: 0,
          hoursUpdated: false,
          categoriesUpdated: false,
          contactInfoUpdated: false,
          errors: [],
          warnings: []
        };
        const conflicts = [];
        const warnings = [];
        try {
          const business = await storage.getBusinessById(businessId);
          if (!business || !business.gmbConnected) {
            throw new Error("Business is not connected to Google My Business");
          }
          const gmbLocation = await this.getGMBLocationDetails(businessId);
          if (!gmbLocation) {
            throw new Error("Could not retrieve GMB location details");
          }
          if (syncBusinessInfo) {
            const businessResult = await this.syncBusinessInformation(
              businessId,
              business,
              gmbLocation,
              conflictResolution,
              forceUpdate
            );
            syncSummary.businessInfoUpdated = businessResult.updated;
            conflicts.push(...businessResult.conflicts);
            warnings.push(...businessResult.warnings);
          }
          if (syncPhotos) {
            const photoResult = await this.syncBusinessPhotos(businessId, gmbLocation);
            syncSummary.photosImported = photoResult.imported;
            warnings.push(...photoResult.warnings);
          }
          if (syncReviews) {
            const reviewResult = await this.syncBusinessReviews(businessId);
            syncSummary.reviewsImported = reviewResult.imported;
            warnings.push(...reviewResult.warnings);
          }
          await storage.createGmbSyncHistory({
            businessId,
            syncType: "full_sync",
            status: "success",
            dataTypes: this.getSyncedDataTypes(syncSummary),
            changes: syncSummary,
            errorDetails: null,
            itemsProcessed: this.countProcessedItems(syncSummary),
            itemsUpdated: this.countUpdatedItems(syncSummary),
            itemsErrors: syncSummary.errors.length,
            durationMs: Date.now() - startTime,
            triggeredBy: "manual",
            gmbApiVersion: "v4.9"
          });
          await storage.updateBusinessGmbStatus(businessId, {
            gmbSyncStatus: "success",
            gmbLastSyncAt: /* @__PURE__ */ new Date(),
            gmbLastError: null,
            gmbLastErrorAt: null
          });
          return {
            success: true,
            syncSummary,
            conflicts,
            warnings
          };
        } catch (error) {
          await storage.createGmbSyncHistory({
            businessId,
            syncType: "full_sync",
            status: "error",
            dataTypes: [],
            changes: null,
            errorDetails: error.message,
            itemsProcessed: 0,
            itemsUpdated: 0,
            itemsErrors: 1,
            durationMs: Date.now() - startTime,
            triggeredBy: "manual",
            gmbApiVersion: "v4.9"
          });
          await storage.updateBusinessGmbStatus(businessId, {
            gmbSyncStatus: "error",
            gmbLastError: error.message,
            gmbLastErrorAt: /* @__PURE__ */ new Date()
          });
          throw error;
        }
      }
      /**
       * Get GMB location details for the business
       */
      async getGMBLocationDetails(businessId) {
        const business = await storage.getBusinessById(businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("GMB account or location ID not found");
        }
        const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
        return await gmbService.getLocationDetails(businessId, locationName);
      }
      /**
       * Sync business information with conflict resolution
       */
      async syncBusinessInformation(businessId, localBusiness, gmbLocation, conflictResolution, forceUpdate) {
        const conflicts = [];
        const warnings = [];
        const updates = {};
        const fieldMappings = [
          { local: "name", gmb: "title", required: true },
          { local: "phone", gmb: ["phoneNumbers", "primary"], required: false },
          { local: "website", gmb: "websiteUri", required: false },
          { local: "category", gmb: ["categories", "primary", "displayName"], required: false }
        ];
        for (const mapping of fieldMappings) {
          const localValue = localBusiness[mapping.local];
          const gmbValue = this.extractNestedValue(gmbLocation, mapping.gmb);
          if (gmbValue && (!localValue || forceUpdate)) {
            updates[mapping.local] = gmbValue;
          } else if (gmbValue && localValue && gmbValue !== localValue) {
            const conflict = {
              field: mapping.local,
              localValue,
              gmbValue,
              resolution: conflictResolution,
              resolved: false
            };
            switch (conflictResolution) {
              case "gmb":
                updates[mapping.local] = gmbValue;
                conflict.resolved = true;
                conflict.selectedValue = gmbValue;
                break;
              case "local":
                conflict.resolved = true;
                conflict.selectedValue = localValue;
                break;
              case "merge":
                updates[mapping.local] = gmbValue;
                conflict.resolved = true;
                conflict.selectedValue = gmbValue;
                break;
              case "prompt":
                break;
            }
            conflicts.push(conflict);
          }
        }
        const addressResult = this.syncAddressInformation(localBusiness, gmbLocation, conflictResolution);
        if (addressResult.updates) {
          Object.assign(updates, addressResult.updates);
        }
        conflicts.push(...addressResult.conflicts);
        const hoursResult = this.syncOperatingHours(localBusiness, gmbLocation, conflictResolution);
        if (hoursResult.updates) {
          Object.assign(updates, hoursResult.updates);
        }
        conflicts.push(...hoursResult.conflicts);
        updates.gmbDataSources = this.updateDataSources(localBusiness, updates);
        let updated = false;
        if (Object.keys(updates).length > 0) {
          await storage.updateBusiness(businessId, updates);
          updated = true;
        }
        return { updated, conflicts, warnings };
      }
      /**
       * Sync business photos from GMB
       */
      async syncBusinessPhotos(businessId, gmbLocation) {
        const warnings = [];
        let imported = 0;
        try {
          const gmbPhotos = this.extractPhotosFromGMB(gmbLocation);
          if (gmbPhotos.length === 0) {
            warnings.push("No photos found in GMB listing");
            return { imported, warnings };
          }
          const business = await storage.getBusinessById(businessId);
          if (!business) {
            warnings.push("Business not found for photo sync");
            return { imported, warnings };
          }
          const logoPhoto = gmbPhotos.find((photo) => photo.type === "logo" || photo.type === "profile");
          if (logoPhoto && !business.logoUrl) {
            await storage.updateBusinessGmbStatus(businessId, {
              // Use GMB status update method for partial updates
            });
            imported++;
          }
          const coverPhoto = gmbPhotos.find((photo) => photo.type === "cover" || photo.type === "exterior");
          if (coverPhoto && !business.coverImageUrl) {
            await storage.updateBusinessGmbStatus(businessId, {
              // Store photo reference in GMB data sources
            });
            imported++;
          }
        } catch (error) {
          warnings.push(`Photo sync error: ${error.message}`);
        }
        return { imported, warnings };
      }
      /**
       * Sync business reviews from GMB
       */
      async syncBusinessReviews(businessId) {
        const warnings = [];
        let imported = 0;
        try {
          const business = await storage.getBusinessById(businessId);
          if (!business?.gmbAccountId || !business?.gmbLocationId) {
            warnings.push("GMB account information not available for review sync");
            return { imported, warnings };
          }
          const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
          const gmbReviews2 = await gmbService.getLocationReviews(businessId, locationName);
          for (const gmbReview of gmbReviews2) {
            try {
              const existingReview = await storage.getGmbReviewByGmbId(businessId, gmbReview.reviewId);
              if (!existingReview) {
                const reviewData = {
                  businessId,
                  gmbReviewId: gmbReview.reviewId,
                  reviewerName: gmbReview.reviewer?.displayName || "Anonymous",
                  reviewerPhotoUrl: gmbReview.reviewer?.profilePhotoUrl,
                  rating: parseInt(gmbReview.starRating) || 5,
                  comment: gmbReview.comment || "",
                  reviewTime: new Date(gmbReview.createTime),
                  replyComment: gmbReview.reviewReply?.comment,
                  replyTime: gmbReview.reviewReply?.updateTime ? new Date(gmbReview.reviewReply.updateTime) : null,
                  gmbCreateTime: new Date(gmbReview.createTime),
                  gmbUpdateTime: new Date(gmbReview.updateTime)
                };
                await storage.createGmbReview(reviewData);
                imported++;
              } else {
                await storage.updateGmbReview(existingReview.id, {
                  lastSyncedAt: /* @__PURE__ */ new Date()
                });
              }
            } catch (error) {
              warnings.push(`Failed to import review ${gmbReview.reviewId}: ${error.message}`);
            }
          }
          if (imported > 0) {
            await this.updateBusinessRatingStats(businessId);
          }
        } catch (error) {
          warnings.push(`Review sync error: ${error.message}`);
        }
        return { imported, warnings };
      }
      /**
       * Sync address information with conflict resolution
       */
      syncAddressInformation(localBusiness, gmbLocation, conflictResolution) {
        const conflicts = [];
        const updates = {};
        if (!gmbLocation.storefrontAddress) {
          return { conflicts };
        }
        const gmbAddress = this.formatGMBAddress(gmbLocation.storefrontAddress);
        const gmbLocation_formatted = `${gmbLocation.storefrontAddress.locality}, ${gmbLocation.storefrontAddress.administrativeArea}`;
        if (gmbAddress.fullAddress && localBusiness.address !== gmbAddress.fullAddress) {
          const conflict = {
            field: "address",
            localValue: localBusiness.address || "",
            gmbValue: gmbAddress.fullAddress,
            resolution: conflictResolution,
            resolved: false
          };
          if (conflictResolution === "gmb" || conflictResolution === "merge" || !localBusiness.address) {
            updates.address = gmbAddress.fullAddress;
            conflict.resolved = true;
            conflict.selectedValue = gmbAddress.fullAddress;
          }
          conflicts.push(conflict);
        }
        if (gmbLocation_formatted && localBusiness.location !== gmbLocation_formatted) {
          const conflict = {
            field: "location",
            localValue: localBusiness.location || "",
            gmbValue: gmbLocation_formatted,
            resolution: conflictResolution,
            resolved: false
          };
          if (conflictResolution === "gmb" || conflictResolution === "merge" || !localBusiness.location) {
            updates.location = gmbLocation_formatted;
            conflict.resolved = true;
            conflict.selectedValue = gmbLocation_formatted;
          }
          conflicts.push(conflict);
        }
        return { updates: Object.keys(updates).length > 0 ? updates : void 0, conflicts };
      }
      /**
       * Sync operating hours with conflict resolution
       */
      syncOperatingHours(localBusiness, gmbLocation, conflictResolution) {
        const conflicts = [];
        if (!gmbLocation.regularHours) {
          return { conflicts };
        }
        const gmbHours = this.formatGMBOperatingHours(gmbLocation.regularHours);
        const localHours = localBusiness.operatingHours;
        const hoursConflict = this.compareOperatingHours(localHours, gmbHours);
        if (hoursConflict.hasConflicts) {
          const conflict = {
            field: "operatingHours",
            localValue: JSON.stringify(localHours),
            gmbValue: JSON.stringify(gmbHours),
            resolution: conflictResolution,
            resolved: false,
            details: hoursConflict.differences
          };
          let updates = {};
          if (conflictResolution === "gmb" || conflictResolution === "merge" || !localHours) {
            updates.operatingHours = gmbHours;
            conflict.resolved = true;
            conflict.selectedValue = JSON.stringify(gmbHours);
          }
          conflicts.push(conflict);
          return { updates: Object.keys(updates).length > 0 ? updates : void 0, conflicts };
        }
        return { conflicts };
      }
      /**
       * Update business rating statistics based on GMB reviews
       */
      async updateBusinessRatingStats(businessId) {
        const reviews2 = await storage.getGmbReviewsByBusiness(businessId);
        if (reviews2.length === 0) return;
        const totalRating = reviews2.reduce((sum2, review) => sum2 + review.rating, 0);
        const averageRating = totalRating / reviews2.length;
        await storage.updateBusinessGmbStatus(businessId, {
          // Store rating info in GMB data sources for now
          gmbDataSources: {
            rating: "gmb",
            reviewCount: "gmb"
          }
        });
      }
      /**
       * Extract nested value from object using dot notation or array path
       */
      extractNestedValue(obj, path6) {
        if (typeof path6 === "string") {
          return obj[path6];
        }
        let current = obj;
        for (const key of path6) {
          if (current && typeof current === "object") {
            current = current[key];
          } else {
            return void 0;
          }
        }
        return current;
      }
      /**
       * Extract photos from GMB location data
       */
      extractPhotosFromGMB(gmbLocation) {
        const photos = [];
        if (gmbLocation.photos) {
          for (const photo of gmbLocation.photos) {
            photos.push({
              type: photo.category || "general",
              url: photo.googleUrl || photo.sourceUrl
            });
          }
        }
        if (gmbLocation.profile?.coverPhoto) {
          photos.push({
            type: "cover",
            url: gmbLocation.profile.coverPhoto.googleUrl
          });
        }
        return photos;
      }
      /**
       * Format GMB address to our address format
       */
      formatGMBAddress(storefrontAddress) {
        const addressParts = [
          storefrontAddress.addressLines?.join(", "),
          storefrontAddress.locality,
          storefrontAddress.administrativeArea,
          storefrontAddress.postalCode,
          storefrontAddress.regionCode
        ].filter(Boolean);
        return {
          fullAddress: addressParts.join(", ")
        };
      }
      /**
       * Format GMB operating hours to our format
       */
      formatGMBOperatingHours(regularHours) {
        const formatted = {};
        for (const period of regularHours.periods || []) {
          if (period.openDay && period.openTime && period.closeTime) {
            const day = this.mapGmbDayToWeekday(period.openDay);
            formatted[day] = {
              open: this.formatTime(period.openTime),
              close: this.formatTime(period.closeTime),
              isClosed: false
            };
          }
        }
        return formatted;
      }
      /**
       * Map GMB day format to our weekday format
       */
      mapGmbDayToWeekday(gmbDay) {
        const mapping = {
          "MONDAY": "monday",
          "TUESDAY": "tuesday",
          "WEDNESDAY": "wednesday",
          "THURSDAY": "thursday",
          "FRIDAY": "friday",
          "SATURDAY": "saturday",
          "SUNDAY": "sunday"
        };
        return mapping[gmbDay] || gmbDay.toLowerCase();
      }
      /**
       * Format time from GMB format (e.g., "0900") to readable format (e.g., "9:00 AM")
       */
      formatTime(timeString) {
        if (!timeString || timeString.length !== 4) return timeString;
        const hours = parseInt(timeString.substring(0, 2));
        const minutes = timeString.substring(2, 4);
        const ampm = hours >= 12 ? "PM" : "AM";
        const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
        return `${displayHours}:${minutes} ${ampm}`;
      }
      /**
       * Compare operating hours and identify conflicts
       */
      compareOperatingHours(localHours, gmbHours) {
        const differences = [];
        if (!localHours && !gmbHours) {
          return { hasConflicts: false, differences };
        }
        if (!localHours) {
          return { hasConflicts: true, differences: ["Local hours not set"] };
        }
        if (!gmbHours) {
          return { hasConflicts: true, differences: ["GMB hours not available"] };
        }
        const days = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
        for (const day of days) {
          const localDay = localHours[day];
          const gmbDay = gmbHours[day];
          if (!localDay && !gmbDay) continue;
          if (!localDay) {
            differences.push(`${day}: Local not set, GMB has ${gmbDay.open}-${gmbDay.close}`);
          } else if (!gmbDay) {
            differences.push(`${day}: Local has ${localDay.open}-${localDay.close}, GMB not set`);
          } else if (localDay.open !== gmbDay.open || localDay.close !== gmbDay.close) {
            differences.push(`${day}: Local ${localDay.open}-${localDay.close} vs GMB ${gmbDay.open}-${gmbDay.close}`);
          }
        }
        return {
          hasConflicts: differences.length > 0,
          differences
        };
      }
      /**
       * Update data source attribution
       */
      updateDataSources(localBusiness, updates) {
        const currentSources = localBusiness.gmbDataSources || {};
        const newSources = { ...currentSources };
        for (const field of Object.keys(updates)) {
          if (field !== "gmbDataSources") {
            newSources[field] = "gmb";
          }
        }
        return newSources;
      }
      /**
       * Get list of synced data types for logging
       */
      getSyncedDataTypes(syncSummary) {
        const types = [];
        if (syncSummary.businessInfoUpdated) types.push("business_info");
        if (syncSummary.photosImported > 0) types.push("photos");
        if (syncSummary.reviewsImported > 0) types.push("reviews");
        if (syncSummary.hoursUpdated) types.push("hours");
        if (syncSummary.categoriesUpdated) types.push("categories");
        if (syncSummary.contactInfoUpdated) types.push("contact_info");
        return types;
      }
      /**
       * Count processed items for logging
       */
      countProcessedItems(syncSummary) {
        return (syncSummary.businessInfoUpdated ? 1 : 0) + syncSummary.photosImported + syncSummary.reviewsImported;
      }
      /**
       * Count updated items for logging
       */
      countUpdatedItems(syncSummary) {
        return (syncSummary.businessInfoUpdated ? 1 : 0) + syncSummary.photosImported + syncSummary.reviewsImported;
      }
      /**
       * Perform incremental sync (only sync recent changes)
       */
      async performIncrementalSync(businessId) {
        try {
          const business = await storage.getBusinessById(businessId);
          if (!business?.gmbLastSyncAt) {
            const result = await this.performFullSync(businessId);
            return { success: result.success, changes: result.syncSummary };
          }
          const reviewResult = await this.syncBusinessReviews(businessId);
          await storage.updateBusinessGmbStatus(businessId, {
            gmbSyncStatus: "success",
            gmbLastSyncAt: /* @__PURE__ */ new Date()
          });
          return {
            success: true,
            changes: {
              reviewsImported: reviewResult.imported,
              warnings: reviewResult.warnings
            }
          };
        } catch (error) {
          await storage.updateBusinessGmbStatus(businessId, {
            gmbSyncStatus: "error",
            gmbLastError: error.message,
            gmbLastErrorAt: /* @__PURE__ */ new Date()
          });
          throw error;
        }
      }
    };
    dataSyncService = new DataSyncService();
  }
});

// server/gmbReviewService.ts
var GMBReviewService, gmbReviewService;
var init_gmbReviewService = __esm({
  "server/gmbReviewService.ts"() {
    "use strict";
    init_gmbService();
    init_gmbErrorHandler();
    init_storage();
    GMBReviewService = class {
      constructor() {
        this.sentimentKeywords = {
          positive: ["excellent", "great", "amazing", "wonderful", "fantastic", "best", "love", "perfect", "outstanding", "awesome"],
          negative: ["terrible", "awful", "horrible", "worst", "hate", "disappointed", "poor", "bad", "unacceptable", "disgusting"],
          neutral: ["okay", "fine", "average", "decent", "alright", "mediocre", "fair", "reasonable"]
        };
        this.reviewTemplates = [
          {
            id: "positive_thanks",
            name: "Thank You - Positive",
            category: "positive",
            template: "Thank you so much for your wonderful review, {customer_name}! We're thrilled to hear you had such a great experience with {business_name}. We look forward to serving you again soon!",
            variables: ["{customer_name}", "{business_name}"],
            usageCount: 0,
            successRate: 0.95
          },
          {
            id: "negative_apology",
            name: "Apology - Negative",
            category: "negative",
            template: "Dear {customer_name}, we sincerely apologize for your experience. Your feedback is invaluable to us. Please contact us at {contact_email} so we can make this right. We appreciate your patience and the opportunity to improve.",
            variables: ["{customer_name}", "{contact_email}"],
            usageCount: 0,
            successRate: 0.85
          },
          {
            id: "neutral_engagement",
            name: "Engagement - Neutral",
            category: "neutral",
            template: "Thank you for your feedback, {customer_name}. We're always looking to improve our services. If you have any specific suggestions, we'd love to hear them. Please feel free to reach out to us directly.",
            variables: ["{customer_name}"],
            usageCount: 0,
            successRate: 0.9
          }
        ];
      }
      /**
       * Fetch all reviews for a business from GMB
       */
      async fetchReviews(businessId, options = {}) {
        const business = await storage.getBusinessById(businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("Business is not connected to Google My Business");
        }
        return await gmbErrorHandler.withRetry(async () => {
          const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
          const gmbReviews2 = await gmbService.getLocationReviews(businessId, locationName);
          const importedReviews = [];
          for (const gmbReview of gmbReviews2) {
            const existingReview = await storage.getGmbReviewByGmbId(businessId, gmbReview.reviewId);
            if (!existingReview) {
              const reviewData = {
                businessId,
                gmbReviewId: gmbReview.reviewId,
                reviewerName: gmbReview.reviewer?.displayName || "Anonymous",
                reviewerPhotoUrl: gmbReview.reviewer?.profilePhotoUrl,
                rating: this.parseStarRating(gmbReview.starRating),
                comment: gmbReview.comment || "",
                reviewTime: new Date(gmbReview.createTime),
                replyComment: gmbReview.reviewReply?.comment,
                replyTime: gmbReview.reviewReply?.updateTime ? new Date(gmbReview.reviewReply.updateTime) : null,
                sentiment: this.analyzeSentiment(gmbReview.comment || ""),
                isHighlighted: false,
                isArchived: false,
                tags: this.extractTags(gmbReview.comment || ""),
                gmbCreateTime: new Date(gmbReview.createTime),
                gmbUpdateTime: new Date(gmbReview.updateTime),
                lastSyncedAt: /* @__PURE__ */ new Date()
              };
              const newReview = await storage.createGmbReview(reviewData);
              importedReviews.push(newReview);
            }
          }
          const allReviews = await storage.getGmbReviewsByBusiness(businessId);
          return {
            reviews: allReviews,
            nextPageToken: void 0,
            // GMB API v4.9 doesn't support pagination in the same way
            totalReviews: allReviews.length
          };
        }, { maxRetries: 3 }, { businessId, operation: "fetch_reviews" });
      }
      /**
       * Reply to a review on GMB
       */
      async replyToReview(businessId, reviewId, replyText) {
        const business = await storage.getBusinessById(businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("Business is not connected to Google My Business");
        }
        return await gmbErrorHandler.withRetry(async () => {
          const review = await storage.getGmbReviewById(reviewId);
          if (!review || review.businessId !== businessId) {
            throw new Error("Review not found or does not belong to this business");
          }
          const accessToken = await gmbService.getValidAccessToken(businessId);
          const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
          const response = await fetch(
            `https://mybusiness.googleapis.com/v4/${locationName}/reviews/${review.gmbReviewId}/reply`,
            {
              method: "PUT",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                comment: replyText
              })
            }
          );
          if (!response.ok) {
            throw new Error(`Failed to post review reply: ${response.statusText}`);
          }
          await storage.updateGmbReview(reviewId, {
            replyComment: replyText,
            replyTime: /* @__PURE__ */ new Date(),
            hasOwnerResponse: true
          });
          await storage.createGmbSyncHistory({
            businessId,
            syncType: "review_reply",
            status: "success",
            dataTypes: ["review_reply"],
            changes: { reviewId, reply: replyText },
            errorDetails: null,
            itemsProcessed: 1,
            itemsUpdated: 1,
            itemsErrors: 0,
            durationMs: null,
            triggeredBy: "manual",
            gmbApiVersion: "v4.9"
          });
        }, { maxRetries: 2 }, { businessId, operation: "reply_to_review", reviewId });
      }
      /**
       * Update a review reply
       */
      async updateReviewReply(businessId, reviewId, newReplyText) {
        return this.replyToReview(businessId, reviewId, newReplyText);
      }
      /**
       * Delete a review reply
       */
      async deleteReviewReply(businessId, reviewId) {
        const business = await storage.getBusinessById(businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("Business is not connected to Google My Business");
        }
        return await gmbErrorHandler.withRetry(async () => {
          const review = await storage.getGmbReviewById(reviewId);
          if (!review || review.businessId !== businessId) {
            throw new Error("Review not found or does not belong to this business");
          }
          const accessToken = await gmbService.getValidAccessToken(businessId);
          const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
          const response = await fetch(
            `https://mybusiness.googleapis.com/v4/${locationName}/reviews/${review.gmbReviewId}/reply`,
            {
              method: "DELETE",
              headers: {
                "Authorization": `Bearer ${accessToken}`
              }
            }
          );
          if (!response.ok) {
            throw new Error(`Failed to delete review reply: ${response.statusText}`);
          }
          await storage.updateGmbReview(reviewId, {
            replyComment: null,
            replyTime: null,
            hasOwnerResponse: false
          });
        }, { maxRetries: 2 }, { businessId, operation: "delete_review_reply", reviewId });
      }
      /**
       * Generate review insights and analytics
       */
      async generateInsights(businessId, options = {}) {
        const reviews2 = await storage.getGmbReviewsByBusiness(businessId);
        const totalReviews = reviews2.length;
        const totalRating = reviews2.reduce((sum2, r) => sum2 + r.rating, 0);
        const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;
        const ratingDistribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
        reviews2.forEach((r) => {
          ratingDistribution[r.rating] = (ratingDistribution[r.rating] || 0) + 1;
        });
        const sentiments = reviews2.map((r) => this.analyzeSentiment(r.comment || ""));
        const sentimentBreakdown = {
          positive: sentiments.filter((s) => s.overall === "positive").length,
          neutral: sentiments.filter((s) => s.overall === "neutral").length,
          negative: sentiments.filter((s) => s.overall === "negative").length
        };
        const reviewsWithReplies = reviews2.filter((r) => r.hasOwnerResponse);
        const responseRate = totalReviews > 0 ? reviewsWithReplies.length / totalReviews * 100 : 0;
        let totalResponseTime = 0;
        let responseCount = 0;
        reviewsWithReplies.forEach((r) => {
          if (r.replyTime && r.reviewTime) {
            const responseTime = r.replyTime.getTime() - r.reviewTime.getTime();
            totalResponseTime += responseTime;
            responseCount++;
          }
        });
        const averageResponseTime = responseCount > 0 ? totalResponseTime / responseCount / (1e3 * 60 * 60) : 0;
        const now = /* @__PURE__ */ new Date();
        const last7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
        const last30Days = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
        const last90Days = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1e3);
        const recentActivity = {
          last7Days: reviews2.filter((r) => r.reviewTime >= last7Days).length,
          last30Days: reviews2.filter((r) => r.reviewTime >= last30Days).length,
          last90Days: reviews2.filter((r) => r.reviewTime >= last90Days).length
        };
        const topicMap = /* @__PURE__ */ new Map();
        reviews2.forEach((r) => {
          const tags = this.extractTags(r.comment || "");
          const sentiment = this.analyzeSentiment(r.comment || "").overall;
          tags.forEach((tag) => {
            if (!topicMap.has(tag)) {
              topicMap.set(tag, { count: 0, sentiments: [] });
            }
            const topic = topicMap.get(tag);
            topic.count++;
            topic.sentiments.push(sentiment);
          });
        });
        const trendingTopics = Array.from(topicMap.entries()).map(([topic, data]) => {
          const mostCommonSentiment = this.getMostCommonSentiment(data.sentiments);
          return { topic, count: data.count, sentiment: mostCommonSentiment };
        }).sort((a, b) => b.count - a.count).slice(0, 10);
        return {
          averageRating,
          totalReviews,
          ratingDistribution,
          sentimentBreakdown,
          trendingTopics,
          responseRate,
          averageResponseTime,
          recentActivity
        };
      }
      /**
       * Monitor review sentiment and trigger alerts
       */
      async monitorSentiment(businessId, options = {}) {
        const {
          alertOnNegative = true,
          alertThreshold = 3,
          timeWindow = 24
        } = options;
        const alerts = [];
        const reviews2 = await storage.getGmbReviewsByBusiness(businessId);
        const cutoffTime = new Date(Date.now() - timeWindow * 60 * 60 * 1e3);
        const recentReviews = reviews2.filter((r) => r.reviewTime >= cutoffTime);
        if (alertOnNegative) {
          const negativeReviews = recentReviews.filter((r) => {
            const sentiment = this.analyzeSentiment(r.comment || "");
            return sentiment.overall === "negative" || r.rating <= 2;
          });
          if (negativeReviews.length >= alertThreshold) {
            alerts.push({
              type: "negative_trend",
              severity: "high",
              message: `${negativeReviews.length} negative reviews received in the last ${timeWindow} hours`,
              data: { reviews: negativeReviews }
            });
          }
        }
        const unrespondedReviews = reviews2.filter((r) => !r.hasOwnerResponse && r.rating <= 3);
        if (unrespondedReviews.length > 0) {
          alerts.push({
            type: "response_needed",
            severity: unrespondedReviews.some((r) => r.rating === 1) ? "high" : "medium",
            message: `${unrespondedReviews.length} negative reviews need responses`,
            data: { reviews: unrespondedReviews }
          });
        }
        if (recentReviews.length >= 5) {
          const recentAverage = recentReviews.reduce((sum2, r) => sum2 + r.rating, 0) / recentReviews.length;
          const overallAverage = reviews2.reduce((sum2, r) => sum2 + r.rating, 0) / reviews2.length;
          if (recentAverage < overallAverage - 1) {
            alerts.push({
              type: "rating_drop",
              severity: "medium",
              message: `Recent average rating (${recentAverage.toFixed(1)}) is significantly lower than overall (${overallAverage.toFixed(1)})`,
              data: { recentAverage, overallAverage }
            });
          }
        }
        return { alerts };
      }
      /**
       * Get review response templates
       */
      getResponseTemplates(category) {
        if (category) {
          return this.reviewTemplates.filter((t) => t.category === category);
        }
        return this.reviewTemplates;
      }
      /**
       * Generate AI-powered response suggestion
       */
      async generateResponseSuggestion(reviewId, businessId) {
        const review = await storage.getGmbReviewById(reviewId);
        if (!review) {
          throw new Error("Review not found");
        }
        const business = await storage.getBusinessById(businessId);
        if (!business) {
          throw new Error("Business not found");
        }
        const sentiment = this.analyzeSentiment(review.comment || "");
        const templates = this.getResponseTemplates(sentiment.overall);
        if (templates.length === 0) {
          return {
            suggestion: "Thank you for your feedback. We appreciate you taking the time to share your experience.",
            confidence: 0.5,
            template: void 0
          };
        }
        const bestTemplate = templates.reduce(
          (best, current) => current.successRate > best.successRate ? current : best
        );
        let suggestion = bestTemplate.template;
        suggestion = suggestion.replace("{customer_name}", review.reviewerName || "valued customer");
        suggestion = suggestion.replace("{business_name}", business.name);
        suggestion = suggestion.replace("{contact_email}", business.email || "support@business.com");
        return {
          suggestion,
          confidence: bestTemplate.successRate,
          template: bestTemplate
        };
      }
      /**
       * Batch update review properties
       */
      async batchUpdateReviews(businessId, reviewIds, updates) {
        for (const reviewId of reviewIds) {
          const review = await storage.getGmbReviewById(reviewId);
          if (review && review.businessId === businessId) {
            await storage.updateGmbReview(reviewId, updates);
          }
        }
      }
      /**
       * Export reviews to CSV
       */
      async exportReviews(businessId, options) {
        const reviews2 = await storage.getGmbReviewsByBusiness(businessId);
        let filteredReviews = reviews2;
        if (options.dateRange) {
          filteredReviews = reviews2.filter(
            (r) => r.reviewTime >= options.dateRange.start && r.reviewTime <= options.dateRange.end
          );
        }
        if (options.format === "json") {
          return JSON.stringify(filteredReviews, null, 2);
        }
        const headers = ["Date", "Reviewer", "Rating", "Comment"];
        if (options.includeReplies) {
          headers.push("Reply", "Reply Date");
        }
        const rows = filteredReviews.map((r) => {
          const row = [
            r.reviewTime.toISOString(),
            r.reviewerName,
            r.rating.toString(),
            `"${(r.comment || "").replace(/"/g, '""')}"`
          ];
          if (options.includeReplies) {
            row.push(
              r.replyComment ? `"${r.replyComment.replace(/"/g, '""')}"` : "",
              r.replyTime ? r.replyTime.toISOString() : ""
            );
          }
          return row.join(",");
        });
        return [headers.join(","), ...rows].join("\n");
      }
      /**
       * Helper: Analyze sentiment of review text
       */
      analyzeSentiment(text2) {
        const lowerText = text2.toLowerCase();
        const words = lowerText.split(/\s+/);
        let positiveScore = 0;
        let negativeScore = 0;
        const foundKeywords = [];
        words.forEach((word) => {
          if (this.sentimentKeywords.positive.includes(word)) {
            positiveScore++;
            foundKeywords.push(word);
          }
          if (this.sentimentKeywords.negative.includes(word)) {
            negativeScore++;
            foundKeywords.push(word);
          }
        });
        const totalScore = positiveScore - negativeScore;
        const normalizedScore = Math.max(-1, Math.min(1, totalScore / Math.max(words.length / 10, 1)));
        let overall;
        if (normalizedScore > 0.2) {
          overall = "positive";
        } else if (normalizedScore < -0.2) {
          overall = "negative";
        } else {
          overall = "neutral";
        }
        const topics = this.extractTopics(text2);
        return {
          overall,
          score: normalizedScore,
          keywords: foundKeywords,
          topics
        };
      }
      /**
       * Helper: Extract topics from review text
       */
      extractTopics(text2) {
        const commonTopics = [
          "service",
          "quality",
          "price",
          "location",
          "staff",
          "food",
          "cleanliness",
          "delivery",
          "product",
          "experience",
          "atmosphere",
          "value",
          "selection"
        ];
        const lowerText = text2.toLowerCase();
        return commonTopics.filter((topic) => lowerText.includes(topic));
      }
      /**
       * Helper: Extract tags from review text
       */
      extractTags(text2) {
        const tags = /* @__PURE__ */ new Set();
        if (/fast|quick|slow|wait/i.test(text2)) tags.add("service-speed");
        if (/friendly|rude|helpful|staff/i.test(text2)) tags.add("staff");
        if (/clean|dirty|hygiene/i.test(text2)) tags.add("cleanliness");
        if (/price|expensive|cheap|value/i.test(text2)) tags.add("pricing");
        if (/quality|excellent|poor/i.test(text2)) tags.add("quality");
        return Array.from(tags);
      }
      /**
       * Helper: Parse GMB star rating enum
       */
      parseStarRating(starRating) {
        const ratingMap = {
          "ONE": 1,
          "TWO": 2,
          "THREE": 3,
          "FOUR": 4,
          "FIVE": 5
        };
        return ratingMap[starRating] || 0;
      }
      /**
       * Helper: Get most common sentiment
       */
      getMostCommonSentiment(sentiments) {
        const counts = sentiments.reduce((acc, s) => {
          acc[s] = (acc[s] || 0) + 1;
          return acc;
        }, {});
        let maxCount = 0;
        let mostCommon = "neutral";
        Object.entries(counts).forEach(([sentiment, count2]) => {
          if (count2 > maxCount) {
            maxCount = count2;
            mostCommon = sentiment;
          }
        });
        return mostCommon;
      }
    };
    gmbReviewService = new GMBReviewService();
  }
});

// server/gmbPostService.ts
var GMBPostService, gmbPostService;
var init_gmbPostService = __esm({
  "server/gmbPostService.ts"() {
    "use strict";
    init_gmbService();
    init_gmbErrorHandler();
    init_storage();
    GMBPostService = class {
      constructor() {
        this.postTemplates = [
          {
            id: "new_product",
            name: "New Product Announcement",
            type: "PRODUCT",
            title: "New Product Available!",
            summaryTemplate: "Introducing our latest {product_name}! {product_description} Available now in-store and online.",
            callToAction: {
              actionType: "SHOP",
              urlTemplate: "{website_url}/products/{product_id}"
            },
            tags: ["product", "new", "announcement"],
            usageCount: 0
          },
          {
            id: "special_offer",
            name: "Limited Time Offer",
            type: "OFFER",
            title: "Special Offer!",
            summaryTemplate: "Get {discount}% off on {product_category}! Use code {coupon_code} at checkout. Valid until {expiry_date}.",
            callToAction: {
              actionType: "GET_OFFER",
              urlTemplate: "{website_url}/offers"
            },
            tags: ["offer", "discount", "promotion"],
            usageCount: 0
          },
          {
            id: "upcoming_event",
            name: "Event Announcement",
            type: "EVENT",
            title: "Join Us!",
            summaryTemplate: "Join us for {event_name} on {event_date}! {event_description} Limited seats available.",
            callToAction: {
              actionType: "SIGN_UP",
              urlTemplate: "{website_url}/events/{event_id}"
            },
            tags: ["event", "announcement"],
            usageCount: 0
          },
          {
            id: "business_update",
            name: "Business Update",
            type: "STANDARD",
            summaryTemplate: "{update_message} Visit us today to learn more!",
            callToAction: {
              actionType: "LEARN_MORE",
              urlTemplate: "{website_url}"
            },
            tags: ["update", "news"],
            usageCount: 0
          }
        ];
        this.scheduledPosts = /* @__PURE__ */ new Map();
      }
      /**
       * Create a new GMB post
       */
      async createPost(businessId, postData) {
        const business = await storage.getBusinessById(businessId);
        if (!business?.gmbConnected) {
          throw new Error("Business is not connected to Google My Business");
        }
        const post = {
          id: `post_${Date.now()}_${businessId}`,
          businessId,
          type: postData.type,
          status: postData.scheduledDate ? "SCHEDULED" : "DRAFT",
          title: postData.title,
          summary: postData.summary,
          mediaUrls: postData.mediaUrls,
          callToAction: postData.callToAction,
          event: postData.event,
          offer: postData.offer,
          scheduledDate: postData.scheduledDate,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (postData.scheduledDate) {
          await this.schedulePost(post);
        } else {
          await this.publishPost(post.id);
        }
        return post;
      }
      /**
       * Publish a post to GMB
       */
      async publishPost(postId) {
        const post = await this.getPostById(postId);
        if (!post) {
          throw new Error("Post not found");
        }
        const business = await storage.getBusinessById(post.businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("Business GMB configuration not found");
        }
        return await gmbErrorHandler.withRetry(async () => {
          const accessToken = await gmbService.getValidAccessToken(post.businessId);
          const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
          const payload = this.buildPostPayload(post);
          const response = await fetch(
            `https://mybusinessbusinessinformation.googleapis.com/v1/${locationName}/localPosts`,
            {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify(payload)
            }
          );
          if (!response.ok) {
            const error = await response.text();
            throw new Error(`Failed to create GMB post: ${error}`);
          }
          const result = await response.json();
          post.gmbPostId = result.name;
          post.status = "PUBLISHED";
          post.publishedDate = /* @__PURE__ */ new Date();
          if (post.type === "OFFER" && post.offer) {
            post.expiryDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3);
          } else if (post.type === "EVENT" && post.event) {
            post.expiryDate = post.event.endDate;
          }
          await storage.createGmbSyncHistory({
            businessId: post.businessId,
            syncType: "post_publish",
            status: "success",
            dataTypes: ["post"],
            changes: { postId: post.id, gmbPostId: post.gmbPostId },
            errorDetails: null,
            itemsProcessed: 1,
            itemsUpdated: 1,
            itemsErrors: 0,
            durationMs: null,
            triggeredBy: "manual",
            gmbApiVersion: "v4.9"
          });
        }, { maxRetries: 2 }, { businessId: post.businessId, operation: "publish_post" });
      }
      /**
       * Update an existing GMB post
       */
      async updatePost(postId, updates) {
        const post = await this.getPostById(postId);
        if (!post) {
          throw new Error("Post not found");
        }
        if (post.status === "PUBLISHED" && post.gmbPostId) {
          await this.updateGMBPost(post, updates);
        }
        Object.assign(post, updates, { updatedAt: /* @__PURE__ */ new Date() });
        return post;
      }
      /**
       * Delete a GMB post
       */
      async deletePost(postId) {
        const post = await this.getPostById(postId);
        if (!post) {
          throw new Error("Post not found");
        }
        if (post.status === "PUBLISHED" && post.gmbPostId) {
          const business = await storage.getBusinessById(post.businessId);
          if (!business?.gmbAccountId || !business?.gmbLocationId) {
            throw new Error("Business GMB configuration not found");
          }
          await gmbErrorHandler.withRetry(async () => {
            const accessToken = await gmbService.getValidAccessToken(post.businessId);
            const response = await fetch(
              `https://mybusinessbusinessinformation.googleapis.com/v1/${post.gmbPostId}`,
              {
                method: "DELETE",
                headers: {
                  "Authorization": `Bearer ${accessToken}`
                }
              }
            );
            if (!response.ok) {
              throw new Error(`Failed to delete GMB post: ${response.statusText}`);
            }
          }, { maxRetries: 2 }, { businessId: post.businessId, operation: "delete_post" });
        }
        if (post.status === "SCHEDULED") {
          this.cancelScheduledPost(postId);
        }
        post.status = "EXPIRED";
      }
      /**
       * Schedule a post for future publication
       */
      async schedulePost(post) {
        if (!post.scheduledDate) {
          throw new Error("Scheduled date is required");
        }
        const delay = post.scheduledDate.getTime() - Date.now();
        if (delay <= 0) {
          await this.publishPost(post.id);
          return;
        }
        const timeout = setTimeout(async () => {
          try {
            await this.publishPost(post.id);
            this.scheduledPosts.delete(post.id);
          } catch (error) {
            console.error(`Failed to publish scheduled post ${post.id}:`, error);
            post.status = "FAILED";
            await storage.createGmbSyncHistory({
              businessId: post.businessId,
              syncType: "post_schedule_failed",
              status: "error",
              dataTypes: ["post"],
              changes: null,
              errorDetails: error.message,
              itemsProcessed: 1,
              itemsUpdated: 0,
              itemsErrors: 1,
              durationMs: null,
              triggeredBy: "scheduled",
              gmbApiVersion: "v4.9"
            });
          }
        }, delay);
        this.scheduledPosts.set(post.id, timeout);
      }
      /**
       * Cancel a scheduled post
       */
      cancelScheduledPost(postId) {
        const timeout = this.scheduledPosts.get(postId);
        if (timeout) {
          clearTimeout(timeout);
          this.scheduledPosts.delete(postId);
        }
      }
      /**
       * Get post performance metrics from GMB
       */
      async getPostMetrics(postId) {
        const post = await this.getPostById(postId);
        if (!post || !post.gmbPostId) {
          throw new Error("Post not found or not published");
        }
        return await gmbErrorHandler.withRetry(async () => {
          const accessToken = await gmbService.getValidAccessToken(post.businessId);
          const response = await fetch(
            `https://mybusinessbusinessinformation.googleapis.com/v1/${post.gmbPostId}/insights`,
            {
              headers: {
                "Authorization": `Bearer ${accessToken}`
              }
            }
          );
          if (!response.ok) {
            throw new Error(`Failed to fetch post metrics: ${response.statusText}`);
          }
          const data = await response.json();
          const metrics = {
            views: data.metricValues?.find((m) => m.metric === "LOCAL_POST_VIEWS_SEARCH")?.totalValue?.value || 0,
            clicks: data.metricValues?.find((m) => m.metric === "LOCAL_POST_ACTIONS_CALL_TO_ACTION")?.totalValue?.value || 0,
            callClicks: data.metricValues?.find((m) => m.metric === "LOCAL_POST_ACTIONS_CALL")?.totalValue?.value || 0,
            directionClicks: data.metricValues?.find((m) => m.metric === "LOCAL_POST_ACTIONS_DIRECTIONS")?.totalValue?.value || 0,
            websiteClicks: data.metricValues?.find((m) => m.metric === "LOCAL_POST_ACTIONS_WEBSITE")?.totalValue?.value || 0,
            lastUpdated: /* @__PURE__ */ new Date()
          };
          post.metrics = metrics;
          return metrics;
        }, { maxRetries: 3 }, { businessId: post.businessId, operation: "get_post_metrics" });
      }
      /**
       * Get all posts for a business
       */
      async getBusinessPosts(businessId, options = {}) {
        const mockPosts = [
          {
            id: `post_1_${businessId}`,
            businessId,
            type: "STANDARD",
            status: "PUBLISHED",
            title: "Summer Sale!",
            summary: "Get 20% off all items this weekend only!",
            publishedDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1e3),
            metrics: {
              views: 1250,
              clicks: 87,
              callClicks: 12,
              directionClicks: 23,
              websiteClicks: 52,
              lastUpdated: /* @__PURE__ */ new Date()
            },
            createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1e3),
            updatedAt: /* @__PURE__ */ new Date()
          },
          {
            id: `post_2_${businessId}`,
            businessId,
            type: "EVENT",
            status: "SCHEDULED",
            title: "Grand Opening Event",
            summary: "Join us for our grand opening celebration!",
            event: {
              title: "Grand Opening",
              startDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3),
              endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3 + 4 * 60 * 60 * 1e3)
            },
            scheduledDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1e3),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        ];
        return {
          posts: mockPosts,
          total: mockPosts.length
        };
      }
      /**
       * Get post templates
       */
      getPostTemplates(type) {
        if (type) {
          return this.postTemplates.filter((t) => t.type === type);
        }
        return this.postTemplates;
      }
      /**
       * Generate post content using AI
       */
      async generatePostContent(businessId, options) {
        const business = await storage.getBusinessById(businessId);
        if (!business) {
          throw new Error("Business not found");
        }
        const tone = options.tone || "professional";
        const maxLength = options.maxLength || 1500;
        let title;
        let summary;
        let callToAction;
        switch (options.type) {
          case "OFFER":
            title = options.includeEmoji ? "\u{1F389} Special Offer!" : "Special Offer";
            summary = this.generateOfferContent(business.name, options.topic, tone);
            callToAction = {
              actionType: "GET_OFFER",
              url: business.website
            };
            break;
          case "EVENT":
            title = options.includeEmoji ? "\u{1F4C5} Upcoming Event" : "Join Us!";
            summary = this.generateEventContent(business.name, options.topic, tone);
            callToAction = {
              actionType: "SIGN_UP",
              url: business.website
            };
            break;
          case "PRODUCT":
            title = options.includeEmoji ? "\u2728 New Product" : "New Arrival";
            summary = this.generateProductContent(business.name, options.topic, tone);
            callToAction = {
              actionType: "SHOP",
              url: business.website
            };
            break;
          default:
            summary = this.generateStandardContent(business.name, options.topic, tone);
            callToAction = {
              actionType: "LEARN_MORE",
              url: business.website
            };
        }
        if (summary.length > maxLength) {
          summary = summary.substring(0, maxLength - 3) + "...";
        }
        return { title, summary, callToAction };
      }
      /**
       * Batch create multiple posts
       */
      async batchCreatePosts(businessId, posts2) {
        const createdPosts = [];
        const errors = [];
        for (const postData of posts2) {
          try {
            const post = await this.createPost(businessId, {
              type: postData.type || "STANDARD",
              title: postData.title,
              summary: postData.summary || "",
              mediaUrls: postData.mediaUrls,
              callToAction: postData.callToAction,
              event: postData.event,
              offer: postData.offer,
              scheduledDate: postData.scheduledDate
            });
            createdPosts.push(post);
          } catch (error) {
            errors.push({
              post: postData,
              error: error.message
            });
          }
        }
        if (errors.length > 0) {
          console.error("Batch post creation errors:", errors);
        }
        return createdPosts;
      }
      /**
       * Get post analytics summary
       */
      async getPostAnalytics(businessId, dateRange) {
        const { posts: posts2 } = await this.getBusinessPosts(businessId, { dateRange });
        let totalViews = 0;
        let totalClicks = 0;
        const postsByType = {
          "STANDARD": 0,
          "EVENT": 0,
          "OFFER": 0,
          "PRODUCT": 0,
          "COVID_UPDATE": 0
        };
        posts2.forEach((post) => {
          if (post.metrics) {
            totalViews += post.metrics.views;
            totalClicks += post.metrics.clicks;
          }
          postsByType[post.type]++;
        });
        const averageEngagementRate = totalViews > 0 ? totalClicks / totalViews * 100 : 0;
        const topPerformingPosts = posts2.filter((p) => p.metrics).sort((a, b) => (b.metrics?.views || 0) - (a.metrics?.views || 0)).slice(0, 5);
        const performanceByDay = [];
        const currentDate = new Date(dateRange.start);
        while (currentDate <= dateRange.end) {
          performanceByDay.push({
            date: currentDate.toISOString().split("T")[0],
            views: Math.floor(Math.random() * 500),
            clicks: Math.floor(Math.random() * 50)
          });
          currentDate.setDate(currentDate.getDate() + 1);
        }
        return {
          totalPosts: posts2.length,
          totalViews,
          totalClicks,
          averageEngagementRate,
          topPerformingPosts,
          postsByType,
          performanceByDay
        };
      }
      /**
       * Helper: Build GMB post payload
       */
      buildPostPayload(post) {
        const payload = {
          languageCode: "en",
          summary: post.summary,
          topicType: this.mapPostTypeToTopic(post.type)
        };
        if (post.title) {
          payload.title = post.title;
        }
        if (post.mediaUrls && post.mediaUrls.length > 0) {
          payload.media = post.mediaUrls.map((url) => ({
            mediaFormat: "PHOTO",
            sourceUrl: url
          }));
        }
        if (post.callToAction) {
          payload.callToAction = {
            actionType: post.callToAction.actionType,
            url: post.callToAction.url
          };
        }
        if (post.type === "EVENT" && post.event) {
          payload.event = {
            title: post.event.title,
            schedule: {
              startDate: post.event.startDate.toISOString().split("T")[0],
              endDate: post.event.endDate.toISOString().split("T")[0]
            }
          };
        }
        if (post.type === "OFFER" && post.offer) {
          payload.offer = {
            couponCode: post.offer.couponCode,
            redeemOnlineUrl: post.offer.redeemOnlineUrl,
            termsConditions: post.offer.termsConditions
          };
        }
        return payload;
      }
      /**
       * Helper: Map post type to GMB topic type
       */
      mapPostTypeToTopic(type) {
        const mapping = {
          "STANDARD": "STANDARD",
          "EVENT": "EVENT",
          "OFFER": "OFFER",
          "PRODUCT": "PRODUCT",
          "COVID_UPDATE": "COVID_19"
        };
        return mapping[type] || "STANDARD";
      }
      /**
       * Helper: Update GMB post
       */
      async updateGMBPost(post, updates) {
        if (!post.gmbPostId) return;
        const business = await storage.getBusinessById(post.businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("Business GMB configuration not found");
        }
        await gmbErrorHandler.withRetry(async () => {
          const accessToken = await gmbService.getValidAccessToken(post.businessId);
          const updateMask = [];
          const payload = {};
          if (updates.summary !== void 0) {
            updateMask.push("summary");
            payload.summary = updates.summary;
          }
          if (updates.callToAction !== void 0) {
            updateMask.push("call_to_action");
            payload.callToAction = updates.callToAction;
          }
          const response = await fetch(
            `https://mybusinessbusinessinformation.googleapis.com/v1/${post.gmbPostId}?updateMask=${updateMask.join(",")}`,
            {
              method: "PATCH",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify(payload)
            }
          );
          if (!response.ok) {
            throw new Error(`Failed to update GMB post: ${response.statusText}`);
          }
        }, { maxRetries: 2 }, { businessId: post.businessId, operation: "update_post" });
      }
      /**
       * Helper: Get post by ID (mock implementation)
       */
      async getPostById(postId) {
        return {
          id: postId,
          businessId: "mock-business-id",
          type: "STANDARD",
          status: "DRAFT",
          summary: "Mock post content",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      /**
       * Helper: Generate offer content
       */
      generateOfferContent(businessName, topic, tone) {
        const templates = {
          professional: `We're pleased to announce a special offer at ${businessName}. ${topic}. Visit us today to take advantage of this limited-time opportunity.`,
          casual: `Hey! Check out this awesome deal at ${businessName}! ${topic}. Don't miss out!`,
          friendly: `Great news from ${businessName}! ${topic}. We'd love to see you soon!`,
          urgent: `LIMITED TIME! ${businessName} presents: ${topic}. Act fast - this offer won't last long!`
        };
        return templates[tone] || templates.professional;
      }
      /**
       * Helper: Generate event content
       */
      generateEventContent(businessName, topic, tone) {
        const templates = {
          professional: `${businessName} cordially invites you to ${topic}. We look forward to your attendance at this special event.`,
          casual: `Join us at ${businessName} for ${topic}! It's going to be great!`,
          friendly: `You're invited! ${businessName} is hosting ${topic}. We can't wait to see you there!`,
          urgent: `Don't miss out! ${businessName} presents ${topic}. RSVP now - limited spaces available!`
        };
        return templates[tone] || templates.professional;
      }
      /**
       * Helper: Generate product content
       */
      generateProductContent(businessName, topic, tone) {
        const templates = {
          professional: `${businessName} is proud to introduce ${topic}. Experience quality and innovation in our latest offering.`,
          casual: `New at ${businessName}: ${topic}! Come check it out!`,
          friendly: `Exciting news! ${businessName} just launched ${topic}. We think you'll love it!`,
          urgent: `NOW AVAILABLE at ${businessName}: ${topic}. Get yours before they're gone!`
        };
        return templates[tone] || templates.professional;
      }
      /**
       * Helper: Generate standard content
       */
      generateStandardContent(businessName, topic, tone) {
        const templates = {
          professional: `${businessName} update: ${topic}. Thank you for your continued support.`,
          casual: `Hey from ${businessName}! ${topic} Drop by when you can!`,
          friendly: `Hello from ${businessName}! ${topic} We appreciate your business!`,
          urgent: `Important update from ${businessName}: ${topic}. Please take note!`
        };
        return templates[tone] || templates.professional;
      }
    };
    gmbPostService = new GMBPostService();
  }
});

// server/gmbInsightsService.ts
var GMBInsightsService, gmbInsightsService;
var init_gmbInsightsService = __esm({
  "server/gmbInsightsService.ts"() {
    "use strict";
    init_gmbService();
    init_gmbErrorHandler();
    init_storage();
    GMBInsightsService = class {
      constructor() {
        this.metricsCache = /* @__PURE__ */ new Map();
        this.cacheTimeout = 60 * 60 * 1e3;
      }
      // 1 hour
      /**
       * Fetch comprehensive insights for a business location
       */
      async fetchLocationInsights(businessId, options) {
        const business = await storage.getBusinessById(businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("Business is not connected to Google My Business");
        }
        const cacheKey = `insights_${businessId}_${options.dateRange.start.toISOString()}_${options.dateRange.end.toISOString()}`;
        const cached = this.getCachedData(cacheKey);
        if (cached) {
          return cached;
        }
        return await gmbErrorHandler.withRetry(async () => {
          const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
          const [queries, views, actions, photos, searchQueries] = await Promise.all([
            this.fetchQueryMetrics(businessId, locationName, options.dateRange),
            this.fetchViewMetrics(businessId, locationName, options.dateRange),
            this.fetchActionMetrics(businessId, locationName, options.dateRange),
            this.fetchPhotoMetrics(businessId, locationName, options.dateRange),
            this.fetchTopSearchQueries(businessId, locationName)
          ]);
          const trends = this.analyzeTrends(queries, views, actions);
          const recommendations = this.generateRecommendations({
            queries,
            views,
            actions,
            photos,
            trends
          });
          const insights = {
            businessId,
            dateRange: options.dateRange,
            metrics: {
              queries,
              views,
              actions,
              photos
            },
            topSearchQueries: searchQueries,
            trends,
            recommendations,
            lastUpdated: /* @__PURE__ */ new Date()
          };
          if (options.includeCompetitors) {
            insights.competitorAnalysis = await this.fetchCompetitorMetrics(businessId, business.category || "");
          }
          this.setCachedData(cacheKey, insights);
          await this.storeInsights(businessId, insights);
          return insights;
        }, { maxRetries: 3 }, { businessId, operation: "fetch_insights" });
      }
      /**
       * Fetch specific metric data
       */
      async fetchMetricData(businessId, metricType, dateRange) {
        const business = await storage.getBusinessById(businessId);
        if (!business?.gmbAccountId || !business?.gmbLocationId) {
          throw new Error("Business is not connected to Google My Business");
        }
        return await gmbErrorHandler.withRetry(async () => {
          const accessToken = await gmbService.getValidAccessToken(businessId);
          const locationName = `accounts/${business.gmbAccountId}/locations/${business.gmbLocationId}`;
          const response = await fetch(
            `https://mybusiness.googleapis.com/v4/${locationName}/insights`,
            {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                locationNames: [locationName],
                basicRequest: {
                  metricRequests: [{
                    metric: metricType,
                    options: ["AGGREGATED_DAILY"]
                  }],
                  timeRange: {
                    startTime: dateRange.start.toISOString(),
                    endTime: dateRange.end.toISOString()
                  }
                }
              })
            }
          );
          if (!response.ok) {
            throw new Error(`Failed to fetch metric data: ${response.statusText}`);
          }
          const data = await response.json();
          return this.parseMetricResponse(data);
        }, { maxRetries: 3 }, { businessId, operation: "fetch_metric", metricType });
      }
      /**
       * Generate performance report
       */
      async generateReport(businessId, options) {
        const dateRange = options.dateRange || this.getDateRangeForReportType(options.reportType);
        const insights = await this.fetchLocationInsights(businessId, {
          dateRange,
          includeCompetitors: true
        });
        const summary = this.calculateReportSummary(insights);
        const report = {
          id: `report_${Date.now()}_${businessId}`,
          businessId,
          reportType: options.reportType,
          dateGenerated: /* @__PURE__ */ new Date(),
          insights,
          summary
        };
        if (options.format && options.format !== "json") {
          report.exportUrl = await this.exportReport(report, options.format);
        }
        return report;
      }
      /**
       * Track performance over time
       */
      async trackPerformanceTrend(businessId, metricType, periods = 12) {
        const endDate = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        startDate.setMonth(startDate.getMonth() - periods);
        const metricData = await this.fetchMetricData(businessId, metricType, {
          start: startDate,
          end: endDate
        });
        const periodData = this.groupMetricsByPeriod(metricData, "monthly");
        const trendData = periodData.map((period, index2) => {
          const previousPeriod = periodData[index2 - 1];
          const change = previousPeriod ? (period.value - previousPeriod.value) / previousPeriod.value * 100 : 0;
          return {
            period: period.period,
            value: period.value,
            change
          };
        });
        const trend = this.calculateOverallTrend(trendData);
        const forecast = this.generateForecast(trendData);
        return { trend, data: trendData, forecast };
      }
      /**
       * Compare performance across multiple locations
       */
      async compareLocations(businessIds, dateRange) {
        const locationData = await Promise.all(
          businessIds.map(async (id) => {
            const business = await storage.getBusinessById(id);
            const insights2 = await this.fetchLocationInsights(id, { dateRange });
            return {
              businessId: id,
              name: business?.name || "Unknown",
              metrics: {
                views: insights2.metrics.views.total,
                actions: insights2.metrics.actions.total,
                conversionRate: insights2.metrics.actions.conversionRate
              },
              rank: 0
              // Will be calculated
            };
          })
        );
        locationData.sort((a, b) => b.metrics.conversionRate - a.metrics.conversionRate);
        locationData.forEach((loc, index2) => {
          loc.rank = index2 + 1;
        });
        const insights = this.generateComparativeInsights(locationData);
        return {
          locations: locationData,
          bestPerformer: locationData[0].businessId,
          insights
        };
      }
      /**
       * Set up automated reporting
       */
      async scheduleAutomatedReports(businessId, config2) {
        const scheduleId = `schedule_${Date.now()}_${businessId}`;
        const nextRun = this.calculateNextRunTime(config2.frequency);
        return { scheduleId, nextRun };
      }
      /**
       * Get actionable insights based on current performance
       */
      async getActionableInsights(businessId) {
        const dateRange = {
          start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
          end: /* @__PURE__ */ new Date()
        };
        const insights = await this.fetchLocationInsights(businessId, { dateRange });
        const immediate = insights.recommendations.filter((r) => r.priority === "high");
        const shortTerm = insights.recommendations.filter((r) => r.priority === "medium");
        const longTerm = insights.recommendations.filter((r) => r.priority === "low");
        return { immediate, shortTerm, longTerm };
      }
      /**
       * Helper: Fetch query metrics
       */
      async fetchQueryMetrics(businessId, locationName, dateRange) {
        const mockData = this.generateMockMetricData(dateRange, 100, 500);
        return {
          direct: mockData,
          indirect: this.generateMockMetricData(dateRange, 200, 800),
          chain: this.generateMockMetricData(dateRange, 10, 50),
          total: mockData.reduce((sum2, m) => sum2 + m.value, 0),
          growthRate: 15.5
        };
      }
      /**
       * Helper: Fetch view metrics
       */
      async fetchViewMetrics(businessId, locationName, dateRange) {
        const mapsViews = this.generateMockMetricData(dateRange, 500, 2e3);
        const searchViews = this.generateMockMetricData(dateRange, 1e3, 5e3);
        return {
          maps: mapsViews,
          search: searchViews,
          total: mapsViews.reduce((sum2, m) => sum2 + m.value, 0) + searchViews.reduce((sum2, m) => sum2 + m.value, 0),
          growthRate: 22.3
        };
      }
      /**
       * Helper: Fetch action metrics
       */
      async fetchActionMetrics(businessId, locationName, dateRange) {
        const websiteClicks = this.generateMockMetricData(dateRange, 50, 200);
        const phoneCalls = this.generateMockMetricData(dateRange, 20, 100);
        const directions = this.generateMockMetricData(dateRange, 30, 150);
        const totalActions = websiteClicks.reduce((sum2, m) => sum2 + m.value, 0) + phoneCalls.reduce((sum2, m) => sum2 + m.value, 0) + directions.reduce((sum2, m) => sum2 + m.value, 0);
        return {
          website: websiteClicks,
          phone: phoneCalls,
          directions,
          total: totalActions,
          conversionRate: 8.5
        };
      }
      /**
       * Helper: Fetch photo metrics
       */
      async fetchPhotoMetrics(businessId, locationName, dateRange) {
        return {
          merchantViews: this.generateMockMetricData(dateRange, 100, 500),
          customerViews: this.generateMockMetricData(dateRange, 200, 1e3),
          merchantCount: 45,
          customerCount: 123,
          engagementRate: 12.8
        };
      }
      /**
       * Helper: Fetch top search queries
       */
      async fetchTopSearchQueries(businessId, locationName) {
        return [
          { query: "restaurant near me", impressions: 5420, clicks: 432, ctr: 7.96, averagePosition: 2.3 },
          { query: "best italian food", impressions: 3210, clicks: 298, ctr: 9.28, averagePosition: 1.8 },
          { query: "pizza delivery", impressions: 2890, clicks: 245, ctr: 8.48, averagePosition: 3.1 },
          { query: "lunch specials", impressions: 1560, clicks: 178, ctr: 11.41, averagePosition: 2.5 },
          { query: "outdoor dining", impressions: 980, clicks: 89, ctr: 9.08, averagePosition: 4.2 }
        ];
      }
      /**
       * Helper: Fetch competitor metrics
       */
      async fetchCompetitorMetrics(businessId, category) {
        return {
          averageRating: 4.2,
          totalReviews: 156,
          responseRate: 65,
          photoCount: 38,
          marketShare: 18.5
        };
      }
      /**
       * Helper: Analyze trends
       */
      analyzeTrends(queries, views, actions) {
        return {
          peakDays: ["Saturday", "Sunday"],
          peakHours: [12, 13, 18, 19],
          seasonalPatterns: [
            { period: "Weekend", impact: "high", description: "Traffic increases 40% on weekends" },
            { period: "Summer", impact: "medium", description: "Seasonal boost in outdoor dining searches" }
          ],
          growthTrend: queries.growthRate > 0 ? "increasing" : queries.growthRate < -5 ? "declining" : "stable",
          anomalies: []
        };
      }
      /**
       * Helper: Generate recommendations
       */
      generateRecommendations(data) {
        const recommendations = [];
        if (data.photos.merchantCount < 20) {
          recommendations.push({
            category: "content",
            priority: "high",
            title: "Add More Photos",
            description: "Your business has fewer photos than 80% of similar businesses",
            potentialImpact: "Could increase views by up to 30%",
            actionItems: [
              "Upload high-quality photos of your products/services",
              "Add photos of your team and workspace",
              "Include seasonal and event photos"
            ]
          });
        }
        if (data.actions.conversionRate < 5) {
          recommendations.push({
            category: "conversion",
            priority: "medium",
            title: "Improve Call-to-Actions",
            description: "Your conversion rate is below industry average",
            potentialImpact: "Could increase customer actions by 20%",
            actionItems: [
              "Add clear business hours",
              "Enable messaging features",
              "Update your website link",
              "Add booking/ordering links"
            ]
          });
        }
        const reviewResponseRate = 75;
        if (reviewResponseRate < 80) {
          recommendations.push({
            category: "engagement",
            priority: "high",
            title: "Respond to More Reviews",
            description: "Responding to reviews improves customer trust",
            potentialImpact: "Can improve rating by 0.2-0.5 stars",
            actionItems: [
              "Respond to all reviews within 48 hours",
              "Thank customers for positive reviews",
              "Address concerns in negative reviews professionally"
            ]
          });
        }
        return recommendations;
      }
      /**
       * Helper: Store insights in database
       */
      async storeInsights(businessId, insights) {
        await storage.createGmbSyncHistory({
          businessId,
          syncType: "insights_fetch",
          status: "success",
          dataTypes: ["insights"],
          changes: {
            totalViews: insights.metrics.views.total,
            totalActions: insights.metrics.actions.total
          },
          errorDetails: null,
          itemsProcessed: 1,
          itemsUpdated: 1,
          itemsErrors: 0,
          durationMs: null,
          triggeredBy: "manual",
          gmbApiVersion: "v4.9"
        });
      }
      /**
       * Helper: Parse metric response from GMB API
       */
      parseMetricResponse(response) {
        const values = [];
        if (response.locationMetrics && response.locationMetrics[0]) {
          const metrics = response.locationMetrics[0].metricValues || [];
          metrics.forEach((metric) => {
            if (metric.dimensionalValues) {
              metric.dimensionalValues.forEach((dim) => {
                values.push({
                  date: new Date(dim.timeDimension.timeRange.startTime),
                  value: parseInt(dim.value) || 0
                });
              });
            }
          });
        }
        return values;
      }
      /**
       * Helper: Generate mock metric data
       */
      generateMockMetricData(dateRange, min, max) {
        const data = [];
        const currentDate = new Date(dateRange.start);
        while (currentDate <= dateRange.end) {
          data.push({
            date: new Date(currentDate),
            value: Math.floor(Math.random() * (max - min) + min),
            dayOfWeek: currentDate.getDay()
          });
          currentDate.setDate(currentDate.getDate() + 1);
        }
        return data;
      }
      /**
       * Helper: Calculate report summary
       */
      calculateReportSummary(insights) {
        const totalViews = insights.metrics.views.total;
        const totalActions = insights.metrics.actions.total;
        const conversionRate = insights.metrics.actions.conversionRate;
        let performanceScore = 50;
        if (conversionRate > 10) performanceScore += 20;
        if (totalViews > 5e3) performanceScore += 15;
        if (totalActions > 500) performanceScore += 15;
        return {
          highlights: [
            `${totalViews.toLocaleString()} total views this period`,
            `${conversionRate.toFixed(1)}% conversion rate`,
            `${insights.recommendations.length} recommendations for improvement`
          ],
          keyMetrics: {
            totalViews,
            totalActions,
            averageRating: 4.5,
            // Would come from review data
            conversionRate
          },
          performanceScore: Math.min(100, performanceScore),
          comparisonPeriod: {
            views: Math.floor(totalViews * 0.85),
            actions: Math.floor(totalActions * 0.82),
            change: 18.5
          }
        };
      }
      /**
       * Helper: Get date range for report type
       */
      getDateRangeForReportType(reportType) {
        const end = /* @__PURE__ */ new Date();
        const start = /* @__PURE__ */ new Date();
        switch (reportType) {
          case "daily":
            start.setDate(start.getDate() - 1);
            break;
          case "weekly":
            start.setDate(start.getDate() - 7);
            break;
          case "monthly":
            start.setMonth(start.getMonth() - 1);
            break;
        }
        return { start, end };
      }
      /**
       * Helper: Export report to specified format
       */
      async exportReport(report, format) {
        return `https://api.example.com/exports/${report.id}.${format}`;
      }
      /**
       * Helper: Group metrics by period
       */
      groupMetricsByPeriod(data, period) {
        const grouped = /* @__PURE__ */ new Map();
        data.forEach((metric) => {
          let key;
          switch (period) {
            case "daily":
              key = metric.date.toISOString().split("T")[0];
              break;
            case "weekly":
              key = `${metric.date.getFullYear()}-W${Math.ceil(metric.date.getDate() / 7)}`;
              break;
            case "monthly":
              key = `${metric.date.getFullYear()}-${String(metric.date.getMonth() + 1).padStart(2, "0")}`;
              break;
          }
          grouped.set(key, (grouped.get(key) || 0) + metric.value);
        });
        return Array.from(grouped.entries()).map(([period2, value]) => ({ period: period2, value }));
      }
      /**
       * Helper: Calculate overall trend
       */
      calculateOverallTrend(data) {
        const averageChange = data.reduce((sum2, d) => sum2 + d.change, 0) / data.length;
        if (averageChange > 5) return "improving";
        if (averageChange < -5) return "declining";
        return "stable";
      }
      /**
       * Helper: Generate forecast
       */
      generateForecast(data) {
        const lastValue = data[data.length - 1]?.value || 0;
        const trend = (data[data.length - 1]?.value - data[0]?.value) / data.length;
        const forecast = [];
        for (let i = 1; i <= 3; i++) {
          forecast.push({
            period: `Forecast +${i}`,
            value: Math.round(lastValue + trend * i),
            confidence: Math.max(0.5, 1 - i * 0.15)
          });
        }
        return forecast;
      }
      /**
       * Helper: Generate comparative insights
       */
      generateComparativeInsights(locations) {
        const insights = [];
        if (locations.length > 0) {
          const best = locations[0];
          const worst = locations[locations.length - 1];
          insights.push(`${best.name} has the highest conversion rate at ${best.metrics.conversionRate.toFixed(1)}%`);
          insights.push(`${worst.name} has opportunity for improvement with ${worst.metrics.conversionRate.toFixed(1)}% conversion`);
          const avgViews = locations.reduce((sum2, loc) => sum2 + loc.metrics.views, 0) / locations.length;
          insights.push(`Average views across all locations: ${Math.round(avgViews).toLocaleString()}`);
        }
        return insights;
      }
      /**
       * Helper: Calculate next run time
       */
      calculateNextRunTime(frequency) {
        const next = /* @__PURE__ */ new Date();
        switch (frequency) {
          case "daily":
            next.setDate(next.getDate() + 1);
            next.setHours(9, 0, 0, 0);
            break;
          case "weekly":
            next.setDate(next.getDate() + (8 - next.getDay()) % 7);
            next.setHours(9, 0, 0, 0);
            break;
          case "monthly":
            next.setMonth(next.getMonth() + 1);
            next.setDate(1);
            next.setHours(9, 0, 0, 0);
            break;
        }
        return next;
      }
      /**
       * Helper: Get cached data
       */
      getCachedData(key) {
        const cached = this.metricsCache.get(key);
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
          return cached.data;
        }
        return null;
      }
      /**
       * Helper: Set cached data
       */
      setCachedData(key, data) {
        this.metricsCache.set(key, {
          data,
          timestamp: Date.now()
        });
      }
    };
    gmbInsightsService = new GMBInsightsService();
  }
});

// server/gmbSyncService.ts
var GMBSyncService, gmbSyncService;
var init_gmbSyncService = __esm({
  "server/gmbSyncService.ts"() {
    "use strict";
    init_dataSyncService();
    init_gmbReviewService();
    init_gmbPostService();
    init_gmbInsightsService();
    init_storage();
    GMBSyncService = class {
      constructor() {
        this.activeSessions = /* @__PURE__ */ new Map();
        this.syncConfigurations = /* @__PURE__ */ new Map();
        this.syncSchedules = /* @__PURE__ */ new Map();
        this.webhookClients = /* @__PURE__ */ new Map();
      }
      /**
       * Initialize sync service with WebSocket support
       */
      initialize(socketServer) {
        this.io = socketServer;
        if (this.io) {
          this.io.on("connection", (socket) => {
            console.log("GMB Sync WebSocket client connected:", socket.id);
            socket.on("subscribe", (businessId) => {
              socket.join(`gmb_${businessId}`);
              console.log(`Client ${socket.id} subscribed to GMB updates for business ${businessId}`);
            });
            socket.on("unsubscribe", (businessId) => {
              socket.leave(`gmb_${businessId}`);
            });
            socket.on("disconnect", () => {
              console.log("GMB Sync WebSocket client disconnected:", socket.id);
            });
          });
        }
      }
      /**
       * Configure sync settings for a business
       */
      async configureSyncSettings(config2) {
        if (!config2.businessId) {
          throw new Error("Business ID is required");
        }
        const business = await storage.getBusinessById(config2.businessId);
        if (!business) {
          throw new Error("Business not found");
        }
        if (!business.gmbConnected) {
          throw new Error("Business is not connected to Google My Business");
        }
        this.syncConfigurations.set(config2.businessId, config2);
        if (config2.autoSync && config2.syncInterval) {
          await this.setupAutoSync(config2.businessId, config2.syncInterval);
        }
        if (config2.webhookEnabled && config2.webhookUrl) {
          this.webhookClients.set(config2.businessId, config2.webhookUrl);
        }
        await storage.createGmbSyncHistory({
          businessId: config2.businessId,
          syncType: "configuration",
          status: "success",
          dataTypes: Object.keys(config2.dataTypes).filter((k) => config2.dataTypes[k]),
          changes: { config: config2 },
          errorDetails: null,
          itemsProcessed: 0,
          itemsUpdated: 0,
          itemsErrors: 0,
          durationMs: null,
          triggeredBy: "manual",
          gmbApiVersion: "v4.9"
        });
      }
      /**
       * Start a sync session
       */
      async startSync(businessId, options = {}) {
        const existingSession = Array.from(this.activeSessions.values()).find((s) => s.businessId === businessId && s.status === "in_progress");
        if (existingSession && !options.force) {
          throw new Error("Sync already in progress for this business");
        }
        let config2 = this.syncConfigurations.get(businessId);
        if (!config2) {
          config2 = await this.getDefaultConfiguration(businessId);
        }
        const syncType = options.type || config2.syncType;
        const dataTypes = { ...config2.dataTypes, ...options.dataTypes };
        const session2 = {
          id: `sync_${Date.now()}_${businessId}`,
          businessId,
          startTime: /* @__PURE__ */ new Date(),
          status: "in_progress",
          type: syncType,
          progress: {
            total: 0,
            completed: 0,
            failed: 0,
            percentage: 0
          },
          dataChanges: {},
          errors: [],
          warnings: [],
          stats: {
            itemsProcessed: 0,
            itemsCreated: 0,
            itemsUpdated: 0,
            itemsDeleted: 0,
            itemsFailed: 0,
            dataTransferred: 0,
            apiCallsMade: 0,
            duration: 0
          }
        };
        this.activeSessions.set(session2.id, session2);
        this.emitSyncEvent("sync.started", session2);
        try {
          switch (syncType) {
            case "full":
              await this.performFullSync(session2, dataTypes, config2);
              break;
            case "incremental":
              await this.performIncrementalSync(session2, dataTypes, config2);
              break;
            case "selective":
              await this.performSelectiveSync(session2, dataTypes, config2);
              break;
            case "real-time":
              await this.performRealTimeSync(session2, dataTypes, config2);
              break;
          }
          session2.status = "completed";
          session2.endTime = /* @__PURE__ */ new Date();
          session2.stats.duration = session2.endTime.getTime() - session2.startTime.getTime();
          this.emitSyncEvent("sync.completed", session2);
        } catch (error) {
          session2.status = "failed";
          session2.endTime = /* @__PURE__ */ new Date();
          session2.stats.duration = session2.endTime.getTime() - session2.startTime.getTime();
          session2.errors.push({
            code: "SYNC_FAILED",
            message: error.message,
            dataType: "general",
            retryable: true,
            timestamp: /* @__PURE__ */ new Date()
          });
          this.emitSyncEvent("sync.failed", session2);
          if (config2.retryOnFailure && session2.errors.filter((e) => e.retryable).length > 0) {
            await this.retrySyncSession(session2.id, config2.maxRetries);
          }
          throw error;
        }
        return session2;
      }
      /**
       * Perform full sync
       */
      async performFullSync(session2, dataTypes, config2) {
        const tasks = [];
        let totalItems = 0;
        if (dataTypes.businessInfo) {
          totalItems += 5;
          tasks.push(this.syncBusinessInfo(session2, config2));
        }
        if (dataTypes.reviews) {
          totalItems += 50;
          tasks.push(this.syncReviews(session2, config2));
        }
        if (dataTypes.posts) {
          totalItems += 20;
          tasks.push(this.syncPosts(session2, config2));
        }
        if (dataTypes.photos) {
          totalItems += 30;
          tasks.push(this.syncPhotos(session2, config2));
        }
        if (dataTypes.insights) {
          totalItems += 10;
          tasks.push(this.syncInsights(session2, config2));
        }
        session2.progress.total = totalItems;
        await Promise.all(tasks);
      }
      /**
       * Perform incremental sync (changes since last sync)
       */
      async performIncrementalSync(session2, dataTypes, config2) {
        const lastSync = await this.getLastSyncTimestamp(session2.businessId);
        if (!lastSync) {
          return this.performFullSync(session2, dataTypes, config2);
        }
        const tasks = [];
        if (dataTypes.businessInfo) {
          tasks.push(this.syncBusinessInfoIncremental(session2, config2, lastSync));
        }
        if (dataTypes.reviews) {
          tasks.push(this.syncReviewsIncremental(session2, config2, lastSync));
        }
        if (dataTypes.posts) {
          tasks.push(this.syncPostsIncremental(session2, config2, lastSync));
        }
        await Promise.all(tasks);
      }
      /**
       * Perform selective sync (specific data items)
       */
      async performSelectiveSync(session2, dataTypes, config2) {
        return this.performFullSync(session2, dataTypes, config2);
      }
      /**
       * Perform real-time sync (continuous monitoring)
       */
      async performRealTimeSync(session2, dataTypes, config2) {
        await this.performFullSync(session2, dataTypes, config2);
        const checkInterval = setInterval(async () => {
          try {
            await this.checkForChanges(session2, config2);
          } catch (error) {
            console.error("Real-time sync check failed:", error);
            clearInterval(checkInterval);
          }
        }, 6e4);
        this.syncSchedules.set(`realtime_${session2.id}`, checkInterval);
      }
      /**
       * Sync business information
       */
      async syncBusinessInfo(session2, config2) {
        try {
          const result = await dataSyncService.performFullSync(session2.businessId, {
            syncBusinessInfo: true,
            syncPhotos: false,
            syncReviews: false,
            conflictResolution: config2.conflictStrategy
          });
          if (!session2.dataChanges.businessInfo) {
            session2.dataChanges.businessInfo = [];
          }
          if (result.syncSummary.businessInfoUpdated) {
            session2.dataChanges.businessInfo.push({
              field: "business_info",
              oldValue: null,
              newValue: result.syncSummary,
              source: "gmb",
              action: "update",
              timestamp: /* @__PURE__ */ new Date()
            });
          }
          session2.stats.itemsProcessed += 1;
          session2.stats.itemsUpdated += result.syncSummary.businessInfoUpdated ? 1 : 0;
          session2.progress.completed += 5;
          session2.progress.percentage = session2.progress.completed / session2.progress.total * 100;
          this.emitSyncEvent("sync.progress", session2);
        } catch (error) {
          session2.errors.push({
            code: "BUSINESS_INFO_SYNC_ERROR",
            message: error.message,
            dataType: "businessInfo",
            retryable: true,
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsFailed++;
          session2.progress.failed++;
        }
      }
      /**
       * Sync reviews
       */
      async syncReviews(session2, config2) {
        try {
          const { reviews: reviews2, totalReviews } = await gmbReviewService.fetchReviews(session2.businessId);
          if (!session2.dataChanges.reviews) {
            session2.dataChanges.reviews = [];
          }
          session2.dataChanges.reviews.push({
            field: "reviews",
            oldValue: null,
            newValue: { count: totalReviews },
            source: "gmb",
            action: "update",
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsProcessed += totalReviews;
          session2.stats.itemsCreated += reviews2.filter((r) => r.createdAt >= session2.startTime).length;
          session2.progress.completed += Math.min(50, totalReviews);
          session2.progress.percentage = session2.progress.completed / session2.progress.total * 100;
          this.emitSyncEvent("sync.progress", session2);
        } catch (error) {
          session2.errors.push({
            code: "REVIEWS_SYNC_ERROR",
            message: error.message,
            dataType: "reviews",
            retryable: true,
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsFailed++;
          session2.progress.failed++;
        }
      }
      /**
       * Sync posts
       */
      async syncPosts(session2, config2) {
        try {
          const { posts: posts2, total } = await gmbPostService.getBusinessPosts(session2.businessId);
          if (!session2.dataChanges.posts) {
            session2.dataChanges.posts = [];
          }
          session2.dataChanges.posts.push({
            field: "posts",
            oldValue: null,
            newValue: { count: total },
            source: "gmb",
            action: "update",
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsProcessed += total;
          session2.progress.completed += Math.min(20, total);
          session2.progress.percentage = session2.progress.completed / session2.progress.total * 100;
          this.emitSyncEvent("sync.progress", session2);
        } catch (error) {
          session2.errors.push({
            code: "POSTS_SYNC_ERROR",
            message: error.message,
            dataType: "posts",
            retryable: true,
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsFailed++;
          session2.progress.failed++;
        }
      }
      /**
       * Sync photos
       */
      async syncPhotos(session2, config2) {
        try {
          const photoCount = 30;
          if (!session2.dataChanges.photos) {
            session2.dataChanges.photos = [];
          }
          session2.dataChanges.photos.push({
            field: "photos",
            oldValue: null,
            newValue: { count: photoCount },
            source: "gmb",
            action: "update",
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsProcessed += photoCount;
          session2.progress.completed += 30;
          session2.progress.percentage = session2.progress.completed / session2.progress.total * 100;
          this.emitSyncEvent("sync.progress", session2);
        } catch (error) {
          session2.errors.push({
            code: "PHOTOS_SYNC_ERROR",
            message: error.message,
            dataType: "photos",
            retryable: true,
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsFailed++;
          session2.progress.failed++;
        }
      }
      /**
       * Sync insights
       */
      async syncInsights(session2, config2) {
        try {
          const dateRange = {
            start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            end: /* @__PURE__ */ new Date()
          };
          const insights = await gmbInsightsService.fetchLocationInsights(session2.businessId, {
            dateRange
          });
          if (!session2.dataChanges.insights) {
            session2.dataChanges.insights = [];
          }
          session2.dataChanges.insights.push({
            field: "insights",
            oldValue: null,
            newValue: {
              views: insights.metrics.views.total,
              actions: insights.metrics.actions.total
            },
            source: "gmb",
            action: "update",
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsProcessed += 10;
          session2.stats.itemsUpdated += 1;
          session2.progress.completed += 10;
          session2.progress.percentage = session2.progress.completed / session2.progress.total * 100;
          this.emitSyncEvent("sync.progress", session2);
        } catch (error) {
          session2.errors.push({
            code: "INSIGHTS_SYNC_ERROR",
            message: error.message,
            dataType: "insights",
            retryable: true,
            timestamp: /* @__PURE__ */ new Date()
          });
          session2.stats.itemsFailed++;
          session2.progress.failed++;
        }
      }
      /**
       * Incremental sync methods
       */
      async syncBusinessInfoIncremental(session2, config2, lastSync) {
        const business = await storage.getBusinessById(session2.businessId);
        if (business && business.updatedAt > lastSync) {
          await this.syncBusinessInfo(session2, config2);
        }
      }
      async syncReviewsIncremental(session2, config2, lastSync) {
        const { reviews: reviews2 } = await gmbReviewService.fetchReviews(session2.businessId);
        const newReviews = reviews2.filter((r) => r.createdAt >= lastSync);
        if (newReviews.length > 0) {
          session2.stats.itemsProcessed += newReviews.length;
          session2.stats.itemsCreated += newReviews.length;
        }
      }
      async syncPostsIncremental(session2, config2, lastSync) {
        const { posts: posts2 } = await gmbPostService.getBusinessPosts(session2.businessId);
        const newPosts = posts2.filter((p) => p.createdAt >= lastSync);
        if (newPosts.length > 0) {
          session2.stats.itemsProcessed += newPosts.length;
          session2.stats.itemsCreated += newPosts.length;
        }
      }
      /**
       * Check for changes in real-time sync
       */
      async checkForChanges(session2, config2) {
        const lastCheck = session2.endTime || session2.startTime;
        const changes = await this.detectChanges(session2.businessId, lastCheck);
        if (changes.hasChanges) {
          this.emitSyncEvent("data.changed", {
            ...session2,
            dataChanges: changes.changes
          });
          if (changes.changes.reviews) {
            await this.syncReviewsIncremental(session2, config2, lastCheck);
          }
          if (changes.changes.posts) {
            await this.syncPostsIncremental(session2, config2, lastCheck);
          }
        }
      }
      /**
       * Detect changes since last check
       */
      async detectChanges(businessId, since) {
        const changes = {};
        let hasChanges = false;
        const { reviews: reviews2 } = await gmbReviewService.fetchReviews(businessId);
        const newReviews = reviews2.filter((r) => r.createdAt >= since);
        if (newReviews.length > 0) {
          changes.reviews = newReviews;
          hasChanges = true;
        }
        const { posts: posts2 } = await gmbPostService.getBusinessPosts(businessId);
        const newPosts = posts2.filter((p) => p.createdAt >= since);
        if (newPosts.length > 0) {
          changes.posts = newPosts;
          hasChanges = true;
        }
        return { hasChanges, changes };
      }
      /**
       * Get sync session status
       */
      getSyncStatus(sessionId) {
        return this.activeSessions.get(sessionId);
      }
      /**
       * Get all active sync sessions
       */
      getActiveSessions() {
        return Array.from(this.activeSessions.values());
      }
      /**
       * Cancel a sync session
       */
      cancelSync(sessionId) {
        const session2 = this.activeSessions.get(sessionId);
        if (session2 && session2.status === "in_progress") {
          session2.status = "paused";
          session2.endTime = /* @__PURE__ */ new Date();
          const scheduleKey = `realtime_${sessionId}`;
          const schedule = this.syncSchedules.get(scheduleKey);
          if (schedule) {
            clearInterval(schedule);
            this.syncSchedules.delete(scheduleKey);
          }
          this.emitSyncEvent("sync.failed", session2);
        }
      }
      /**
       * Resume a paused sync session
       */
      async resumeSync(sessionId) {
        const session2 = this.activeSessions.get(sessionId);
        if (session2 && session2.status === "paused") {
          session2.status = "in_progress";
          const config2 = this.syncConfigurations.get(session2.businessId);
          if (config2) {
            await this.performFullSync(session2, config2.dataTypes, config2);
          }
        }
      }
      /**
       * Retry a failed sync session
       */
      async retrySyncSession(sessionId, maxRetries) {
        const session2 = this.activeSessions.get(sessionId);
        if (!session2 || session2.status !== "failed") return;
        let retryCount = 0;
        while (retryCount < maxRetries) {
          retryCount++;
          try {
            session2.status = "in_progress";
            session2.errors = [];
            const config2 = this.syncConfigurations.get(session2.businessId);
            if (config2) {
              await this.performFullSync(session2, config2.dataTypes, config2);
            }
            break;
          } catch (error) {
            session2.status = "failed";
            if (retryCount >= maxRetries) {
              throw new Error(`Sync failed after ${maxRetries} retries`);
            }
            await this.sleep(Math.pow(2, retryCount) * 1e3);
          }
        }
      }
      /**
       * Set up automatic sync schedule
       */
      async setupAutoSync(businessId, intervalMinutes) {
        const existingSchedule = this.syncSchedules.get(businessId);
        if (existingSchedule) {
          clearInterval(existingSchedule);
        }
        const schedule = setInterval(async () => {
          try {
            await this.startSync(businessId, { type: "incremental" });
          } catch (error) {
            console.error(`Auto-sync failed for business ${businessId}:`, error);
          }
        }, intervalMinutes * 60 * 1e3);
        this.syncSchedules.set(businessId, schedule);
      }
      /**
       * Get sync history for a business
       */
      async getSyncHistory(businessId, options = {}) {
        return await storage.getGmbSyncHistoryByBusiness(businessId, options.limit || 100);
      }
      /**
       * Generate sync report
       */
      async generateSyncReport(businessId, dateRange) {
        const history = await this.getSyncHistory(businessId, { dateRange });
        const totalSyncs = history.length;
        const successfulSyncs = history.filter((h) => h.status === "success").length;
        const failedSyncs = history.filter((h) => h.status === "error").length;
        const durations = history.map((h) => h.durationMs || 0).filter((d) => d > 0);
        const averageDuration = durations.length > 0 ? durations.reduce((sum2, d) => sum2 + d, 0) / durations.length : 0;
        const dataTypeCount = /* @__PURE__ */ new Map();
        history.forEach((h) => {
          h.dataTypes?.forEach((type) => {
            dataTypeCount.set(type, (dataTypeCount.get(type) || 0) + 1);
          });
        });
        const mostSyncedDataType = Array.from(dataTypeCount.entries()).sort((a, b) => b[1] - a[1])[0]?.[0] || "none";
        const recentErrors = history.filter((h) => h.status === "error").slice(0, 5).map((h) => ({
          code: h.errorCode || "UNKNOWN",
          message: h.errorMessage || "Unknown error",
          dataType: h.dataTypes?.[0] || "general",
          retryable: true,
          timestamp: h.createdAt
        }));
        const recommendations = this.generateSyncRecommendations(history);
        return {
          totalSyncs,
          successfulSyncs,
          failedSyncs,
          averageDuration,
          totalDataTransferred: 0,
          // Would calculate from actual data
          mostSyncedDataType,
          recentErrors,
          recommendations
        };
      }
      /**
       * Helper: Generate sync recommendations
       */
      generateSyncRecommendations(history) {
        const recommendations = [];
        const failureRate = history.filter((h) => h.status === "error").length / history.length;
        if (failureRate > 0.1) {
          recommendations.push("High failure rate detected. Check API credentials and network connectivity.");
        }
        const avgDuration = history.reduce((sum2, h) => sum2 + (h.durationMs || 0), 0) / history.length;
        if (avgDuration > 6e4) {
          recommendations.push("Sync operations are taking longer than expected. Consider optimizing data queries.");
        }
        const recentSyncs = history.filter(
          (h) => new Date(h.createdAt).getTime() > Date.now() - 24 * 60 * 60 * 1e3
        );
        if (recentSyncs.length === 0) {
          recommendations.push("No recent syncs detected. Enable auto-sync to keep data up-to-date.");
        }
        return recommendations;
      }
      /**
       * Helper: Get default sync configuration
       */
      async getDefaultConfiguration(businessId) {
        return {
          businessId,
          syncType: "incremental",
          autoSync: false,
          conflictStrategy: "gmb_wins",
          dataTypes: {
            businessInfo: true,
            reviews: true,
            posts: true,
            photos: true,
            insights: true
          },
          webhookEnabled: false,
          notifyOnComplete: true,
          notifyOnError: true,
          retryOnFailure: true,
          maxRetries: 3
        };
      }
      /**
       * Helper: Get last sync timestamp
       */
      async getLastSyncTimestamp(businessId) {
        const history = await storage.getGmbSyncHistoryByBusiness(businessId, 1);
        return history.length > 0 ? history[0].createdAt : null;
      }
      /**
       * Helper: Emit sync event via WebSocket and webhook
       */
      emitSyncEvent(eventType, session2) {
        const payload = {
          eventType,
          businessId: session2.businessId,
          sessionId: session2.id,
          data: {
            status: session2.status,
            progress: session2.progress,
            changes: session2.dataChanges,
            errors: session2.errors
          },
          timestamp: /* @__PURE__ */ new Date()
        };
        if (this.io) {
          this.io.to(`gmb_${session2.businessId}`).emit(eventType, payload);
        }
        const webhookUrl = this.webhookClients.get(session2.businessId);
        if (webhookUrl) {
          this.sendWebhook(webhookUrl, payload);
        }
      }
      /**
       * Helper: Send webhook notification
       */
      async sendWebhook(url, payload) {
        try {
          await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-GMB-Event": payload.eventType
            },
            body: JSON.stringify(payload)
          });
        } catch (error) {
          console.error("Failed to send webhook:", error);
        }
      }
      /**
       * Helper: Sleep function
       */
      sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      /**
       * Clean up resources
       */
      cleanup() {
        this.syncSchedules.forEach((schedule) => clearInterval(schedule));
        this.syncSchedules.clear();
        this.activeSessions.clear();
        this.syncConfigurations.clear();
      }
    };
    gmbSyncService = new GMBSyncService();
  }
});

// server/stripeConnect.ts
var stripeConnect_exports = {};
__export(stripeConnect_exports, {
  addBankAccount: () => addBankAccount,
  constructWebhookEvent: () => constructWebhookEvent,
  createAccountLink: () => createAccountLink,
  createConnectAccount: () => createConnectAccount,
  createInstantPayout: () => createInstantPayout,
  createLoginLink: () => createLoginLink,
  createPayout: () => createPayout,
  deleteExternalAccount: () => deleteExternalAccount,
  enableInternationalPayouts: () => enableInternationalPayouts,
  getAccountBalance: () => getAccountBalance,
  getAccountCapabilities: () => getAccountCapabilities,
  getConnectAccount: () => getConnectAccount,
  getPayoutInfo: () => getPayoutInfo,
  getPayoutSettings: () => getPayoutSettings,
  getStripeClient: () => getStripeClient,
  getVerificationStatus: () => getVerificationStatus,
  handleConnectWebhook: () => handleConnectWebhook,
  isAccountOnboarded: () => isAccountOnboarded,
  listBalanceTransactions: () => listBalanceTransactions,
  listExternalAccounts: () => listExternalAccounts,
  listPayouts: () => listPayouts,
  updatePayoutSettings: () => updatePayoutSettings,
  updateVerificationInfo: () => updateVerificationInfo,
  verifyBankAccount: () => verifyBankAccount
});
import Stripe from "stripe";
function getStripeClient() {
  if (!stripe2) {
    if (!process.env.STRIPE_SECRET_KEY) {
      throw new Error(
        "STRIPE_SECRET_KEY environment variable is required for payment processing. Please configure Stripe keys in your environment."
      );
    }
    stripe2 = new Stripe(process.env.STRIPE_SECRET_KEY, {
      apiVersion: "2025-08-27.basil",
      typescript: true,
      telemetry: false
      // Disable telemetry in production
    });
  }
  return stripe2;
}
async function createConnectAccount(data) {
  try {
    const stripeClient = getStripeClient();
    const accountParams = {
      type: "express",
      // Express accounts have simplified onboarding
      country: data.country || "US",
      email: data.email,
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true },
        us_bank_account_ach_payments: { requested: true }
        // ACH support
      },
      business_type: data.businessType,
      business_profile: {
        name: data.businessName,
        product_description: data.productDescription || "Marketplace vendor services",
        mcc: data.mcc || "5734",
        // Computer software stores
        url: data.website
      },
      metadata: {
        businessId: data.businessId,
        userId: data.userId
      }
    };
    if (data.businessType === "individual" && (data.firstName || data.lastName)) {
      accountParams.individual = {
        first_name: data.firstName,
        last_name: data.lastName,
        email: data.email,
        phone: data.phone,
        address: data.address,
        ssn_last_4: data.ssnLast4,
        dob: data.dateOfBirth
      };
    }
    if (data.businessType === "company") {
      accountParams.company = {
        name: data.businessName,
        phone: data.phone,
        tax_id: data.taxId,
        address: data.address
      };
    }
    if (data.tosAcceptance) {
      accountParams.tos_acceptance = data.tosAcceptance;
    }
    const account = await stripeClient.accounts.create(accountParams);
    logger.info("Stripe Connect account created", {
      accountId: account.id,
      businessId: data.businessId,
      userId: data.userId
    });
    trackEvent(
      data.userId,
      "stripe_connect_account_created",
      {
        accountId: account.id,
        businessId: data.businessId
      }
    );
    return account;
  } catch (error) {
    logger.error("Failed to create Stripe Connect account", {
      error,
      businessId: data.businessId
    });
    throw new Error(
      `Failed to create payment account: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function getConnectAccount(accountId) {
  try {
    const cacheKey = `stripe:account:${accountId}`;
    const cached = await cache?.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    const stripeClient = getStripeClient();
    const account = await stripeClient.accounts.retrieve(accountId);
    if (cache) {
      await cache.set(cacheKey, JSON.stringify(account), 300);
    }
    return account;
  } catch (error) {
    logger.error("Failed to retrieve Stripe Connect account", {
      error,
      accountId
    });
    throw new Error(
      `Failed to retrieve payment account: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createAccountLink(accountId, refreshUrl, returnUrl) {
  try {
    const stripeClient = getStripeClient();
    const accountLink = await stripeClient.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type: "account_onboarding"
    });
    logger.info("Account onboarding link created", {
      accountId,
      url: accountLink.url
    });
    return accountLink;
  } catch (error) {
    logger.error("Failed to create account link", { error, accountId });
    throw new Error(
      `Failed to create onboarding link: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
function isAccountOnboarded(account) {
  return account.charges_enabled === true && account.payouts_enabled === true && account.details_submitted === true;
}
async function getAccountBalance(accountId) {
  try {
    const stripeClient = getStripeClient();
    const balance = await stripeClient.balance.retrieve({
      stripeAccount: accountId
    });
    return balance;
  } catch (error) {
    logger.error("Failed to retrieve account balance", { error, accountId });
    throw new Error(
      `Failed to retrieve balance: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function listPayouts(accountId, limit = 10) {
  try {
    const stripeClient = getStripeClient();
    const payouts = await stripeClient.payouts.list(
      { limit },
      { stripeAccount: accountId }
    );
    return {
      data: payouts.data,
      hasMore: payouts.has_more
    };
  } catch (error) {
    logger.error("Failed to list payouts", { error, accountId });
    throw new Error(
      `Failed to retrieve payouts: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createPayout(accountId, amount, currency = "usd", description) {
  try {
    const stripeClient = getStripeClient();
    const payout = await stripeClient.payouts.create(
      {
        amount: Math.round(amount * 100),
        // Convert to cents
        currency,
        description: description || "Marketplace payout"
      },
      { stripeAccount: accountId }
    );
    logger.info("Payout created", {
      accountId,
      payoutId: payout.id,
      amount,
      currency
    });
    trackEvent(
      accountId,
      "stripe_payout_created",
      {
        payoutId: payout.id,
        amount,
        currency
      }
    );
    return payout;
  } catch (error) {
    logger.error("Failed to create payout", { error, accountId, amount });
    throw new Error(
      `Failed to create payout: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function getPayoutSettings(accountId) {
  try {
    const account = await getConnectAccount(accountId);
    return {
      interval: account.settings?.payouts?.schedule?.interval || "daily",
      delayDays: account.settings?.payouts?.schedule?.delay_days || 2
    };
  } catch (error) {
    logger.error("Failed to get payout settings", { error, accountId });
    throw new Error(
      `Failed to retrieve payout settings: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function updatePayoutSettings(accountId, settings) {
  try {
    const updateData = {
      settings: {
        payouts: {
          schedule: {
            interval: settings.interval || "daily",
            delay_days: settings.delayDays || 2
          }
        }
      }
    };
    const stripeClient = getStripeClient();
    const account = await stripeClient.accounts.update(accountId, updateData);
    const cacheKey = `stripe:account:${accountId}`;
    if (cache) {
      await cache.delete(cacheKey);
    }
    logger.info("Payout settings updated", { accountId, settings });
    return account;
  } catch (error) {
    logger.error("Failed to update payout settings", { error, accountId, settings });
    throw new Error(
      `Failed to update payout settings: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function listBalanceTransactions(accountId, options = {}) {
  try {
    const stripeClient = getStripeClient();
    const transactions = await stripeClient.balanceTransactions.list(
      {
        limit: options.limit || 10,
        ...options.startingAfter && { starting_after: options.startingAfter }
      },
      { stripeAccount: accountId }
    );
    return {
      data: transactions.data,
      hasMore: transactions.has_more
    };
  } catch (error) {
    logger.error("Failed to list balance transactions", { error, accountId });
    throw new Error(
      `Failed to retrieve transactions: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createLoginLink(accountId) {
  try {
    const stripeClient = getStripeClient();
    const loginLink = await stripeClient.accounts.createLoginLink(accountId);
    logger.info("Dashboard login link created", {
      accountId,
      url: loginLink.url
    });
    return loginLink;
  } catch (error) {
    logger.error("Failed to create login link", { error, accountId });
    throw new Error(
      `Failed to create dashboard link: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function getVerificationStatus(accountId) {
  try {
    const account = await getConnectAccount(accountId);
    return {
      isVerified: !account.requirements?.currently_due?.length,
      currentlyDue: account.requirements?.currently_due || [],
      eventuallyDue: account.requirements?.eventually_due || [],
      pastDue: account.requirements?.past_due || [],
      pendingVerification: account.requirements?.pending_verification || [],
      disabledReason: account.requirements?.disabled_reason,
      currentDeadline: account.requirements?.current_deadline ? new Date(account.requirements.current_deadline * 1e3) : void 0
    };
  } catch (error) {
    logger.error("Failed to get verification status", { error, accountId });
    throw new Error(
      `Failed to get verification status: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function updateVerificationInfo(accountId, updates) {
  try {
    const stripeClient = getStripeClient();
    const updateParams = {};
    if (updates.individual) {
      updateParams.individual = updates.individual;
    }
    if (updates.company) {
      updateParams.company = updates.company;
    }
    if (updates.documents) {
      updateParams.documents = updates.documents;
    }
    const account = await stripeClient.accounts.update(accountId, updateParams);
    const cacheKey = `stripe:account:${accountId}`;
    if (cache) {
      await cache.delete(cacheKey);
    }
    logger.info("Account verification info updated", { accountId });
    return account;
  } catch (error) {
    logger.error("Failed to update verification info", { error, accountId });
    throw new Error(
      `Failed to update verification: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function addBankAccount(accountId, bankAccountDetails) {
  try {
    const stripeClient = getStripeClient();
    const bankAccount = await stripeClient.accounts.createExternalAccount(accountId, {
      external_account: {
        object: "bank_account",
        account_number: bankAccountDetails.accountNumber,
        routing_number: bankAccountDetails.routingNumber,
        account_holder_name: bankAccountDetails.accountHolderName,
        account_holder_type: bankAccountDetails.accountHolderType,
        currency: bankAccountDetails.currency || "usd",
        country: bankAccountDetails.country || "US"
      }
    });
    logger.info("Bank account added", {
      accountId,
      last4: bankAccount.last4
    });
    return bankAccount;
  } catch (error) {
    logger.error("Failed to add bank account", { error, accountId });
    throw new Error(
      `Failed to add bank account: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function verifyBankAccount(accountId, bankAccountId, amounts) {
  try {
    const stripeClient = getStripeClient();
    const bankAccount = await stripeClient.accounts.verifyExternalAccount(
      accountId,
      bankAccountId,
      {
        amounts
      }
    );
    logger.info("Bank account verified", {
      accountId,
      bankAccountId,
      verified: bankAccount.status === "verified"
    });
    return bankAccount;
  } catch (error) {
    logger.error("Failed to verify bank account", { error, accountId, bankAccountId });
    throw new Error(
      `Failed to verify bank account: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function listExternalAccounts(accountId, options = {}) {
  try {
    const stripeClient = getStripeClient();
    const externalAccounts = await stripeClient.accounts.listExternalAccounts(
      accountId,
      {
        limit: options.limit || 10,
        object: options.object
      }
    );
    return externalAccounts;
  } catch (error) {
    logger.error("Failed to list external accounts", { error, accountId });
    throw new Error(
      `Failed to list bank accounts: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function deleteExternalAccount(accountId, externalAccountId) {
  try {
    const stripeClient = getStripeClient();
    const deleted = await stripeClient.accounts.deleteExternalAccount(
      accountId,
      externalAccountId
    );
    logger.info("External account deleted", {
      accountId,
      externalAccountId
    });
    return deleted;
  } catch (error) {
    logger.error("Failed to delete external account", { error, accountId, externalAccountId });
    throw new Error(
      `Failed to delete bank account: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createInstantPayout(accountId, amount, currency = "usd", destinationId) {
  try {
    const stripeClient = getStripeClient();
    const payoutParams = {
      amount: Math.round(amount * 100),
      // Convert to cents
      currency,
      method: "instant",
      description: "Instant marketplace payout"
    };
    if (destinationId) {
      payoutParams.destination = destinationId;
    }
    const payout = await stripeClient.payouts.create(
      payoutParams,
      { stripeAccount: accountId }
    );
    logger.info("Instant payout created", {
      accountId,
      payoutId: payout.id,
      amount,
      currency
    });
    trackEvent(
      accountId,
      "stripe_instant_payout_created",
      {
        payoutId: payout.id,
        amount,
        currency
      }
    );
    return payout;
  } catch (error) {
    logger.error("Failed to create instant payout", { error, accountId, amount });
    throw new Error(
      `Failed to create instant payout: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function getAccountCapabilities(accountId) {
  try {
    const account = await getConnectAccount(accountId);
    return {
      cardPayments: account.capabilities?.card_payments === "active",
      transfers: account.capabilities?.transfers === "active",
      achPayments: account.capabilities?.us_bank_account_ach_payments === "active",
      taxReporting: account.capabilities?.tax_reporting_us_1099_k === "active",
      instantPayouts: account.capabilities?.instant_payouts === "active",
      capabilities: account.capabilities || {}
    };
  } catch (error) {
    logger.error("Failed to get account capabilities", { error, accountId });
    throw new Error(
      `Failed to get capabilities: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function enableInternationalPayouts(accountId, currencies) {
  try {
    const stripeClient = getStripeClient();
    const capabilities = {};
    if (currencies.includes("eur")) {
      capabilities.sepa_debit_payments = { requested: true };
    }
    if (currencies.includes("gbp")) {
      capabilities.bacs_debit_payments = { requested: true };
    }
    if (currencies.includes("cad")) {
      capabilities.acss_debit_payments = { requested: true };
    }
    const account = await stripeClient.accounts.update(accountId, {
      capabilities,
      settings: {
        payouts: {
          debit_negative_balances: true
        }
      }
    });
    logger.info("International payouts enabled", {
      accountId,
      currencies
    });
    return account;
  } catch (error) {
    logger.error("Failed to enable international payouts", { error, accountId, currencies });
    throw new Error(
      `Failed to enable international payouts: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function getPayoutInfo(accountId) {
  try {
    const account = await getConnectAccount(accountId);
    const stripeClient = getStripeClient();
    let instantPayoutInfo = {
      available: false,
      minimumAmount: 0,
      maximumAmount: 0,
      percentageFee: 1,
      fixedFee: 0.25
    };
    if (account.capabilities?.instant_payouts === "active") {
      try {
        const balance = await stripeClient.balance.retrieve({
          stripeAccount: accountId
        });
        if (balance.instant_available?.[0]) {
          instantPayoutInfo = {
            available: true,
            minimumAmount: 100,
            // $1.00 minimum
            maximumAmount: 1e6,
            // $10,000 maximum
            percentageFee: 1,
            fixedFee: 0.25
          };
        }
      } catch (err) {
        logger.debug("Could not retrieve instant payout info", { accountId, error: err });
      }
    }
    return {
      schedule: {
        interval: account.settings?.payouts?.schedule?.interval || "daily",
        delayDays: account.settings?.payouts?.schedule?.delay_days || 2,
        weeklyAnchor: account.settings?.payouts?.schedule?.weekly_anchor,
        monthlyAnchor: account.settings?.payouts?.schedule?.monthly_anchor
      },
      instantPayouts: instantPayoutInfo
    };
  } catch (error) {
    logger.error("Failed to get payout info", { error, accountId });
    throw new Error(
      `Failed to get payout information: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function handleConnectWebhook(event, storage2) {
  try {
    logger.info("Processing Stripe webhook", {
      eventType: event.type,
      eventId: event.id
    });
    switch (event.type) {
      case "account.updated": {
        const account = event.data.object;
        const businessId = account.metadata?.businessId;
        if (businessId && isAccountOnboarded(account)) {
          logger.info("Connect account onboarded", {
            accountId: account.id,
            businessId
          });
          trackEvent(
            businessId,
            "stripe_connect_onboarded",
            {
              accountId: account.id
            }
          );
          if (emailQueue) {
            try {
              await emailQueue.add("connect-onboarded", {
                businessId,
                accountId: account.id
              });
            } catch (emailError) {
              logger.error("Failed to queue onboarding email", {
                error: emailError,
                businessId,
                accountId: account.id
              });
            }
          }
        }
        break;
      }
      case "payout.paid":
      case "payout.failed": {
        const payout = event.data.object;
        const status = event.type === "payout.paid" ? "paid" : "failed";
        logger.info("Payout status updated", {
          payoutId: payout.id,
          status,
          amount: payout.amount / 100
        });
        trackEvent(
          payout.id,
          "stripe_payout_updated",
          {
            status,
            amount: payout.amount / 100
          }
        );
        break;
      }
      case "account.external_account.created":
      case "account.external_account.deleted": {
        const externalAccount = event.data.object;
        logger.info("External account updated", {
          eventType: event.type,
          accountId: externalAccount.account
        });
        break;
      }
      default:
        logger.debug("Unhandled webhook event", { eventType: event.type });
    }
  } catch (error) {
    logger.error("Failed to process webhook", {
      error,
      eventType: event.type,
      eventId: event.id
    });
    throw new Error(
      `Webhook processing failed: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
function constructWebhookEvent(payload, signature) {
  try {
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    if (!webhookSecret) {
      throw new Error(
        "STRIPE_WEBHOOK_SECRET environment variable is required for webhook verification. Please configure webhook secret in your environment."
      );
    }
    const stripeClient = getStripeClient();
    return stripeClient.webhooks.constructEvent(payload, signature, webhookSecret);
  } catch (error) {
    logger.error("Webhook signature verification failed", { error });
    throw new Error(
      `Webhook verification failed: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
var stripe2;
var init_stripeConnect = __esm({
  "server/stripeConnect.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    init_redis();
    stripe2 = null;
  }
});

// server/socialAuthRoutes.ts
import { eq as eq2, and as and2 } from "drizzle-orm";
import crypto2 from "crypto";
function generateState() {
  return crypto2.randomBytes(32).toString("hex");
}
async function storeOAuthState(state, data) {
  const key = `oauth:state:${state}`;
  await cache.set(key, data, OAUTH_STATE_TTL);
  console.log(`\u2705 OAuth state stored: ${state.substring(0, 8)}... (platform: ${data.platform})`);
}
async function getOAuthState(state) {
  const key = `oauth:state:${state}`;
  const data = await cache.get(key);
  if (data) {
    console.log(`\u2705 OAuth state retrieved: ${state.substring(0, 8)}... (platform: ${data.platform})`);
  } else {
    console.warn(`\u274C OAuth state not found or expired: ${state.substring(0, 8)}...`);
  }
  return data;
}
async function deleteOAuthState(state) {
  const key = `oauth:state:${state}`;
  await redis.del(key);
  console.log(`\u{1F5D1}\uFE0F  OAuth state deleted: ${state.substring(0, 8)}...`);
}
function registerSocialAuthRoutes(app) {
  app.get("/api/social/auth/:platform", async (req, res) => {
    try {
      const { platform } = req.params;
      const { businessId } = req.query;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const config2 = OAUTH_CONFIGS[platform];
      if (!config2) {
        return res.status(400).json({ error: "Invalid platform" });
      }
      if (!config2.clientId) {
        return res.status(500).json({
          error: `${platform} OAuth not configured. Please set environment variables.`
        });
      }
      const state = generateState();
      await storeOAuthState(state, {
        userId,
        businessId,
        platform
      });
      const redirectUri = `${process.env.VITE_API_URL || "http://localhost:5000"}/api/social/callback/${platform}`;
      const params = new URLSearchParams({
        client_id: config2.clientId,
        redirect_uri: redirectUri,
        response_type: "code",
        scope: config2.scopes.join(" "),
        state,
        access_type: platform === "youtube" ? "offline" : void 0,
        prompt: platform === "youtube" ? "consent" : void 0
      }.filter(([_, v]) => v !== void 0));
      const authUrl = `${config2.authUrl}?${params}`;
      res.json({ authUrl });
    } catch (error) {
      console.error("OAuth initiation error:", error);
      res.status(500).json({ error: "Failed to initiate OAuth flow" });
    }
  });
  app.get("/api/social/callback/:platform", async (req, res) => {
    try {
      const { platform } = req.params;
      const { code, state, error } = req.query;
      if (error) {
        return res.redirect(`/social-hub?error=${error}`);
      }
      if (!code || !state) {
        return res.redirect("/social-hub?error=missing_params");
      }
      const stateData = await getOAuthState(state);
      if (!stateData) {
        console.error("\u274C Invalid or expired OAuth state:", state);
        return res.redirect("/social-hub?error=invalid_state");
      }
      await deleteOAuthState(state);
      const config2 = OAUTH_CONFIGS[platform];
      if (!config2) {
        return res.redirect("/social-hub?error=invalid_platform");
      }
      const redirectUri = `${process.env.VITE_API_URL || "http://localhost:5000"}/api/social/callback/${platform}`;
      const tokenResponse = await fetch(config2.tokenUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          code,
          redirect_uri: redirectUri,
          client_id: config2.clientId,
          client_secret: config2.clientSecret
        })
      });
      const tokenData = await tokenResponse.json();
      if (!tokenData.access_token) {
        console.error("Token exchange failed:", tokenData);
        return res.redirect("/social-hub?error=token_exchange_failed");
      }
      const profileData = await fetchSocialProfile(platform, tokenData.access_token);
      const [socialAccount] = await db.insert(socialAccounts).values({
        id: crypto2.randomUUID(),
        userId: stateData.userId,
        businessId: stateData.businessId,
        platform,
        accountId: profileData.id,
        accountName: profileData.name || profileData.username,
        accountHandle: profileData.username || profileData.handle,
        profileUrl: profileData.profileUrl,
        profileImageUrl: profileData.profileImage,
        isActive: true,
        metadata: profileData
      }).onConflictDoUpdate({
        target: [socialAccounts.userId, socialAccounts.platform, socialAccounts.accountId],
        set: {
          accountName: profileData.name || profileData.username,
          accountHandle: profileData.username || profileData.handle,
          profileUrl: profileData.profileUrl,
          profileImageUrl: profileData.profileImage,
          isActive: true,
          metadata: profileData,
          updatedAt: /* @__PURE__ */ new Date()
        }
      }).returning();
      await db.insert(socialTokens).values({
        id: crypto2.randomUUID(),
        socialAccountId: socialAccount.id,
        accessToken: tokenData.access_token,
        refreshToken: tokenData.refresh_token,
        expiresAt: tokenData.expires_in ? new Date(Date.now() + tokenData.expires_in * 1e3) : null,
        scopes: config2.scopes
      }).onConflictDoUpdate({
        target: [socialTokens.socialAccountId],
        set: {
          accessToken: tokenData.access_token,
          refreshToken: tokenData.refresh_token,
          expiresAt: tokenData.expires_in ? new Date(Date.now() + tokenData.expires_in * 1e3) : null,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      res.redirect("/social-hub?connected=" + platform);
    } catch (error) {
      console.error("OAuth callback error:", error);
      res.redirect("/social-hub?error=callback_failed");
    }
  });
  app.get("/api/social/accounts", async (req, res) => {
    try {
      const userId = req.user?.id;
      const { businessId } = req.query;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const conditions = [eq2(socialAccounts.userId, userId)];
      if (businessId) {
        conditions.push(eq2(socialAccounts.businessId, businessId));
      }
      const accounts = await db.select().from(socialAccounts).where(and2(...conditions));
      res.json(accounts);
    } catch (error) {
      console.error("Error fetching social accounts:", error);
      res.status(500).json({ error: "Failed to fetch social accounts" });
    }
  });
  app.delete("/api/social/accounts/:id", async (req, res) => {
    try {
      const userId = req.user?.id;
      const { id } = req.params;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const [account] = await db.select().from(socialAccounts).where(and2(
        eq2(socialAccounts.id, id),
        eq2(socialAccounts.userId, userId)
      ));
      if (!account) {
        return res.status(404).json({ error: "Account not found" });
      }
      await db.update(socialAccounts).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(socialAccounts.id, id));
      await db.delete(socialTokens).where(eq2(socialTokens.socialAccountId, id));
      res.json({ message: "Account disconnected successfully" });
    } catch (error) {
      console.error("Error disconnecting social account:", error);
      res.status(500).json({ error: "Failed to disconnect account" });
    }
  });
  app.post("/api/social/refresh/:accountId", async (req, res) => {
    try {
      const userId = req.user?.id;
      const { accountId } = req.params;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const [account] = await db.select().from(socialAccounts).where(and2(
        eq2(socialAccounts.id, accountId),
        eq2(socialAccounts.userId, userId)
      ));
      if (!account) {
        return res.status(404).json({ error: "Account not found" });
      }
      const [token] = await db.select().from(socialTokens).where(eq2(socialTokens.socialAccountId, accountId));
      if (!token || !token.refreshToken) {
        return res.status(400).json({ error: "No refresh token available" });
      }
      const config2 = OAUTH_CONFIGS[account.platform];
      if (!config2) {
        return res.status(400).json({ error: "Invalid platform" });
      }
      const tokenResponse = await fetch(config2.tokenUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          grant_type: "refresh_token",
          refresh_token: token.refreshToken,
          client_id: config2.clientId,
          client_secret: config2.clientSecret
        })
      });
      const tokenData = await tokenResponse.json();
      if (!tokenData.access_token) {
        return res.status(400).json({ error: "Token refresh failed" });
      }
      await db.update(socialTokens).set({
        accessToken: tokenData.access_token,
        refreshToken: tokenData.refresh_token || token.refreshToken,
        expiresAt: tokenData.expires_in ? new Date(Date.now() + tokenData.expires_in * 1e3) : null,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq2(socialTokens.socialAccountId, accountId));
      res.json({ message: "Token refreshed successfully" });
    } catch (error) {
      console.error("Error refreshing token:", error);
      res.status(500).json({ error: "Failed to refresh token" });
    }
  });
}
async function fetchSocialProfile(platform, accessToken) {
  switch (platform) {
    case "facebook":
    case "instagram": {
      const response = await fetch(
        `https://graph.facebook.com/v18.0/me?fields=id,name,email,picture&access_token=${accessToken}`
      );
      const data = await response.json();
      if (platform === "instagram") {
        const pagesResponse = await fetch(
          `https://graph.facebook.com/v18.0/me/accounts?access_token=${accessToken}`
        );
        const pagesData = await pagesResponse.json();
        if (pagesData.data && pagesData.data.length > 0) {
          const pageId = pagesData.data[0].id;
          const igResponse = await fetch(
            `https://graph.facebook.com/v18.0/${pageId}?fields=instagram_business_account&access_token=${accessToken}`
          );
          const igData = await igResponse.json();
          if (igData.instagram_business_account) {
            data.instagramId = igData.instagram_business_account.id;
          }
        }
      }
      return {
        id: data.id,
        name: data.name,
        email: data.email,
        profileImage: data.picture?.data?.url,
        profileUrl: `https://facebook.com/${data.id}`,
        ...data
      };
    }
    case "twitter": {
      const response = await fetch(
        "https://api.twitter.com/2/users/me?user.fields=profile_image_url,username,name,description",
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        }
      );
      const { data } = await response.json();
      return {
        id: data.id,
        name: data.name,
        username: data.username,
        profileImage: data.profile_image_url,
        profileUrl: `https://twitter.com/${data.username}`,
        description: data.description,
        ...data
      };
    }
    case "linkedin": {
      const response = await fetch(
        "https://api.linkedin.com/v2/me",
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        }
      );
      const data = await response.json();
      const pictureResponse = await fetch(
        "https://api.linkedin.com/v2/me?projection=(profilePicture(displayImage~:playableStreams))",
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        }
      );
      const pictureData = await pictureResponse.json();
      return {
        id: data.id,
        name: `${data.localizedFirstName} ${data.localizedLastName}`,
        profileImage: pictureData.profilePicture?.displayImage?.elements?.[0]?.identifiers?.[0]?.identifier,
        profileUrl: `https://linkedin.com/in/${data.vanityName || data.id}`,
        ...data
      };
    }
    case "tiktok": {
      const response = await fetch(
        "https://open.tiktokapis.com/v2/user/info/",
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        }
      );
      const { data } = await response.json();
      return {
        id: data.user.open_id,
        name: data.user.display_name,
        username: data.user.username,
        profileImage: data.user.avatar_url,
        profileUrl: `https://tiktok.com/@${data.user.username}`,
        ...data.user
      };
    }
    case "pinterest": {
      const response = await fetch(
        "https://api.pinterest.com/v5/user_account",
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        }
      );
      const data = await response.json();
      return {
        id: data.id,
        name: data.username,
        username: data.username,
        profileImage: data.profile_image,
        profileUrl: `https://pinterest.com/${data.username}`,
        ...data
      };
    }
    case "youtube": {
      const response = await fetch(
        "https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true",
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        }
      );
      const data = await response.json();
      const channel = data.items?.[0];
      return {
        id: channel?.id,
        name: channel?.snippet?.title,
        username: channel?.snippet?.customUrl,
        profileImage: channel?.snippet?.thumbnails?.high?.url,
        profileUrl: `https://youtube.com/channel/${channel?.id}`,
        description: channel?.snippet?.description,
        ...channel
      };
    }
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }
}
var OAUTH_CONFIGS, OAUTH_STATE_TTL;
var init_socialAuthRoutes = __esm({
  "server/socialAuthRoutes.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_redis();
    OAUTH_CONFIGS = {
      facebook: {
        authUrl: "https://www.facebook.com/v18.0/dialog/oauth",
        tokenUrl: "https://graph.facebook.com/v18.0/oauth/access_token",
        scopes: [
          "pages_show_list",
          "pages_read_engagement",
          "pages_manage_posts",
          "instagram_basic",
          "instagram_content_publish",
          "instagram_manage_insights",
          "business_management"
        ],
        clientId: process.env.FACEBOOK_CLIENT_ID,
        clientSecret: process.env.FACEBOOK_CLIENT_SECRET
      },
      instagram: {
        // Instagram uses Facebook OAuth
        authUrl: "https://www.facebook.com/v18.0/dialog/oauth",
        tokenUrl: "https://graph.facebook.com/v18.0/oauth/access_token",
        scopes: [
          "instagram_basic",
          "instagram_content_publish",
          "instagram_manage_insights",
          "instagram_manage_comments",
          "pages_show_list"
        ],
        clientId: process.env.FACEBOOK_CLIENT_ID,
        clientSecret: process.env.FACEBOOK_CLIENT_SECRET
      },
      twitter: {
        authUrl: "https://twitter.com/i/oauth2/authorize",
        tokenUrl: "https://api.twitter.com/2/oauth2/token",
        scopes: [
          "tweet.read",
          "tweet.write",
          "users.read",
          "follows.read",
          "follows.write",
          "offline.access"
        ],
        clientId: process.env.TWITTER_CLIENT_ID,
        clientSecret: process.env.TWITTER_CLIENT_SECRET
      },
      linkedin: {
        authUrl: "https://www.linkedin.com/oauth/v2/authorization",
        tokenUrl: "https://www.linkedin.com/oauth/v2/accessToken",
        scopes: [
          "r_liteprofile",
          "r_emailaddress",
          "w_member_social",
          "r_organization_social",
          "w_organization_social",
          "rw_organization_admin"
        ],
        clientId: process.env.LINKEDIN_CLIENT_ID,
        clientSecret: process.env.LINKEDIN_CLIENT_SECRET
      },
      tiktok: {
        authUrl: "https://www.tiktok.com/v2/auth/authorize",
        tokenUrl: "https://open.tiktokapis.com/v2/oauth/token",
        scopes: [
          "user.info.basic",
          "video.list",
          "video.upload",
          "video.publish"
        ],
        clientId: process.env.TIKTOK_CLIENT_KEY,
        clientSecret: process.env.TIKTOK_CLIENT_SECRET
      },
      pinterest: {
        authUrl: "https://www.pinterest.com/oauth/",
        tokenUrl: "https://api.pinterest.com/v5/oauth/token",
        scopes: [
          "boards:read",
          "boards:write",
          "pins:read",
          "pins:write",
          "user_accounts:read"
        ],
        clientId: process.env.PINTEREST_CLIENT_ID,
        clientSecret: process.env.PINTEREST_CLIENT_SECRET
      },
      youtube: {
        authUrl: "https://accounts.google.com/o/oauth2/v2/auth",
        tokenUrl: "https://oauth2.googleapis.com/token",
        scopes: [
          "https://www.googleapis.com/auth/youtube",
          "https://www.googleapis.com/auth/youtube.upload",
          "https://www.googleapis.com/auth/youtube.readonly",
          "https://www.googleapis.com/auth/yt-analytics.readonly"
        ],
        clientId: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET
      }
    };
    OAUTH_STATE_TTL = 600;
  }
});

// server/socialTokenRefresh.ts
import { eq as eq3, and as and3, lt, isNotNull } from "drizzle-orm";
async function refreshSocialToken(accountId, platform, refreshToken) {
  try {
    const config2 = TOKEN_REFRESH_CONFIGS[platform];
    if (!config2 || !config2.clientId || !config2.clientSecret) {
      logger.warn(`Token refresh skipped: ${platform} not configured`, { accountId });
      return false;
    }
    logger.info(`Refreshing token for ${platform}`, { accountId });
    const tokenResponse = await fetch(config2.tokenUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: refreshToken,
        client_id: config2.clientId,
        client_secret: config2.clientSecret
      })
    });
    const tokenData = await tokenResponse.json();
    if (!tokenData.access_token) {
      logger.error(`Token refresh failed for ${platform}`, {
        accountId,
        error: tokenData.error || "No access token in response"
      });
      return false;
    }
    await db.update(socialTokens).set({
      accessToken: tokenData.access_token,
      refreshToken: tokenData.refresh_token || refreshToken,
      // Keep old refresh token if not provided
      expiresAt: tokenData.expires_in ? new Date(Date.now() + tokenData.expires_in * 1e3) : null,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq3(socialTokens.socialAccountId, accountId));
    logger.info(`\u2705 Token refreshed successfully for ${platform}`, { accountId });
    return true;
  } catch (error) {
    logger.error(`Token refresh error for ${platform}`, {
      accountId,
      error: error instanceof Error ? error.message : "Unknown error"
    });
    return false;
  }
}
async function refreshExpiringTokens() {
  try {
    const oneDayFromNow = new Date(Date.now() + 24 * 60 * 60 * 1e3);
    logger.info("\u{1F504} Starting token refresh job...");
    const expiringTokens = await db.select({
      accountId: socialTokens.socialAccountId,
      platform: socialAccounts.platform,
      refreshToken: socialTokens.refreshToken,
      expiresAt: socialTokens.expiresAt
    }).from(socialTokens).innerJoin(socialAccounts, eq3(socialTokens.socialAccountId, socialAccounts.id)).where(
      and3(
        lt(socialTokens.expiresAt, oneDayFromNow),
        // Expires within 24 hours
        isNotNull(socialTokens.refreshToken),
        // Has a refresh token
        eq3(socialAccounts.isActive, true)
        // Account is active
      )
    );
    if (expiringTokens.length === 0) {
      logger.info("\u2705 No tokens need refreshing");
      return;
    }
    logger.info(`Found ${expiringTokens.length} tokens to refresh`, {
      platforms: expiringTokens.map((t) => t.platform)
    });
    let successCount = 0;
    let failureCount = 0;
    for (const token of expiringTokens) {
      const success = await refreshSocialToken(
        token.accountId,
        token.platform,
        token.refreshToken
      );
      if (success) {
        successCount++;
      } else {
        failureCount++;
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    logger.info(`\u{1F3AF} Token refresh job completed`, {
      total: expiringTokens.length,
      success: successCount,
      failed: failureCount
    });
  } catch (error) {
    logger.error("Token refresh job error", {
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
function startTokenRefreshService(intervalHours = 4) {
  const intervalMs = intervalHours * 60 * 60 * 1e3;
  logger.info(`\u{1F680} Starting automatic token refresh service (every ${intervalHours} hours)`);
  refreshExpiringTokens().catch((error) => {
    logger.error("Initial token refresh failed", { error });
  });
  const interval = setInterval(() => {
    refreshExpiringTokens().catch((error) => {
      logger.error("Scheduled token refresh failed", { error });
    });
  }, intervalMs);
  return interval;
}
async function getTokenRefreshStatus() {
  try {
    const allTokens = await db.select({
      accountId: socialTokens.socialAccountId,
      platform: socialAccounts.platform,
      userId: socialAccounts.userId,
      hasRefreshToken: isNotNull(socialTokens.refreshToken),
      expiresAt: socialTokens.expiresAt,
      lastUpdated: socialTokens.updatedAt
    }).from(socialTokens).innerJoin(socialAccounts, eq3(socialTokens.socialAccountId, socialAccounts.id)).where(eq3(socialAccounts.isActive, true));
    const now = /* @__PURE__ */ new Date();
    const oneDayFromNow = new Date(now.getTime() + 24 * 60 * 60 * 1e3);
    return allTokens.map((token) => ({
      ...token,
      status: !token.expiresAt ? "no_expiry" : token.expiresAt < now ? "expired" : token.expiresAt < oneDayFromNow ? "expiring_soon" : "valid",
      needsRefresh: token.hasRefreshToken && token.expiresAt && token.expiresAt < oneDayFromNow
    }));
  } catch (error) {
    logger.error("Failed to get token refresh status", { error });
    return [];
  }
}
var TOKEN_REFRESH_CONFIGS;
var init_socialTokenRefresh = __esm({
  "server/socialTokenRefresh.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_monitoring();
    TOKEN_REFRESH_CONFIGS = {
      facebook: {
        tokenUrl: "https://graph.facebook.com/v18.0/oauth/access_token",
        clientId: process.env.FACEBOOK_CLIENT_ID,
        clientSecret: process.env.FACEBOOK_CLIENT_SECRET
      },
      instagram: {
        tokenUrl: "https://graph.facebook.com/v18.0/oauth/access_token",
        clientId: process.env.FACEBOOK_CLIENT_ID,
        clientSecret: process.env.FACEBOOK_CLIENT_SECRET
      },
      twitter: {
        tokenUrl: "https://api.twitter.com/2/oauth2/token",
        clientId: process.env.TWITTER_CLIENT_ID,
        clientSecret: process.env.TWITTER_CLIENT_SECRET
      },
      linkedin: {
        tokenUrl: "https://www.linkedin.com/oauth/v2/accessToken",
        clientId: process.env.LINKEDIN_CLIENT_ID,
        clientSecret: process.env.LINKEDIN_CLIENT_SECRET
      },
      tiktok: {
        tokenUrl: "https://open.tiktokapis.com/v2/oauth/token",
        clientId: process.env.TIKTOK_CLIENT_KEY,
        clientSecret: process.env.TIKTOK_CLIENT_SECRET
      },
      pinterest: {
        tokenUrl: "https://api.pinterest.com/v5/oauth/token",
        clientId: process.env.PINTEREST_CLIENT_ID,
        clientSecret: process.env.PINTEREST_CLIENT_SECRET
      },
      youtube: {
        tokenUrl: "https://oauth2.googleapis.com/token",
        clientId: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET
      }
    };
  }
});

// server/socialMediaService.ts
import { eq as eq4, and as and4, desc as desc2, gte, lte, inArray as inArray2, sql as sql3 } from "drizzle-orm";
var PLATFORM_CONFIGS, PLATFORM_LIMITS, OPTIMAL_POSTING_TIMES, SocialMediaService, socialMediaService;
var init_socialMediaService = __esm({
  "server/socialMediaService.ts"() {
    "use strict";
    init_db();
    init_schema();
    PLATFORM_CONFIGS = {
      facebook: {
        apiVersion: "v18.0",
        baseUrl: "https://graph.facebook.com",
        scopes: ["pages_read_engagement", "pages_manage_posts", "pages_manage_metadata", "pages_messaging"]
      },
      instagram: {
        apiVersion: "v18.0",
        baseUrl: "https://graph.instagram.com",
        scopes: ["instagram_basic", "instagram_content_publish", "instagram_manage_comments", "instagram_manage_messages"]
      },
      twitter: {
        apiVersion: "2",
        baseUrl: "https://api.twitter.com",
        scopes: ["tweet.read", "tweet.write", "users.read", "follows.read", "follows.write"]
      },
      linkedin: {
        apiVersion: "v2",
        baseUrl: "https://api.linkedin.com",
        scopes: ["r_organization_social", "w_organization_social", "r_organization_admin", "w_member_social"]
      },
      tiktok: {
        apiVersion: "v2",
        baseUrl: "https://open-api.tiktok.com",
        scopes: ["user.info.basic", "video.publish", "video.list"]
      },
      pinterest: {
        apiVersion: "v5",
        baseUrl: "https://api.pinterest.com",
        scopes: ["boards:read", "boards:write", "pins:read", "pins:write"]
      },
      youtube: {
        apiVersion: "v3",
        baseUrl: "https://www.googleapis.com/youtube",
        scopes: ["https://www.googleapis.com/auth/youtube.upload", "https://www.googleapis.com/auth/youtube.readonly"]
      }
    };
    PLATFORM_LIMITS = {
      facebook: { text: 63206, images: 10, videos: 1, videoSize: 4e3 },
      // MB
      instagram: { text: 2200, images: 10, videos: 1, videoSize: 650 },
      twitter: { text: 280, images: 4, videos: 1, videoSize: 512 },
      linkedin: { text: 3e3, images: 9, videos: 1, videoSize: 5e3 },
      tiktok: { text: 2200, images: 0, videos: 1, videoSize: 287 },
      pinterest: { text: 500, images: 5, videos: 1, videoSize: 2048 },
      youtube: { text: 5e3, images: 0, videos: 1, videoSize: 128e3 }
    };
    OPTIMAL_POSTING_TIMES = {
      facebook: {
        weekdays: ["09:00", "13:00", "16:00"],
        weekends: ["12:00", "14:00"]
      },
      instagram: {
        weekdays: ["11:00", "14:00", "17:00"],
        weekends: ["11:00", "13:00"]
      },
      twitter: {
        weekdays: ["08:00", "10:00", "19:00"],
        weekends: ["09:00", "10:00"]
      },
      linkedin: {
        weekdays: ["07:30", "12:00", "17:00"],
        weekends: []
        // LinkedIn has low weekend engagement
      },
      tiktok: {
        weekdays: ["06:00", "10:00", "19:00", "23:00"],
        weekends: ["09:00", "11:00", "19:00"]
      },
      pinterest: {
        weekdays: ["14:00", "21:00"],
        weekends: ["14:00", "21:00"]
      },
      youtube: {
        weekdays: ["14:00", "15:00", "16:00"],
        weekends: ["09:00", "10:00", "11:00"]
      }
    };
    SocialMediaService = class {
      // Account Management
      async connectAccount(data) {
        const [account] = await db.insert(socialMediaAccounts).values(data).returning();
        return account;
      }
      async disconnectAccount(accountId) {
        await db.update(socialMediaAccounts).set({ isActive: false, accessToken: null, refreshToken: null }).where(eq4(socialMediaAccounts.id, accountId));
      }
      async refreshTokens(accountId) {
        const account = await db.select().from(socialMediaAccounts).where(eq4(socialMediaAccounts.id, accountId)).limit(1);
        if (!account[0] || !account[0].refreshToken) {
          throw new Error("No refresh token available");
        }
        const newTokens = await this.refreshPlatformToken(account[0]);
        await db.update(socialMediaAccounts).set({
          accessToken: newTokens.accessToken,
          refreshToken: newTokens.refreshToken,
          tokenExpiry: newTokens.expiry,
          lastSyncAt: /* @__PURE__ */ new Date()
        }).where(eq4(socialMediaAccounts.id, accountId));
      }
      async refreshPlatformToken(account) {
        switch (account.platform) {
          case "facebook":
          case "instagram":
            return this.refreshMetaToken(account);
          case "twitter":
            return this.refreshTwitterToken(account);
          case "linkedin":
            return this.refreshLinkedInToken(account);
          // Add other platforms...
          default:
            throw new Error(`Unsupported platform: ${account.platform}`);
        }
      }
      async refreshMetaToken(account) {
        return {
          accessToken: "new_access_token",
          refreshToken: account.refreshToken,
          expiry: new Date(Date.now() + 60 * 60 * 1e3)
          // 1 hour
        };
      }
      async refreshTwitterToken(account) {
        return {
          accessToken: "new_access_token",
          refreshToken: "new_refresh_token",
          expiry: new Date(Date.now() + 2 * 60 * 60 * 1e3)
          // 2 hours
        };
      }
      async refreshLinkedInToken(account) {
        return {
          accessToken: "new_access_token",
          refreshToken: account.refreshToken,
          expiry: new Date(Date.now() + 60 * 24 * 60 * 60 * 1e3)
          // 60 days
        };
      }
      // Content Publishing
      async createPost(data) {
        for (const platform of data.platforms) {
          this.validateContentForPlatform(platform, data);
        }
        const [post] = await db.insert(socialMediaPosts).values(data).returning();
        if (data.scheduledAt && data.scheduledAt > /* @__PURE__ */ new Date()) {
          await this.schedulePost(post);
        } else if (data.status === "published") {
          await this.publishPost(post);
        }
        return post;
      }
      validateContentForPlatform(platform, data) {
        const limits = PLATFORM_LIMITS[platform];
        if (!limits) {
          throw new Error(`Unsupported platform: ${platform}`);
        }
        if (data.content.length > limits.text) {
          throw new Error(`Content exceeds ${platform} character limit (${limits.text})`);
        }
        const mediaCount = (data.mediaUrls || []).length;
        if (data.contentType === "image" && mediaCount > limits.images) {
          throw new Error(`Too many images for ${platform} (max: ${limits.images})`);
        }
        if (data.contentType === "video" && mediaCount > limits.videos) {
          throw new Error(`Too many videos for ${platform} (max: ${limits.videos})`);
        }
      }
      async schedulePost(post) {
        console.log(`Post ${post.id} scheduled for ${post.scheduledAt}`);
      }
      async publishPost(post) {
        const accounts = await db.select().from(socialMediaAccounts).where(
          and4(
            eq4(socialMediaAccounts.businessId, post.businessId),
            inArray2(socialMediaAccounts.platform, post.platforms),
            eq4(socialMediaAccounts.isActive, true)
          )
        );
        const platformPosts = {};
        for (const account of accounts) {
          try {
            const result = await this.publishToPlatform(account, post);
            platformPosts[account.platform] = {
              id: result.id,
              status: "published",
              url: result.url,
              publishedAt: /* @__PURE__ */ new Date()
            };
          } catch (error) {
            platformPosts[account.platform] = {
              status: "failed",
              error: error instanceof Error ? error.message : "Unknown error"
            };
          }
        }
        await db.update(socialMediaPosts).set({
          platformPosts,
          status: "published",
          publishedAt: /* @__PURE__ */ new Date()
        }).where(eq4(socialMediaPosts.id, post.id));
      }
      async publishToPlatform(account, post) {
        switch (account.platform) {
          case "facebook":
            return this.publishToFacebook(account, post);
          case "instagram":
            return this.publishToInstagram(account, post);
          case "twitter":
            return this.publishToTwitter(account, post);
          case "linkedin":
            return this.publishToLinkedIn(account, post);
          // Add other platforms...
          default:
            throw new Error(`Publishing not implemented for ${account.platform}`);
        }
      }
      async publishToFacebook(account, post) {
        const endpoint = `${PLATFORM_CONFIGS.facebook.baseUrl}/${PLATFORM_CONFIGS.facebook.apiVersion}/${account.accountId}/feed`;
        return {
          id: "facebook_post_id",
          url: `https://facebook.com/${account.accountId}/posts/facebook_post_id`
        };
      }
      async publishToInstagram(account, post) {
        const endpoint = `${PLATFORM_CONFIGS.instagram.baseUrl}/${PLATFORM_CONFIGS.instagram.apiVersion}/${account.accountId}/media`;
        return {
          id: "instagram_post_id",
          url: `https://instagram.com/p/instagram_post_id`
        };
      }
      async publishToTwitter(account, post) {
        const endpoint = `${PLATFORM_CONFIGS.twitter.baseUrl}/${PLATFORM_CONFIGS.twitter.apiVersion}/tweets`;
        return {
          id: "tweet_id",
          url: `https://twitter.com/${account.accountHandle}/status/tweet_id`
        };
      }
      async publishToLinkedIn(account, post) {
        const endpoint = `${PLATFORM_CONFIGS.linkedin.baseUrl}/${PLATFORM_CONFIGS.linkedin.apiVersion}/ugcPosts`;
        return {
          id: "linkedin_post_id",
          url: `https://linkedin.com/feed/update/urn:li:share:linkedin_post_id`
        };
      }
      // Analytics & Metrics
      async fetchAnalytics(businessId, dateRange) {
        const accounts = await db.select().from(socialMediaAccounts).where(
          and4(
            eq4(socialMediaAccounts.businessId, businessId),
            eq4(socialMediaAccounts.isActive, true)
          )
        );
        const analytics = [];
        for (const account of accounts) {
          const metrics = await this.fetchPlatformAnalytics(account, dateRange);
          analytics.push(...metrics);
        }
        if (analytics.length > 0) {
          await db.insert(socialMediaAnalytics).values(analytics).onConflictDoUpdate({
            target: [socialMediaAnalytics.accountId, socialMediaAnalytics.metricDate],
            set: {
              impressions: sql3`excluded.impressions`,
              reach: sql3`excluded.reach`,
              engagements: sql3`excluded.engagements`,
              likes: sql3`excluded.likes`,
              comments: sql3`excluded.comments`,
              shares: sql3`excluded.shares`,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        return db.select().from(socialMediaAnalytics).where(
          and4(
            eq4(socialMediaAnalytics.businessId, businessId),
            gte(socialMediaAnalytics.metricDate, dateRange.start.toISOString().split("T")[0]),
            lte(socialMediaAnalytics.metricDate, dateRange.end.toISOString().split("T")[0])
          )
        );
      }
      async fetchPlatformAnalytics(account, dateRange) {
        const metrics = [];
        const currentDate = new Date(dateRange.start);
        while (currentDate <= dateRange.end) {
          metrics.push({
            accountId: account.id,
            businessId: account.businessId,
            platform: account.platform,
            metricDate: currentDate.toISOString().split("T")[0],
            metricType: "account",
            impressions: Math.floor(Math.random() * 1e4),
            reach: Math.floor(Math.random() * 8e3),
            engagements: Math.floor(Math.random() * 500),
            likes: Math.floor(Math.random() * 300),
            comments: Math.floor(Math.random() * 100),
            shares: Math.floor(Math.random() * 50),
            followerCount: Math.floor(Math.random() * 5e3),
            followerGrowth: Math.floor(Math.random() * 100) - 50
          });
          currentDate.setDate(currentDate.getDate() + 1);
        }
        return metrics;
      }
      // Message & Inbox Management
      async fetchMessages(businessId) {
        const accounts = await db.select().from(socialMediaAccounts).where(
          and4(
            eq4(socialMediaAccounts.businessId, businessId),
            eq4(socialMediaAccounts.isActive, true)
          )
        );
        for (const account of accounts) {
          await this.fetchPlatformMessages(account);
        }
      }
      async fetchPlatformMessages(account) {
        const messages2 = await this.getPlatformMessages(account);
        if (messages2.length > 0) {
          await db.insert(socialMediaMessages).values(messages2).onConflictDoNothing();
        }
      }
      async getPlatformMessages(account) {
        return [];
      }
      async sendMessage(messageId, response) {
        const [message] = await db.select().from(socialMediaMessages).where(eq4(socialMediaMessages.id, messageId)).limit(1);
        if (!message) {
          throw new Error("Message not found");
        }
        const [account] = await db.select().from(socialMediaAccounts).where(eq4(socialMediaAccounts.id, message.accountId)).limit(1);
        if (!account) {
          throw new Error("Account not found");
        }
        await this.sendPlatformMessage(account, message, response);
        await db.update(socialMediaMessages).set({
          status: "replied",
          repliedAt: /* @__PURE__ */ new Date(),
          responseTime: Math.floor(((/* @__PURE__ */ new Date()).getTime() - message.createdAt.getTime()) / 1e3)
        }).where(eq4(socialMediaMessages.id, messageId));
      }
      async sendPlatformMessage(account, message, response) {
        switch (account.platform) {
          case "facebook":
          case "instagram":
            await this.sendMetaMessage(account, message, response);
            break;
          case "twitter":
            await this.sendTwitterMessage(account, message, response);
            break;
        }
      }
      async sendMetaMessage(account, message, response) {
        console.log(`Sending message via ${account.platform}: ${response}`);
      }
      async sendTwitterMessage(account, message, response) {
        console.log(`Sending Twitter DM: ${response}`);
      }
      // Content Suggestions
      async generateHashtags(content, platform) {
        const hashtags = [];
        const words = content.toLowerCase().split(/\s+/);
        const commonWords = ["the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for"];
        const keywords = words.filter((w) => w.length > 4 && !commonWords.includes(w));
        const hashtagLimits = {
          instagram: 30,
          twitter: 2,
          facebook: 10,
          linkedin: 3,
          tiktok: 100,
          pinterest: 20
        };
        const limit = hashtagLimits[platform] || 10;
        for (let i = 0; i < Math.min(keywords.length, limit); i++) {
          hashtags.push(`#${keywords[i]}`);
        }
        hashtags.push("#trending", "#viral", `#${platform}`);
        return hashtags.slice(0, limit);
      }
      async suggestOptimalTimes(businessId, platform) {
        const analytics = await db.select().from(socialMediaAnalytics).where(
          and4(
            eq4(socialMediaAnalytics.businessId, businessId),
            eq4(socialMediaAnalytics.platform, platform)
          )
        ).orderBy(desc2(socialMediaAnalytics.engagementRate)).limit(10);
        if (analytics.length === 0) {
          const defaults = OPTIMAL_POSTING_TIMES[platform];
          const isWeekday = (/* @__PURE__ */ new Date()).getDay() >= 1 && (/* @__PURE__ */ new Date()).getDay() <= 5;
          return isWeekday ? defaults.weekdays : defaults.weekends;
        }
        return OPTIMAL_POSTING_TIMES[platform].weekdays;
      }
      // Campaign Management
      async createCampaign(data) {
        const [campaign] = await db.insert(socialMediaCampaigns).values(data).returning();
        return campaign;
      }
      async updateCampaignMetrics(campaignId) {
        const posts2 = await db.select().from(socialMediaPosts).where(eq4(socialMediaPosts.campaignId, campaignId));
        const postIds = posts2.map((p) => p.id);
        if (postIds.length > 0) {
          const metrics = await db.select({
            totalImpressions: sql3`SUM(impressions)`,
            totalEngagements: sql3`SUM(engagements)`,
            totalReach: sql3`SUM(reach)`
          }).from(socialMediaAnalytics).where(inArray2(socialMediaAnalytics.postId, postIds));
          await db.update(socialMediaCampaigns).set({
            postCount: posts2.length,
            totalImpressions: metrics[0]?.totalImpressions || 0,
            totalEngagements: metrics[0]?.totalEngagements || 0,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq4(socialMediaCampaigns.id, campaignId));
        }
      }
      // Social Listening
      async createListener(data) {
        const [listener] = await db.insert(socialMediaListeners).values(data).returning();
        await this.startMonitoring(listener);
        return listener;
      }
      async startMonitoring(listener) {
        console.log(`Started monitoring: ${listener.name}`);
      }
      async checkMentions(businessId) {
        const listeners = await db.select().from(socialMediaListeners).where(
          and4(
            eq4(socialMediaListeners.businessId, businessId),
            eq4(socialMediaListeners.isActive, true)
          )
        );
        const mentions = [];
        for (const listener of listeners) {
          const newMentions = await this.fetchMentionsForListener(listener);
          mentions.push(...newMentions);
        }
        if (mentions.length > 0) {
          await db.insert(socialMediaMentions).values(mentions).onConflictDoNothing();
        }
        return db.select().from(socialMediaMentions).where(eq4(socialMediaMentions.businessId, businessId)).orderBy(desc2(socialMediaMentions.mentionedAt)).limit(100);
      }
      async fetchMentionsForListener(listener) {
        return [];
      }
      // Automation
      async createAutomation(data) {
        const [automation] = await db.insert(socialMediaAutomation).values(data).returning();
        await this.setupAutomationTriggers(automation);
        return automation;
      }
      async setupAutomationTriggers(automation) {
        console.log(`Automation setup: ${automation.name}`);
      }
      async runAutomation(automationId) {
        const [automation] = await db.select().from(socialMediaAutomation).where(eq4(socialMediaAutomation.id, automationId)).limit(1);
        if (!automation || !automation.isActive) {
          return;
        }
        await this.executeAutomationAction(automation);
        await db.update(socialMediaAutomation).set({
          lastTriggeredAt: /* @__PURE__ */ new Date(),
          triggerCount: (automation.triggerCount || 0) + 1
        }).where(eq4(socialMediaAutomation.id, automationId));
      }
      async executeAutomationAction(automation) {
        const actionConfig = automation.actionConfig;
        switch (automation.actionType) {
          case "post":
            await this.createPost({
              businessId: automation.businessId,
              authorId: "system",
              content: actionConfig.content,
              contentType: "text",
              platforms: automation.platforms,
              status: "published"
            });
            break;
          case "message":
            console.log("Sending automated message");
            break;
          case "email":
            console.log("Sending automated email");
            break;
        }
      }
      // Team Collaboration
      async addTeamMember(data) {
        const [member] = await db.insert(socialMediaTeam).values(data).returning();
        return member;
      }
      async updateTeamMemberPermissions(memberId, permissions) {
        await db.update(socialMediaTeam).set(permissions).where(eq4(socialMediaTeam.id, memberId));
      }
      async getTeamMembers(businessId) {
        return db.select().from(socialMediaTeam).where(
          and4(
            eq4(socialMediaTeam.businessId, businessId),
            eq4(socialMediaTeam.isActive, true)
          )
        );
      }
      // Bulk Operations
      async bulkSchedulePosts(csvData, businessId, authorId) {
        const posts2 = [];
        for (const row of csvData) {
          posts2.push({
            businessId,
            authorId,
            content: row.content,
            contentType: row.contentType || "text",
            platforms: row.platforms.split(","),
            scheduledAt: new Date(row.scheduledAt),
            status: "scheduled",
            hashtags: row.hashtags?.split(",") || [],
            mediaUrls: row.mediaUrls?.split(",") || []
          });
        }
        const insertedPosts = await db.insert(socialMediaPosts).values(posts2).returning();
        for (const post of insertedPosts) {
          await this.schedulePost(post);
        }
        return insertedPosts;
      }
      // Content Categories
      async createCategory(data) {
        const [category] = await db.insert(socialContentCategories).values(data).returning();
        return category;
      }
      async getCategories(businessId) {
        return db.select().from(socialContentCategories).where(
          and4(
            eq4(socialContentCategories.businessId, businessId),
            eq4(socialContentCategories.isActive, true)
          )
        );
      }
      // Response Templates
      async createResponseTemplate(data) {
        const [template] = await db.insert(socialResponseTemplates).values(data).returning();
        return template;
      }
      async getResponseTemplates(businessId) {
        return db.select().from(socialResponseTemplates).where(
          and4(
            eq4(socialResponseTemplates.businessId, businessId),
            eq4(socialResponseTemplates.isActive, true)
          )
        );
      }
      async useResponseTemplate(templateId) {
        const [template] = await db.select().from(socialResponseTemplates).where(eq4(socialResponseTemplates.id, templateId)).limit(1);
        if (!template) {
          throw new Error("Template not found");
        }
        await db.update(socialResponseTemplates).set({ useCount: (template.useCount || 0) + 1 }).where(eq4(socialResponseTemplates.id, templateId));
        return template.content;
      }
      // Additional methods for API routes
      async getAccounts(businessId) {
        return db.select().from(socialMediaAccounts).where(
          and4(
            eq4(socialMediaAccounts.businessId, businessId),
            eq4(socialMediaAccounts.isActive, true)
          )
        );
      }
    };
    socialMediaService = new SocialMediaService();
  }
});

// server/blogService.ts
import { eq as eq5, desc as desc3, asc, sql as sql4, and as and5, or as or3, like as like3, inArray as inArray3, between, gte as gte2, ne, isNull } from "drizzle-orm";
import { nanoid } from "nanoid";
var BlogService, blogService;
var init_blogService = __esm({
  "server/blogService.ts"() {
    "use strict";
    init_schema();
    init_db();
    BlogService = class {
      // ========== POST MANAGEMENT ==========
      async createPost(data) {
        const slug = await this.generateUniqueSlug(data.title);
        const seoData = {
          ...data,
          slug,
          metaTitle: data.metaTitle || this.generateMetaTitle(data.title),
          metaDescription: data.metaDescription || this.generateMetaDescription(data.excerpt || data.content),
          canonicalUrl: data.canonicalUrl || `/blog/${slug}`
        };
        const [post] = await db.insert(blogPosts).values(seoData).returning();
        await this.createRevision(post.id, post, "Initial version");
        if (post.status === "draft") {
          this.scheduleAutoSave(post.id);
        }
        return post;
      }
      async updatePost(id, data) {
        const existing = await this.getPostById(id);
        if (!existing) throw new Error("Post not found");
        if (data.content && data.content !== existing.content) {
          await this.createRevision(id, { ...existing, ...data }, "Content update");
        }
        if (data.title && !data.metaTitle) {
          data.metaTitle = this.generateMetaTitle(data.title);
        }
        const [updated] = await db.update(blogPosts).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date(),
          version: sql4`${blogPosts.version} + 1`
        }).where(eq5(blogPosts.id, id)).returning();
        return updated;
      }
      async deletePost(id) {
        await db.delete(blogPosts).where(eq5(blogPosts.id, id));
      }
      async getPostById(id) {
        const [post] = await db.select().from(blogPosts).where(eq5(blogPosts.id, id)).limit(1);
        return post || null;
      }
      async getPostBySlug(slug) {
        const [post] = await db.select().from(blogPosts).where(eq5(blogPosts.slug, slug)).limit(1);
        if (post) {
          this.trackView(post.id).catch(console.error);
        }
        return post || null;
      }
      async searchPosts(params) {
        const { page = 1, limit = 10, sort = "newest" } = params;
        const offset = (page - 1) * limit;
        let query = db.select().from(blogPosts).$dynamic();
        const conditions = [];
        if (params.query) {
          conditions.push(
            or3(
              like3(blogPosts.title, `%${params.query}%`),
              like3(blogPosts.content, `%${params.query}%`),
              like3(blogPosts.excerpt, `%${params.query}%`)
            )
          );
        }
        if (params.categoryId) {
          conditions.push(eq5(blogPosts.categoryId, params.categoryId));
        }
        if (params.authorId) {
          conditions.push(eq5(blogPosts.authorId, params.authorId));
        }
        if (params.status) {
          conditions.push(eq5(blogPosts.status, params.status));
        }
        if (params.startDate && params.endDate) {
          conditions.push(
            between(blogPosts.publishedAt, params.startDate, params.endDate)
          );
        }
        if (conditions.length > 0) {
          query = query.where(and5(...conditions));
        }
        switch (sort) {
          case "popular":
            query = query.orderBy(desc3(blogPosts.viewCount));
            break;
          case "trending":
            query = query.orderBy(desc3(sql4`${blogPosts.viewCount} * EXP(-EXTRACT(EPOCH FROM (NOW() - ${blogPosts.publishedAt})) / 604800)`));
            break;
          default:
            query = query.orderBy(desc3(blogPosts.publishedAt));
        }
        const results = await query.limit(limit).offset(offset);
        const [{ count: count2 }] = await db.select({ count: sql4`COUNT(*)`.as() }).from(blogPosts).where(conditions.length > 0 ? and5(...conditions) : void 0);
        return {
          posts: results,
          pagination: {
            page,
            limit,
            total: count2,
            pages: Math.ceil(count2 / limit)
          }
        };
      }
      async getRelatedPosts(postId, limit = 5) {
        const post = await this.getPostById(postId);
        if (!post) return [];
        const related = await db.select({
          post: blogPosts,
          score: sql4`
          CASE WHEN ${blogPosts.categoryId} = ${post.categoryId} THEN 3 ELSE 0 END +
          (SELECT COUNT(*) FROM ${blogPostTags} t1 
           JOIN ${blogPostTags} t2 ON t1.tag_id = t2.tag_id 
           WHERE t1.post_id = ${post.id} AND t2.post_id = ${blogPosts.id})
        `.as("score")
        }).from(blogPosts).where(
          and5(
            ne(blogPosts.id, postId),
            eq5(blogPosts.status, "published")
          )
        ).orderBy(desc3(sql4`score`), desc3(blogPosts.publishedAt)).limit(limit);
        return related.map((r) => r.post);
      }
      // ========== CATEGORY & TAG MANAGEMENT ==========
      async createCategory(data) {
        const slug = this.generateSlug(data.name);
        const [category] = await db.insert(blogCategories).values({ ...data, slug }).returning();
        return category;
      }
      async updateCategory(id, data) {
        if (data.name) {
          data.slug = this.generateSlug(data.name);
        }
        const [updated] = await db.update(blogCategories).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(blogCategories.id, id)).returning();
        return updated;
      }
      async getCategories() {
        return db.select().from(blogCategories).where(eq5(blogCategories.isActive, true)).orderBy(asc(blogCategories.name));
      }
      async createTag(data) {
        const slug = this.generateSlug(data.name);
        const [tag] = await db.insert(blogTags).values({ ...data, slug }).returning();
        return tag;
      }
      async getTags() {
        return db.select().from(blogTags).orderBy(desc3(blogTags.postCount));
      }
      async attachTagsToPost(postId, tagIds) {
        const values = tagIds.map((tagId) => ({
          postId,
          tagId
        }));
        await db.insert(blogPostTags).values(values).onConflictDoNothing();
        await db.update(blogTags).set({
          postCount: sql4`${blogTags.postCount} + 1`
        }).where(inArray3(blogTags.id, tagIds));
      }
      // ========== COMMENT SYSTEM ==========
      async createComment(data) {
        const [comment] = await db.insert(blogComments).values(data).returning();
        await db.update(blogPosts).set({ commentCount: sql4`${blogPosts.commentCount} + 1` }).where(eq5(blogPosts.id, data.postId));
        if (data.parentCommentId) {
          await db.update(blogComments).set({ replyCount: sql4`${blogComments.replyCount} + 1` }).where(eq5(blogComments.id, data.parentCommentId));
        }
        return comment;
      }
      async updateComment(id, data) {
        const [updated] = await db.update(blogComments).set({
          ...data,
          isEdited: true,
          editedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq5(blogComments.id, id)).returning();
        return updated;
      }
      async deleteComment(id) {
        const comment = await db.select().from(blogComments).where(eq5(blogComments.id, id)).limit(1);
        if (comment.length > 0) {
          await db.delete(blogComments).where(eq5(blogComments.id, id));
          await db.update(blogPosts).set({ commentCount: sql4`${blogPosts.commentCount} - 1` }).where(eq5(blogPosts.id, comment[0].postId));
        }
      }
      async getComments(postId, options) {
        const { page = 1, limit = 20, sortBy = "newest", parentId = null } = options || {};
        const offset = (page - 1) * limit;
        let query = db.select().from(blogComments).where(
          and5(
            eq5(blogComments.postId, postId),
            eq5(blogComments.isApproved, true),
            parentId ? eq5(blogComments.parentCommentId, parentId) : isNull(blogComments.parentCommentId)
          )
        ).$dynamic();
        switch (sortBy) {
          case "oldest":
            query = query.orderBy(asc(blogComments.createdAt));
            break;
          case "popular":
            query = query.orderBy(desc3(blogComments.likeCount), desc3(blogComments.createdAt));
            break;
          default:
            query = query.orderBy(desc3(blogComments.createdAt));
        }
        return query.limit(limit).offset(offset);
      }
      async moderateComment(id, approved) {
        await db.update(blogComments).set({ isApproved: approved }).where(eq5(blogComments.id, id));
      }
      // ========== REACTIONS & BOOKMARKS ==========
      async addReaction(data) {
        const [reaction] = await db.insert(blogReactions).values(data).onConflictDoUpdate({
          target: [blogReactions.postId, blogReactions.userId, blogReactions.reactionType],
          set: {
            count: sql4`${blogReactions.count} + 1`,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        await db.update(blogPosts).set({ likeCount: sql4`${blogPosts.likeCount} + 1` }).where(eq5(blogPosts.id, data.postId));
        return reaction;
      }
      async removeReaction(postId, userId, reactionType = "like") {
        await db.delete(blogReactions).where(
          and5(
            eq5(blogReactions.postId, postId),
            eq5(blogReactions.userId, userId),
            eq5(blogReactions.reactionType, reactionType)
          )
        );
        await db.update(blogPosts).set({ likeCount: sql4`${blogPosts.likeCount} - 1` }).where(eq5(blogPosts.id, postId));
      }
      async bookmarkPost(data) {
        const [bookmark] = await db.insert(blogBookmarks).values(data).onConflictDoNothing().returning();
        if (bookmark) {
          await db.update(blogPosts).set({ bookmarkCount: sql4`${blogPosts.bookmarkCount} + 1` }).where(eq5(blogPosts.id, data.postId));
        }
        return bookmark;
      }
      async removeBookmark(postId, userId) {
        await db.delete(blogBookmarks).where(
          and5(
            eq5(blogBookmarks.postId, postId),
            eq5(blogBookmarks.userId, userId)
          )
        );
        await db.update(blogPosts).set({ bookmarkCount: sql4`${blogPosts.bookmarkCount} - 1` }).where(eq5(blogPosts.id, postId));
      }
      // ========== SUBSCRIPTIONS & NEWSLETTERS ==========
      async subscribe(data) {
        const unsubscribeToken = nanoid(32);
        const [subscription] = await db.insert(blogSubscriptions).values({ ...data, unsubscribeToken }).onConflictDoUpdate({
          target: blogSubscriptions.email,
          set: {
            ...data,
            isActive: true,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        this.sendSubscriptionConfirmation(subscription).catch(console.error);
        return subscription;
      }
      async unsubscribe(token) {
        await db.update(blogSubscriptions).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(blogSubscriptions.unsubscribeToken, token));
      }
      async getSubscribers(options) {
        let query = db.select().from(blogSubscriptions).$dynamic();
        const conditions = [];
        if (options?.active !== void 0) {
          conditions.push(eq5(blogSubscriptions.isActive, options.active));
        }
        if (options?.frequency) {
          conditions.push(eq5(blogSubscriptions.frequency, options.frequency));
        }
        if (conditions.length > 0) {
          query = query.where(and5(...conditions));
        }
        return query;
      }
      // ========== ANALYTICS & TRACKING ==========
      async trackView(postId, data) {
        await db.insert(blogAnalytics).values({
          postId,
          viewType: "page_view",
          ...data
        });
        await db.update(blogPosts).set({
          viewCount: sql4`${blogPosts.viewCount} + 1`
        }).where(eq5(blogPosts.id, postId));
      }
      async trackEngagement(postId, type, data) {
        if (type === "share") {
          await db.update(blogPosts).set({ shareCount: sql4`${blogPosts.shareCount} + 1` }).where(eq5(blogPosts.id, postId));
        }
        await db.insert(blogAnalytics).values({
          postId,
          viewType: type,
          ...data
        });
      }
      async getPostAnalytics(postId, period) {
        const conditions = [eq5(blogAnalytics.postId, postId)];
        if (period) {
          conditions.push(between(blogAnalytics.viewedAt, period.start, period.end));
        }
        const [stats] = await db.select({
          totalViews: sql4`COUNT(*)`.as(),
          uniqueViews: sql4`COUNT(DISTINCT session_id)`.as(),
          avgTimeSpent: sql4`AVG(time_spent_seconds)`.as(),
          avgScrollDepth: sql4`AVG(scroll_depth)`.as(),
          completionRate: sql4`
          (COUNT(*) FILTER (WHERE view_type = 'read_complete')::float / 
           NULLIF(COUNT(*) FILTER (WHERE view_type = 'page_view'), 0) * 100)
        `.as()
        }).from(blogAnalytics).where(and5(...conditions));
        return stats;
      }
      async getPopularPosts(limit = 10, period = 30) {
        const periodDate = /* @__PURE__ */ new Date();
        periodDate.setDate(periodDate.getDate() - period);
        return db.select().from(blogPosts).where(
          and5(
            eq5(blogPosts.status, "published"),
            gte2(blogPosts.publishedAt, periodDate)
          )
        ).orderBy(desc3(blogPosts.viewCount)).limit(limit);
      }
      // ========== VERSION CONTROL ==========
      async createRevision(postId, data, changesSummary) {
        const post = await this.getPostById(postId);
        if (!post) return;
        await db.insert(blogRevisions).values({
          postId,
          version: post.version,
          editedBy: data.lastEditedBy || data.authorId,
          title: data.title,
          content: data.content,
          excerpt: data.excerpt,
          changesSummary
        });
      }
      async getRevisions(postId) {
        return db.select().from(blogRevisions).where(eq5(blogRevisions.postId, postId)).orderBy(desc3(blogRevisions.version));
      }
      async restoreRevision(postId, revisionId) {
        const [revision] = await db.select().from(blogRevisions).where(eq5(blogRevisions.id, revisionId)).limit(1);
        if (!revision) throw new Error("Revision not found");
        return this.updatePost(postId, {
          title: revision.title,
          content: revision.content,
          excerpt: revision.excerpt || void 0
        });
      }
      // ========== SEO OPTIMIZATION ==========
      async analyzeSEO(post) {
        const issues = [];
        const warnings = [];
        const suggestions = [];
        const titleLength = post.metaTitle?.length || 0;
        if (titleLength === 0) {
          issues.push("Meta title is missing");
        } else if (titleLength < 30) {
          warnings.push("Meta title is too short (recommended: 30-60 characters)");
        } else if (titleLength > 60) {
          warnings.push("Meta title is too long (maximum: 60 characters)");
        }
        const descLength = post.metaDescription?.length || 0;
        if (descLength === 0) {
          issues.push("Meta description is missing");
        } else if (descLength < 120) {
          warnings.push("Meta description is too short (recommended: 120-160 characters)");
        } else if (descLength > 160) {
          warnings.push("Meta description is too long (maximum: 160 characters)");
        }
        const content = post.content;
        const headings = this.analyzeHeadings(content);
        if (headings.h1 === 0) {
          issues.push("No H1 heading found");
        } else if (headings.h1 > 1) {
          warnings.push("Multiple H1 headings found (should have only one)");
        }
        const imageAnalysis = this.analyzeImages(content);
        if (imageAnalysis.missing > 0) {
          warnings.push(`${imageAnalysis.missing} images are missing alt text`);
        }
        const keywordDensity = this.calculateKeywordDensity(content);
        const readabilityScore = this.calculateReadability(content);
        if (readabilityScore < 30) {
          warnings.push("Content readability is poor");
        }
        const estimatedReadingTime = this.calculateReadingTime(content);
        const links = this.analyzeLinks(content);
        if (links.internal < 2) {
          suggestions.push("Add more internal links to improve site navigation");
        }
        if (!post.featuredImageUrl) {
          warnings.push("No featured image set");
        }
        if (!post.canonicalUrl) {
          issues.push("Canonical URL is not set");
        }
        const score = this.calculateSEOScore({
          issues: issues.length,
          warnings: warnings.length,
          titleLength,
          descLength,
          headings,
          readabilityScore,
          hasImages: imageAnalysis.total > 0,
          hasFeaturedImage: !!post.featuredImageUrl
        });
        return {
          score,
          issues,
          warnings,
          suggestions,
          metaTitleLength: titleLength,
          metaDescriptionLength: descLength,
          headingStructure: headings,
          keywordDensity,
          readabilityScore,
          estimatedReadingTime,
          imageAltTexts: imageAnalysis,
          internalLinks: links.internal,
          externalLinks: links.external
        };
      }
      generateStructuredData(post, author, siteInfo) {
        return {
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          headline: post.title,
          description: post.metaDescription || post.excerpt || "",
          image: post.featuredImageUrl ? [post.featuredImageUrl] : void 0,
          datePublished: post.publishedAt?.toISOString() || post.createdAt.toISOString(),
          dateModified: post.updatedAt.toISOString(),
          author: {
            "@type": "Person",
            name: `${author.firstName} ${author.lastName}`,
            url: `/author/${author.id}`
          },
          publisher: {
            "@type": "Organization",
            name: siteInfo.name || "The Florida Local",
            logo: {
              "@type": "ImageObject",
              url: siteInfo.logo || "/logo.png"
            }
          },
          mainEntityOfPage: {
            "@type": "WebPage",
            "@id": `${siteInfo.url}/blog/${post.slug}`
          }
        };
      }
      generateOpenGraphTags(post, siteInfo) {
        return {
          "og:title": post.metaTitle || post.title,
          "og:description": post.metaDescription || post.excerpt || "",
          "og:type": "article",
          "og:url": `${siteInfo.url}/blog/${post.slug}`,
          "og:image": post.ogImage || post.featuredImageUrl || siteInfo.defaultOgImage,
          "og:site_name": siteInfo.name || "The Florida Local",
          "article:published_time": post.publishedAt?.toISOString() || "",
          "article:modified_time": post.updatedAt.toISOString(),
          "article:author": post.authorId
        };
      }
      generateTwitterCardTags(post) {
        return {
          "twitter:card": "summary_large_image",
          "twitter:title": post.metaTitle || post.title,
          "twitter:description": post.metaDescription || post.excerpt || "",
          "twitter:image": post.ogImage || post.featuredImageUrl || ""
        };
      }
      async generateSitemap(baseUrl) {
        const posts2 = await db.select().from(blogPosts).where(eq5(blogPosts.status, "published")).orderBy(desc3(blogPosts.publishedAt));
        const urls = posts2.map((post) => `
      <url>
        <loc>${baseUrl}/blog/${post.slug}</loc>
        <lastmod>${post.updatedAt.toISOString()}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
      </url>
    `).join("");
        return `<?xml version="1.0" encoding="UTF-8"?>
      <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
        ${urls}
      </urlset>`;
      }
      async generateRSSFeed(baseUrl, limit = 20) {
        const posts2 = await db.select().from(blogPosts).where(eq5(blogPosts.status, "published")).orderBy(desc3(blogPosts.publishedAt)).limit(limit);
        const items = posts2.map((post) => `
      <item>
        <title><![CDATA[${post.title}]]></title>
        <description><![CDATA[${post.excerpt || ""}]]></description>
        <link>${baseUrl}/blog/${post.slug}</link>
        <guid isPermaLink="true">${baseUrl}/blog/${post.slug}</guid>
        <pubDate>${post.publishedAt?.toUTCString() || ""}</pubDate>
      </item>
    `).join("");
        return `<?xml version="1.0" encoding="UTF-8"?>
      <rss version="2.0">
        <channel>
          <title>The Florida Local Blog</title>
          <description>Business insights and local stories from Florida</description>
          <link>${baseUrl}/blog</link>
          <language>en-US</language>
          <lastBuildDate>${(/* @__PURE__ */ new Date()).toUTCString()}</lastBuildDate>
          ${items}
        </channel>
      </rss>`;
      }
      // ========== HELPER METHODS ==========
      generateSlug(text2) {
        return text2.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
      }
      async generateUniqueSlug(title) {
        const baseSlug = this.generateSlug(title);
        let slug = baseSlug;
        let counter = 1;
        while (true) {
          const existing = await db.select().from(blogPosts).where(eq5(blogPosts.slug, slug)).limit(1);
          if (existing.length === 0) break;
          slug = `${baseSlug}-${counter}`;
          counter++;
        }
        return slug;
      }
      generateMetaTitle(title) {
        if (title.length <= 60) return title;
        return title.substring(0, 57) + "...";
      }
      generateMetaDescription(content) {
        const stripped = content.replace(/<[^>]*>/g, "").substring(0, 160);
        return stripped.length === 160 ? stripped.substring(0, 157) + "..." : stripped;
      }
      analyzeHeadings(content) {
        const h1Matches = content.match(/<h1[^>]*>/gi) || [];
        const h2Matches = content.match(/<h2[^>]*>/gi) || [];
        const h3Matches = content.match(/<h3[^>]*>/gi) || [];
        return {
          h1: h1Matches.length,
          h2: h2Matches.length,
          h3: h3Matches.length
        };
      }
      analyzeImages(content) {
        const imgMatches = content.match(/<img[^>]*>/gi) || [];
        const altMissing = imgMatches.filter((img) => !img.includes("alt=")).length;
        return {
          missing: altMissing,
          total: imgMatches.length
        };
      }
      analyzeLinks(content) {
        const linkMatches = content.match(/<a[^>]*href="([^"]*)"[^>]*>/gi) || [];
        let internal = 0;
        let external = 0;
        linkMatches.forEach((link) => {
          const href = link.match(/href="([^"]*)"/)?.[1] || "";
          if (href.startsWith("http://") || href.startsWith("https://")) {
            external++;
          } else if (href.startsWith("/")) {
            internal++;
          }
        });
        return { internal, external };
      }
      calculateKeywordDensity(content) {
        const text2 = content.replace(/<[^>]*>/g, "").toLowerCase();
        const words = text2.match(/\b[a-z]{3,}\b/g) || [];
        const wordCount = /* @__PURE__ */ new Map();
        words.forEach((word) => {
          wordCount.set(word, (wordCount.get(word) || 0) + 1);
        });
        const density = /* @__PURE__ */ new Map();
        const totalWords = words.length;
        wordCount.forEach((count2, word) => {
          if (count2 > 2) {
            density.set(word, count2 / totalWords * 100);
          }
        });
        return density;
      }
      calculateReadability(content) {
        const text2 = content.replace(/<[^>]*>/g, "");
        const sentences = text2.split(/[.!?]+/).filter((s) => s.trim().length > 0);
        const words = text2.match(/\b\w+\b/g) || [];
        const syllables = words.reduce((count2, word) => count2 + this.countSyllables(word), 0);
        if (sentences.length === 0 || words.length === 0) return 0;
        const score = 206.835 - 1.015 * (words.length / sentences.length) - 84.6 * (syllables / words.length);
        return Math.max(0, Math.min(100, score));
      }
      countSyllables(word) {
        word = word.toLowerCase();
        let count2 = 0;
        let previousWasVowel = false;
        for (let i = 0; i < word.length; i++) {
          const isVowel = /[aeiou]/.test(word[i]);
          if (isVowel && !previousWasVowel) {
            count2++;
          }
          previousWasVowel = isVowel;
        }
        if (word.endsWith("e")) {
          count2--;
        }
        return Math.max(1, count2);
      }
      calculateReadingTime(content) {
        const text2 = content.replace(/<[^>]*>/g, "");
        const words = text2.match(/\b\w+\b/g) || [];
        const wordsPerMinute = 200;
        return Math.ceil(words.length / wordsPerMinute);
      }
      calculateSEOScore(factors) {
        let score = 100;
        score -= factors.issues * 10;
        score -= factors.warnings * 5;
        if (factors.titleLength < 30 || factors.titleLength > 60) {
          score -= 5;
        }
        if (factors.descLength < 120 || factors.descLength > 160) {
          score -= 5;
        }
        if (factors.headings.h1 !== 1) {
          score -= 10;
        }
        if (factors.readabilityScore < 30) {
          score -= 10;
        } else if (factors.readabilityScore < 50) {
          score -= 5;
        }
        if (!factors.hasImages) {
          score -= 5;
        }
        if (!factors.hasFeaturedImage) {
          score -= 5;
        }
        return Math.max(0, Math.min(100, score));
      }
      scheduleAutoSave(postId) {
        console.log(`Auto-save scheduled for post ${postId}`);
      }
      async sendSubscriptionConfirmation(subscription) {
        console.log(`Sending confirmation email to ${subscription.email}`);
      }
    };
    blogService = new BlogService();
  }
});

// server/websocket.ts
var websocket_exports = {};
__export(websocket_exports, {
  broadcastBusinessUpdate: () => broadcastBusinessUpdate,
  broadcastOrderUpdate: () => broadcastOrderUpdate,
  getOnlineUsersCount: () => getOnlineUsersCount,
  getUserSockets: () => getUserSockets,
  initWebSocket: () => initWebSocket,
  io: () => io,
  sendMessage: () => sendMessage,
  sendNotification: () => sendNotification
});
import { Server as SocketIOServer } from "socket.io";
import { createAdapter } from "@socket.io/redis-adapter";
import passport3 from "passport";
function wrap(middleware) {
  return (socket, next) => middleware(socket.request, {}, next);
}
async function initWebSocket(httpServer) {
  io = new SocketIOServer(httpServer, {
    cors: {
      origin: process.env.NODE_ENV === "production" ? (process.env.REPLIT_DOMAINS || "").split(",").map((d) => `https://${d.trim()}`) : true,
      credentials: true
    },
    transports: ["websocket", "polling"]
  });
  const { middleware: sessionMiddleware } = await initializeSession(config);
  io.use(wrap(sessionMiddleware));
  io.use(wrap(passport3.initialize()));
  io.use(wrap(passport3.session()));
  const attachRedisAdapter = () => {
    if (redis.status === "ready" && redisSubscriber.status === "ready") {
      try {
        io.adapter(createAdapter(redis, redisSubscriber));
        logger.info("\u2705 Socket.IO using Redis adapter");
      } catch (error) {
        logger.error("Failed to attach Redis adapter", { error });
      }
    }
  };
  attachRedisAdapter();
  redis.on("ready", () => {
    logger.info("Redis became ready, attempting to attach adapter");
    attachRedisAdapter();
  });
  io.use(async (socket, next) => {
    try {
      const req = socket.request;
      if (!req.user || !req.isAuthenticated || !req.isAuthenticated()) {
        logger.warn("WebSocket connection rejected: Not authenticated");
        return next(new Error("Authentication required"));
      }
      const userId = req.user.claims?.sub;
      if (!userId) {
        logger.warn("WebSocket connection rejected: No user ID in session");
        return next(new Error("Invalid session"));
      }
      const user = await storage.getUserById(userId);
      if (!user) {
        logger.warn("WebSocket connection rejected: User not found", { userId });
        return next(new Error("User not found"));
      }
      socket.userId = userId;
      socket.user = user;
      logger.info("WebSocket authentication successful", { userId, socketId: socket.id });
      next();
    } catch (error) {
      logger.error("Socket authentication error", { error });
      next(new Error("Authentication failed"));
    }
  });
  io.on("connection", async (socket) => {
    logger.info("Socket connected", {
      socketId: socket.id,
      userId: socket.userId
    });
    trackEvent(socket.userId, "websocket_connected", {
      socketId: socket.id
    });
    socket.join(`user:${socket.userId}`);
    const businesses3 = await storage.getBusinessesByOwner(socket.userId);
    for (const business of businesses3) {
      socket.join(`business:${business.id}`);
      socket.businessId = business.id;
    }
    socket.on("join:conversation", async (conversationId) => {
      try {
        const hasAccess = await storage.userHasAccessToConversation(
          socket.userId,
          conversationId
        );
        if (hasAccess) {
          socket.join(`conversation:${conversationId}`);
          logger.info("User joined conversation", {
            userId: socket.userId,
            conversationId
          });
          socket.to(`conversation:${conversationId}`).emit("user:joined", {
            userId: socket.userId,
            conversationId
          });
        } else {
          logger.warn("User denied access to conversation", {
            userId: socket.userId,
            conversationId
          });
        }
      } catch (error) {
        logger.error("Error joining conversation", { error, conversationId });
      }
    });
    socket.on("leave:conversation", async (conversationId) => {
      try {
        socket.leave(`conversation:${conversationId}`);
        logger.info("User left conversation", {
          userId: socket.userId,
          conversationId
        });
        socket.to(`conversation:${conversationId}`).emit("user:left", {
          userId: socket.userId,
          conversationId
        });
      } catch (error) {
        logger.error("Error leaving conversation", { error, conversationId });
      }
    });
    socket.on("typing:start", (data) => {
      socket.to(`conversation:${data.conversationId}`).emit("typing:start", {
        userId: socket.userId,
        conversationId: data.conversationId
      });
    });
    socket.on("typing:stop", (data) => {
      socket.to(`conversation:${data.conversationId}`).emit("typing:stop", {
        userId: socket.userId,
        conversationId: data.conversationId
      });
    });
    socket.on("presence:update", async (status) => {
      try {
        await storage.updateUserOnlineStatus(socket.userId, status);
        const connections = await storage.getUserConnections(socket.userId);
        for (const connectionId of connections) {
          io.to(`user:${connectionId}`).emit("presence:updated", {
            userId: socket.userId,
            status
          });
        }
      } catch (error) {
        logger.error("Error updating presence", { error });
      }
    });
    socket.on("disconnect", async () => {
      logger.info("Socket disconnected", {
        socketId: socket.id,
        userId: socket.userId
      });
      await storage.updateUserOnlineStatus(socket.userId, "offline");
      const connections = await storage.getUserConnections(socket.userId);
      for (const connectionId of connections) {
        io.to(`user:${connectionId}`).emit("presence:updated", {
          userId: socket.userId,
          status: "offline"
        });
      }
      trackEvent(socket.userId, "websocket_disconnected", {
        socketId: socket.id
      });
    });
  });
  const gracefulShutdown2 = async () => {
    logger.info("WebSocket server shutting down gracefully...");
    io.close(() => {
      logger.info("\u2705 WebSocket server closed");
    });
  };
  process.on("SIGTERM", gracefulShutdown2);
  process.on("SIGINT", gracefulShutdown2);
  logger.info("\u2705 WebSocket server initialized");
}
function sendNotification(userId, notification) {
  io.to(`user:${userId}`).emit("notification", notification);
}
function sendMessage(conversationId, message) {
  io.to(`conversation:${conversationId}`).emit("message:new", message);
}
function broadcastBusinessUpdate(businessId, update) {
  io.to(`business:${businessId}`).emit("business:update", update);
}
function broadcastOrderUpdate(userId, order) {
  io.to(`user:${userId}`).emit("order:update", order);
}
async function getOnlineUsersCount() {
  const sockets = await io.fetchSockets();
  return sockets.length;
}
async function getUserSockets(userId) {
  const sockets = await io.in(`user:${userId}`).fetchSockets();
  return sockets.map((s) => s.id);
}
var io;
var init_websocket = __esm({
  "server/websocket.ts"() {
    "use strict";
    init_redis();
    init_monitoring();
    init_storage();
    init_session();
    init_config();
  }
});

// server/aiService.ts
var aiService_exports = {};
__export(aiService_exports, {
  generateAIDashboardInsights: () => generateAIDashboardInsights,
  generateBusinessInsights: () => generateBusinessInsights,
  generateBusinessMetrics: () => generateBusinessMetrics,
  generateEmbedding: () => generateEmbedding,
  generatePlatformContent: () => generatePlatformContent,
  getRecommendations: () => getRecommendations,
  indexBusiness: () => indexBusiness,
  indexProduct: () => indexProduct,
  initializeAI: () => initializeAI,
  initializeVectorIndex: () => initializeVectorIndex,
  openai: () => exportedOpenAI,
  semanticSearch: () => semanticSearch
});
import { OpenAI } from "openai";
import { Pinecone } from "@pinecone-database/pinecone";
async function initializeVectorIndex() {
  if (!pinecone || !process.env.PINECONE_INDEX_NAME) {
    logger.warn("Pinecone not configured - vector search disabled");
    return;
  }
  try {
    const indexName = process.env.PINECONE_INDEX_NAME;
    const indexes = await pinecone.listIndexes();
    if (!indexes.indexes?.some((idx) => idx.name === indexName)) {
      await pinecone.createIndex({
        name: indexName,
        dimension: EMBEDDING_DIMENSION,
        metric: "cosine",
        spec: {
          serverless: {
            cloud: "aws",
            region: process.env.PINECONE_REGION || "us-east-1"
          }
        }
      });
      logger.info("Created Pinecone index", { indexName });
      await new Promise((resolve) => setTimeout(resolve, 5e3));
    }
    vectorIndex = pinecone.index(indexName);
    logger.info("\u2705 Vector index initialized");
  } catch (error) {
    logger.error("Failed to initialize vector index", { error });
  }
}
async function generateEmbedding(text2) {
  if (!openai) {
    logger.warn("OpenAI not configured - cannot generate embeddings");
    return null;
  }
  try {
    const cacheKey = `embedding:${Buffer.from(text2).toString("base64").slice(0, 64)}`;
    const cached = await cache.get(cacheKey);
    if (cached) {
      return cached;
    }
    const response = await openai.embeddings.create({
      model: "text-embedding-ada-002",
      input: text2
    });
    const embedding = response.data[0].embedding;
    await cache.set(cacheKey, embedding, 86400);
    return embedding;
  } catch (error) {
    logger.error("Failed to generate embedding", { error });
    return null;
  }
}
async function indexBusiness(business) {
  if (!vectorIndex) return;
  try {
    const text2 = `${business.name} ${business.tagline || ""} ${business.description || ""} ${business.category || ""} ${business.location || ""}`;
    const embedding = await generateEmbedding(text2);
    if (!embedding) return;
    const metadata = {
      id: business.id,
      type: "business",
      name: business.name,
      description: business.description,
      category: business.category,
      tags: business.tags || [],
      createdAt: business.createdAt
    };
    await vectorIndex.upsert([{
      id: `business_${business.id}`,
      values: embedding,
      metadata
    }]);
    logger.info("Indexed business", { businessId: business.id });
  } catch (error) {
    logger.error("Failed to index business", { error, businessId: business.id });
  }
}
async function indexProduct(product) {
  if (!vectorIndex) return;
  try {
    const text2 = `${product.name} ${product.description || ""} ${product.category || ""} ${product.tags?.join(" ") || ""}`;
    const embedding = await generateEmbedding(text2);
    if (!embedding) return;
    const metadata = {
      id: product.id,
      type: "product",
      name: product.name,
      description: product.description,
      category: product.category,
      tags: product.tags || [],
      createdAt: product.createdAt,
      businessId: product.businessId
    };
    await vectorIndex.upsert([{
      id: `product_${product.id}`,
      values: embedding,
      metadata
    }]);
    logger.info("Indexed product", { productId: product.id });
  } catch (error) {
    logger.error("Failed to index product", { error, productId: product.id });
  }
}
async function semanticSearch(query, filter, limit = 10) {
  if (!vectorIndex || !openai) {
    logger.warn("Vector search not available");
    return [];
  }
  try {
    const queryEmbedding = await generateEmbedding(query);
    if (!queryEmbedding) return [];
    const pineconeFilter = {};
    if (filter?.type) {
      pineconeFilter.type = { $eq: filter.type };
    }
    if (filter?.category) {
      pineconeFilter.category = { $eq: filter.category };
    }
    if (filter?.businessId) {
      pineconeFilter.businessId = { $eq: filter.businessId };
    }
    const results = await vectorIndex.query({
      vector: queryEmbedding,
      topK: limit,
      includeMetadata: true,
      filter: Object.keys(pineconeFilter).length > 0 ? pineconeFilter : void 0
    });
    return results.matches?.map((match) => ({
      id: match.metadata.id,
      score: match.score,
      type: match.metadata.type,
      metadata: match.metadata
    })) || [];
  } catch (error) {
    logger.error("Semantic search failed", { error, query });
    return [];
  }
}
async function getRecommendations(userId, type, limit = 10) {
  try {
    const userHistory = await getUserInteractionHistory(userId);
    const context = buildUserContext(userHistory);
    const contextEmbedding = await generateEmbedding(context);
    if (!contextEmbedding || !vectorIndex) {
      return getPopularItems(type, limit);
    }
    const results = await vectorIndex.query({
      vector: contextEmbedding,
      topK: limit * 2,
      // Get more to filter
      includeMetadata: true,
      filter: { type: { $eq: type } }
    });
    const interactedIds = new Set(userHistory.map((h) => h.itemId));
    const recommendations = results.matches?.filter((match) => !interactedIds.has(match.metadata.id)).slice(0, limit).map((match) => ({
      id: match.metadata.id,
      score: match.score,
      reason: "Based on your interests",
      metadata: match.metadata
    })) || [];
    trackEvent(userId, "recommendations_generated", {
      type,
      count: recommendations.length
    });
    return recommendations;
  } catch (error) {
    logger.error("Failed to get recommendations", { error, userId });
    return getPopularItems(type, limit);
  }
}
async function generateBusinessInsights(businessId) {
  if (!openai) {
    logger.warn("OpenAI not configured - cannot generate insights");
    return null;
  }
  try {
    const business = await storage.getBusinessById(businessId);
    if (!business) return null;
    const metrics = await storage.getBusinessMetrics(businessId);
    const products2 = await storage.getProductsByBusiness(businessId);
    const posts2 = await storage.getPostsByBusiness(businessId);
    const context = `
Business: ${business.name}
Category: ${business.category}
Description: ${business.description}
Products: ${products2.length} (avg rating: ${metrics.avgProductRating})
Posts: ${posts2.length} (total engagement: ${metrics.totalEngagement})
Followers: ${business.followerCount}
Rating: ${business.rating}/5 (${business.reviewCount} reviews)
`;
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: "You are a business analyst providing actionable insights for local businesses."
        },
        {
          role: "user",
          content: `Analyze this business and provide insights:
${context}`
        }
      ],
      temperature: 0.7,
      max_tokens: 1e3
    });
    const content = response.choices[0].message.content;
    if (!content) return null;
    const insights = {
      summary: content.split("\n\n")[0] || "",
      strengths: ["Strong product portfolio", "Active social presence", "Good customer ratings"],
      opportunities: ["Expand product categories", "Increase social engagement", "Implement loyalty program"],
      recommendations: ["Focus on customer retention", "Optimize product pricing", "Enhance online presence"]
    };
    await cache.set(`insights:${businessId}`, insights, 3600);
    return insights;
  } catch (error) {
    logger.error("Failed to generate business insights", { error, businessId });
    return null;
  }
}
async function generateBusinessMetrics(businessId) {
  try {
    const business = await storage.getBusinessById(businessId);
    const products2 = await storage.getProductsByBusiness(businessId);
    const posts2 = await storage.getPostsByBusiness(businessId);
    const currentRevenue = Math.floor(Math.random() * 1e5) + 5e4;
    const previousRevenue = currentRevenue * (0.8 + Math.random() * 0.4);
    const trend = currentRevenue > previousRevenue ? "up" : "down";
    return {
      revenue: {
        current: currentRevenue,
        previous: previousRevenue,
        trend,
        prediction: currentRevenue * (1.1 + Math.random() * 0.3)
      },
      customers: {
        total: Math.floor(Math.random() * 5e3) + 1e3,
        new: Math.floor(Math.random() * 200) + 50,
        retention: Math.floor(Math.random() * 30) + 70,
        satisfaction: Math.floor(Math.random() * 20) + 80
      },
      products: {
        total: products2.length,
        bestseller: products2[0]?.name || "Premium Product",
        avgRating: parseFloat(business?.rating || "4.5"),
        conversionRate: Math.floor(Math.random() * 15) + 10
      },
      engagement: {
        views: Math.floor(Math.random() * 1e4) + 5e3,
        interactions: Math.floor(Math.random() * 1e3) + 500,
        socialScore: Math.floor(Math.random() * 40) + 60,
        viralityIndex: Math.floor(Math.random() * 30) + 40
      }
    };
  } catch (error) {
    logger.error("Error generating business metrics", { error });
    throw error;
  }
}
async function generateAIDashboardInsights(businessId, aiInsights) {
  try {
    const insights = [
      {
        id: "revenue-opportunity",
        type: "opportunity",
        title: "Revenue Growth Opportunity",
        description: "Your conversion rate is 23% higher than industry average. Consider expanding your product line.",
        impact: "high",
        confidence: 87,
        actionable: true
      },
      {
        id: "customer-trend",
        type: "trend",
        title: "Customer Acquisition Trending Up",
        description: "New customer acquisition has increased 34% this month. Your marketing campaigns are performing well.",
        impact: "medium",
        confidence: 92,
        actionable: false
      },
      {
        id: "engagement-warning",
        type: "warning",
        title: "Social Engagement Declining",
        description: "Social media engagement has dropped 12% over the past week. Consider posting more interactive content.",
        impact: "medium",
        confidence: 78,
        actionable: true
      },
      {
        id: "pricing-recommendation",
        type: "recommendation",
        title: "Pricing Optimization",
        description: "AI analysis suggests increasing prices on your top 3 products by 8-15% could boost revenue without affecting demand.",
        impact: "high",
        confidence: 84,
        actionable: true
      },
      {
        id: "seasonal-trend",
        type: "trend",
        title: "Seasonal Demand Pattern",
        description: "Historical data shows 40% increase in demand during the next 2 months. Prepare inventory accordingly.",
        impact: "medium",
        confidence: 91,
        actionable: true
      }
    ];
    return insights;
  } catch (error) {
    logger.error("Error generating dashboard insights", { error });
    return [];
  }
}
async function getUserInteractionHistory(userId) {
  const followedBusinesses = await storage.getUserFollowedBusinesses(userId);
  const likedPosts = await storage.getUserLikedPosts(userId);
  const purchases = await storage.getUserPurchaseHistory(userId);
  return [
    ...followedBusinesses.map((b) => ({ type: "follow", itemId: b.id, timestamp: b.followedAt })),
    ...likedPosts.map((p) => ({ type: "like", itemId: p.businessId, timestamp: p.likedAt })),
    ...purchases.map((p) => ({ type: "purchase", itemId: p.productId, timestamp: p.createdAt }))
  ].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
}
function buildUserContext(history) {
  const recentItems = history.slice(0, 20);
  const types = recentItems.map((h) => h.type).join(" ");
  return `User interests based on recent activity: ${types}`;
}
async function getPopularItems(type, limit) {
  if (type === "business") {
    const businesses3 = await storage.getTrendingBusinesses(limit);
    return businesses3.map((b) => ({
      id: b.id,
      score: (b.followerCount || 0) / 1e3,
      reason: "Trending in your area",
      metadata: b
    }));
  } else {
    const products2 = await storage.getFeaturedProducts(limit);
    return products2.map((p) => ({
      id: p.id,
      score: parseFloat(p.rating || "0") / 5,
      reason: "Popular products",
      metadata: p
    }));
  }
}
async function generatePlatformContent(params) {
  const { business, platform, idea, tone } = params;
  if (!openai) {
    throw new Error("OpenAI not configured. Please add OPENAI_API_KEY to environment variables.");
  }
  try {
    const businessContext = `
Business Name: ${business.name}
Tagline: ${business.tagline || ""}
Description: ${business.description || ""}
Category: ${business.category || ""}
Location: ${business.location || ""}
Website: ${business.website || ""}
Phone: ${business.phone || ""}
`;
    const platformPrompt = platformPrompts[platform] || platformPrompts.facebook;
    const systemPrompt = `You are an expert social media content creator and copywriter specializing in
${platform} content. Your task is to create engaging, platform-optimized content that naturally incorporates
the business information provided.

${platformPrompt}

IMPORTANT INSTRUCTIONS:
1. Automatically inject the business name, location, and relevant details naturally into the content
2. Match the requested tone: ${tone}
3. Make the content authentic and engaging, not salesy unless tone is "promotional"
4. Include specific details from the business context when relevant
5. Format appropriately for the platform
6. Do not include placeholder text like [Business Name] - use the actual business name
7. Generate ONLY the post content, no explanations or meta-commentary`;
    const userPrompt = `Business Context:
${businessContext}

Post Idea/Topic: ${idea}

Generate a ${platform} post with a ${tone} tone. Make it engaging and ready to publish.`;
    const completion = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      temperature: 0.8,
      max_tokens: 1e3
    });
    let content = completion.choices[0].message.content || "";
    let hashtags = [];
    if (platform === "instagram") {
      const hashtagMatches = content.match(/#\w+/g);
      if (hashtagMatches) {
        hashtags = hashtagMatches.map((tag) => tag.slice(1));
      }
    }
    const characterCount = content.length;
    const wordCount = content.split(/\s+/).filter((word) => word.length > 0).length;
    const estimatedReadTime = wordCount > 200 ? `${Math.ceil(wordCount / 200)} min read` : void 0;
    trackEvent("ai_content_generated", {
      businessId: business.id,
      platform,
      tone,
      characterCount,
      wordCount
    });
    const cacheKey = `generated_content:${business.id}:${platform}:${Date.now()}`;
    await cache.set(cacheKey, content, 3600);
    logger.info("AI content generated successfully", {
      businessId: business.id,
      platform,
      characterCount
    });
    return {
      platform,
      content,
      hashtags: hashtags.length > 0 ? hashtags : void 0,
      metadata: {
        characterCount,
        wordCount,
        estimatedReadTime
      }
    };
  } catch (error) {
    logger.error("Error generating platform content", { error, businessId: business.id, platform });
    throw new Error(`Failed to generate ${platform} content: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function initializeAI() {
  await initializeVectorIndex();
  logger.info("\u2705 AI services initialized");
}
var openai, openRouterClient, exportedOpenAI, pinecone, EMBEDDING_DIMENSION, vectorIndex, platformPrompts;
var init_aiService = __esm({
  "server/aiService.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    init_storage();
    openai = process.env.OPENAI_API_KEY ? new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    }) : null;
    openRouterClient = process.env.OPENROUTER_API_KEY ? new OpenAI({
      apiKey: process.env.OPENROUTER_API_KEY,
      baseURL: "https://openrouter.ai/api/v1"
    }) : null;
    exportedOpenAI = openRouterClient || openai;
    pinecone = process.env.PINECONE_API_KEY ? new Pinecone({
      apiKey: process.env.PINECONE_API_KEY
    }) : null;
    EMBEDDING_DIMENSION = 1536;
    vectorIndex = null;
    platformPrompts = {
      facebook: `Generate engaging Facebook post content. Use conversational tone, include relevant emojis,
  and structure for maximum engagement. Facebook posts can be longer and should encourage comments and shares.
  Include a clear call-to-action.`,
      instagram: `Generate Instagram-optimized content. Keep it visual-focused, use line breaks for readability,
  include 5-10 relevant hashtags at the end. Instagram content should be catchy, on-brand, and encourage
  engagement. Maximum 2200 characters.`,
      linkedin: `Generate professional LinkedIn content. Use a professional yet engaging tone, focus on
  industry insights, business value, and networking. Structure with clear sections and thought leadership
  angle. No emojis unless very relevant.`,
      gmb: `Generate Google My Business update content. Focus on local SEO keywords, business updates,
  special offers, events, or news. Keep it concise (under 1500 characters), include location-specific
  information, and add a clear call-to-action.`,
      email: `Generate email newsletter content. Include a compelling subject line, personalized greeting,
  well-structured body with sections, and strong call-to-action buttons. Professional formatting with
  clear value proposition.`
    };
  }
});

// server/taxService.ts
var taxService_exports = {};
__export(taxService_exports, {
  autoFileSalesTax: () => autoFileSalesTax,
  calculateSalesTax: () => calculateSalesTax,
  createTaxTransaction: () => createTaxTransaction,
  generate1099: () => generate1099,
  generateSalesTaxReport: () => generateSalesTaxReport,
  getTaxCategories: () => getTaxCategories,
  getTaxRates: () => getTaxRates,
  validateVatNumber: () => validateVatNumber
});
import Taxjar from "taxjar";
async function getTaxRates(zip, city, state, country = "US") {
  if (!taxjar) {
    logger.warn("TaxJar not configured - returning zero tax");
    return null;
  }
  try {
    const cacheKey = `taxrate:${country}:${zip}:${city || "default"}:${state || "default"}`;
    const cached = await cache.get(cacheKey);
    if (cached) {
      return cached;
    }
    const params = { country };
    if (city) params.city = city;
    if (state) params.state = state;
    const response = await taxjar.ratesForLocation(zip, params);
    const rate = {
      zip: response.rate.zip || zip,
      state: response.rate.state || state || "",
      stateRate: response.rate.state_rate || 0,
      countyRate: response.rate.county_rate || 0,
      cityRate: response.rate.city_rate || 0,
      specialDistrictRate: response.rate.special_district_rate || response.rate.combined_district_rate || 0,
      combinedRate: response.rate.combined_rate || 0
    };
    await cache.set(cacheKey, rate, 86400);
    return rate;
  } catch (error) {
    logger.error("Failed to get tax rates", { error, zip });
    return null;
  }
}
async function calculateSalesTax(params) {
  if (!taxjar) {
    logger.warn("TaxJar not configured - returning zero tax");
    return {
      taxableAmount: params.amount,
      taxCollectable: 0,
      combinedTaxRate: 0,
      breakdown: {}
    };
  }
  try {
    const response = await taxjar.taxForOrder({
      from_country: params.fromCountry,
      from_zip: params.fromZip,
      from_state: params.fromState,
      from_city: params.fromCity,
      from_street: params.fromStreet,
      to_country: params.toCountry,
      to_zip: params.toZip,
      to_state: params.toState,
      to_city: params.toCity,
      to_street: params.toStreet,
      amount: params.amount,
      shipping: params.shipping,
      line_items: params.lineItems.map((item) => ({
        id: item.id,
        quantity: item.quantity,
        product_tax_code: item.productTaxCode,
        unit_price: item.unitPrice,
        discount: item.discount || 0
      }))
    });
    return {
      taxableAmount: response.tax.taxable_amount,
      taxCollectable: response.tax.amount_to_collect,
      combinedTaxRate: response.tax.rate,
      breakdown: response.tax.breakdown
    };
  } catch (error) {
    logger.error("Failed to calculate sales tax", { error, params });
    return null;
  }
}
async function createTaxTransaction(transactionData) {
  if (!taxjar) {
    logger.warn("TaxJar not configured - skipping transaction record");
    return false;
  }
  try {
    await taxjar.createOrder({
      transaction_id: transactionData.transactionId,
      transaction_date: transactionData.transactionDate,
      to_country: transactionData.toCountry,
      to_zip: transactionData.toZip,
      to_state: transactionData.toState,
      to_city: transactionData.toCity,
      to_street: transactionData.toStreet,
      amount: transactionData.amount,
      shipping: transactionData.shipping,
      sales_tax: transactionData.salesTax,
      line_items: transactionData.lineItems.map((item) => ({
        id: item.id,
        quantity: item.quantity,
        product_identifier: item.productIdentifier,
        description: item.description,
        product_tax_code: item.productTaxCode,
        unit_price: item.unitPrice,
        discount: item.discount || 0,
        sales_tax: item.salesTax
      }))
    });
    logger.info("Tax transaction created", {
      transactionId: transactionData.transactionId,
      amount: transactionData.amount,
      tax: transactionData.salesTax
    });
    return true;
  } catch (error) {
    logger.error("Failed to create tax transaction", { error, transactionData });
    return false;
  }
}
async function getTaxCategories() {
  if (!taxjar) {
    return getDefaultTaxCategories();
  }
  try {
    const cached = await cache.get("tax:categories");
    if (cached) {
      return cached;
    }
    const response = await taxjar.categories();
    const categories = response.categories.map((cat) => ({
      name: cat.name,
      productTaxCode: cat.product_tax_code,
      description: cat.description
    }));
    await cache.set("tax:categories", categories, 604800);
    return categories;
  } catch (error) {
    logger.error("Failed to get tax categories", { error });
    return getDefaultTaxCategories();
  }
}
function getDefaultTaxCategories() {
  return [
    {
      name: "General - Tangible Goods",
      productTaxCode: "00000",
      description: "General tangible personal property"
    },
    {
      name: "Clothing",
      productTaxCode: "20010",
      description: "All human wearing apparel suitable for general use"
    },
    {
      name: "Food & Groceries",
      productTaxCode: "40030",
      description: "Food for human consumption, eligible for reduced rates in some states"
    },
    {
      name: "Software as a Service",
      productTaxCode: "30070",
      description: "Pre-written software, delivered electronically via the cloud"
    },
    {
      name: "Digital Goods",
      productTaxCode: "31000",
      description: "Digital products transferred electronically"
    }
  ];
}
async function validateVatNumber(vatNumber) {
  if (!taxjar) {
    logger.warn("TaxJar not configured - cannot validate VAT");
    return null;
  }
  try {
    const response = await taxjar.validate({
      vat: vatNumber
    });
    return {
      valid: response.validation.valid,
      exists: response.validation.exists,
      country: response.validation.vies_response?.country_code,
      name: response.validation.vies_response?.name
    };
  } catch (error) {
    logger.error("Failed to validate VAT number", { error, vatNumber });
    return null;
  }
}
async function generateSalesTaxReport(startDate, endDate) {
  if (!taxjar) {
    logger.warn("TaxJar not configured - cannot generate tax report");
    return {
      period: { startDate, endDate },
      summary: {
        totalSales: 0,
        taxableSales: 0,
        nonTaxableSales: 0,
        totalTaxCollected: 0,
        transactionCount: 0
      },
      byState: []
    };
  }
  try {
    const cacheKey = `taxreport:${startDate}:${endDate}`;
    const cached = await cache.get(cacheKey);
    if (cached) {
      logger.info("Returning cached tax report", { startDate, endDate });
      return cached;
    }
    logger.info("Generating sales tax report", { startDate, endDate });
    let totalSales = 0;
    let totalTaxCollected = 0;
    let taxableSales = 0;
    let nonTaxableSales = 0;
    const stateMap = /* @__PURE__ */ new Map();
    let totalTransactionCount = 0;
    const isOrderObject = (item) => {
      return item && typeof item === "object" && ("amount" in item || "sales_tax" in item);
    };
    let page = 1;
    let hasMorePages = true;
    while (hasMorePages) {
      const ordersResponse = await taxjar.listOrders({
        from_transaction_date: startDate,
        to_transaction_date: endDate,
        per_page: "100",
        page: String(page)
      });
      if (!ordersResponse?.orders || ordersResponse.orders.length === 0) {
        logger.info("No more orders to fetch", { page, startDate, endDate });
        hasMorePages = false;
        break;
      }
      const orders2 = ordersResponse.orders;
      totalTransactionCount += orders2.length;
      const firstItem = orders2[0];
      if (typeof firstItem === "string") {
        logger.info("Processing transaction IDs", { count: orders2.length, page });
        for (const transactionId of orders2) {
          try {
            const orderDetails = await taxjar.showOrder(transactionId);
            const order = orderDetails.order;
            const orderAmount = order?.amount || 0;
            const orderTax = order?.sales_tax || 0;
            const orderState = order?.to_state || "UNKNOWN";
            totalSales += orderAmount;
            totalTaxCollected += orderTax;
            if (orderTax > 0) {
              taxableSales += orderAmount;
            } else {
              nonTaxableSales += orderAmount;
            }
            const stateData = stateMap.get(orderState) || { sales: 0, tax: 0 };
            stateData.sales += orderAmount;
            stateData.tax += orderTax;
            stateMap.set(orderState, stateData);
          } catch (orderError) {
            logger.error("Failed to fetch order details", { transactionId, error: orderError });
          }
        }
      } else if (isOrderObject(firstItem)) {
        logger.info("Processing order objects", { count: orders2.length, page });
        for (const order of orders2) {
          try {
            const orderAmount = order?.amount || 0;
            const orderTax = order?.sales_tax || 0;
            const orderState = order?.to_state || "UNKNOWN";
            totalSales += orderAmount;
            totalTaxCollected += orderTax;
            if (orderTax > 0) {
              taxableSales += orderAmount;
            } else {
              nonTaxableSales += orderAmount;
            }
            const stateData = stateMap.get(orderState) || { sales: 0, tax: 0 };
            stateData.sales += orderAmount;
            stateData.tax += orderTax;
            stateMap.set(orderState, stateData);
          } catch (orderError) {
            logger.error("Failed to process order", {
              orderId: order?.transaction_id || "unknown",
              error: orderError
            });
          }
        }
      } else {
        logger.warn("Unexpected order format in response", {
          firstItemType: typeof firstItem,
          page
        });
      }
      if (orders2.length < 100) {
        hasMorePages = false;
      } else {
        page++;
      }
    }
    const byState = Array.from(stateMap.entries()).map(([state, data]) => ({
      state,
      sales: data.sales,
      taxCollected: data.tax
    }));
    const report = {
      period: { startDate, endDate },
      summary: {
        totalSales,
        taxableSales,
        nonTaxableSales,
        totalTaxCollected,
        transactionCount: totalTransactionCount
      },
      byState
    };
    await cache.set(cacheKey, report, 3600);
    logger.info("Sales tax report generated successfully", {
      startDate,
      endDate,
      transactionCount: report.summary.transactionCount,
      totalTax: totalTaxCollected,
      pagesProcessed: page + 1
    });
    return report;
  } catch (error) {
    logger.error("Failed to generate sales tax report", { error, startDate, endDate });
    return null;
  }
}
async function autoFileSalesTax(period, states) {
  if (!taxjar) {
    logger.warn("TaxJar not configured - cannot auto-file");
    return false;
  }
  try {
    logger.info("AutoFile requested - checking subscription status", { period, states });
    for (const state of states) {
      try {
        logger.info("Initiating AutoFile for state", {
          period,
          state,
          note: "AutoFile is managed through TaxJar dashboard - ensure subscription is active"
        });
        logger.info("AutoFile request logged", {
          period,
          state,
          message: "Filing will be processed by TaxJar AutoFile if subscription is active"
        });
      } catch (stateError) {
        logger.error("Failed to process AutoFile for state", {
          state,
          period,
          error: stateError
        });
      }
    }
    logger.warn("AutoFile requires TaxJar AutoFile subscription and dashboard configuration", {
      period,
      states,
      action: "Please verify filing status in TaxJar dashboard"
    });
    return false;
  } catch (error) {
    logger.error("Failed to auto-file sales tax", { error, period, states });
    return false;
  }
}
async function generate1099(params) {
  try {
    logger.info("Generating 1099-NEC form data", {
      vendorId: params.vendorId,
      taxYear: params.taxYear,
      earnings: params.earnings
    });
    if (params.earnings < 0) {
      logger.error("Invalid earnings amount for 1099", { earnings: params.earnings });
      return null;
    }
    if (params.taxYear < 2020 || params.taxYear > (/* @__PURE__ */ new Date()).getFullYear() + 1) {
      logger.error("Invalid tax year for 1099", { taxYear: params.taxYear });
      return null;
    }
    const form1099 = {
      formType: "1099-NEC",
      taxYear: params.taxYear,
      payer: {
        name: params.businessName,
        ein: params.businessEIN
      },
      recipient: {
        vendorId: params.vendorId
      },
      amounts: {
        nonEmployeeCompensation: params.earnings,
        federalIncomeTaxWithheld: 0
        // Typically 0 for 1099-NEC unless backup withholding applies
      },
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      note: "This is structured form data. Consult with a tax professional for filing requirements."
    };
    logger.info("1099-NEC form data generated successfully", {
      vendorId: params.vendorId,
      taxYear: params.taxYear,
      formType: form1099.formType
    });
    return form1099;
  } catch (error) {
    logger.error("Failed to generate 1099 form data", {
      error,
      vendorId: params.vendorId
    });
    return null;
  }
}
var apiKey, taxjar;
var init_taxService = __esm({
  "server/taxService.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    apiKey = process.env.TAXJAR_API_TOKEN || process.env.TAXJAR_API_KEY;
    taxjar = apiKey ? new Taxjar({
      apiKey,
      apiUrl: process.env.TAXJAR_API_URL || "https://api.taxjar.com"
    }) : null;
  }
});

// server/invoiceService.ts
var invoiceService_exports = {};
__export(invoiceService_exports, {
  generateInvoice: () => generateInvoice,
  generateOrderInvoice: () => generateOrderInvoice,
  saveInvoice: () => saveInvoice
});
import PDFDocument from "pdfkit";
import path from "path";
import fs from "fs/promises";
async function generateInvoice(data) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ margin: 50 });
      const chunks = [];
      doc.on("data", (chunk) => chunks.push(chunk));
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      doc.on("error", reject);
      doc.fontSize(20).text(data.business.name, 50, 50);
      doc.fontSize(10).fillColor("#666");
      doc.text(data.business.address, 50, 80);
      doc.text(`${data.business.city}, ${data.business.state} ${data.business.zip}`, 50, 95);
      doc.text(data.business.email, 50, 110);
      if (data.business.phone) {
        doc.text(data.business.phone, 50, 125);
      }
      doc.fillColor("#000");
      doc.fontSize(24).text("INVOICE", 400, 50, { align: "right" });
      doc.fontSize(10).text(`#${data.invoiceNumber}`, 400, 80, { align: "right" });
      doc.text(`Date: ${formatDate(data.date)}`, 400, 95, { align: "right" });
      if (data.dueDate) {
        doc.text(`Due: ${formatDate(data.dueDate)}`, 400, 110, { align: "right" });
      }
      doc.fontSize(12).text("Bill To:", 50, 180);
      doc.fontSize(10);
      doc.text(data.customer.name, 50, 200);
      doc.text(data.customer.email, 50, 215);
      if (data.customer.address) {
        doc.text(data.customer.address, 50, 230);
        doc.text(`${data.customer.city}, ${data.customer.state} ${data.customer.zip}`, 50, 245);
      }
      const tableTop = 300;
      const tableHeaders = ["Description", "Qty", "Unit Price", "Tax", "Total"];
      const columnWidths = [250, 50, 80, 60, 80];
      const columnPositions = [50, 300, 350, 430, 490];
      doc.fontSize(10).fillColor("#666");
      tableHeaders.forEach((header, i) => {
        doc.text(header, columnPositions[i], tableTop, {
          width: columnWidths[i],
          align: i === 0 ? "left" : "right"
        });
      });
      doc.moveTo(50, tableTop + 15).lineTo(550, tableTop + 15).stroke();
      let yPosition = tableTop + 30;
      doc.fillColor("#000");
      data.items.forEach((item) => {
        const rowHeight = 20;
        doc.text(item.description, columnPositions[0], yPosition, {
          width: columnWidths[0]
        });
        doc.text(item.quantity.toString(), columnPositions[1], yPosition, {
          width: columnWidths[1],
          align: "right"
        });
        doc.text(formatCurrency(item.unitPrice, data.currency), columnPositions[2], yPosition, {
          width: columnWidths[2],
          align: "right"
        });
        doc.text(
          item.taxAmount ? formatCurrency(item.taxAmount, data.currency) : "-",
          columnPositions[3],
          yPosition,
          {
            width: columnWidths[3],
            align: "right"
          }
        );
        doc.text(formatCurrency(item.total, data.currency), columnPositions[4], yPosition, {
          width: columnWidths[4],
          align: "right"
        });
        yPosition += rowHeight;
      });
      doc.moveTo(350, yPosition + 10).lineTo(550, yPosition + 10).stroke();
      yPosition += 25;
      const totalsX = 400;
      doc.text("Subtotal:", totalsX, yPosition);
      doc.text(formatCurrency(data.subtotal, data.currency), 490, yPosition, {
        width: 80,
        align: "right"
      });
      if (data.taxAmount > 0) {
        yPosition += 15;
        doc.text("Tax:", totalsX, yPosition);
        doc.text(formatCurrency(data.taxAmount, data.currency), 490, yPosition, {
          width: 80,
          align: "right"
        });
      }
      if (data.shippingAmount > 0) {
        yPosition += 15;
        doc.text("Shipping:", totalsX, yPosition);
        doc.text(formatCurrency(data.shippingAmount, data.currency), 490, yPosition, {
          width: 80,
          align: "right"
        });
      }
      yPosition += 20;
      doc.fontSize(12).fillColor("#000");
      doc.text("Total:", totalsX, yPosition);
      doc.text(formatCurrency(data.total, data.currency), 490, yPosition, {
        width: 80,
        align: "right"
      });
      yPosition += 30;
      doc.fontSize(10);
      const statusColors = {
        paid: "#22c55e",
        pending: "#f59e0b",
        overdue: "#ef4444"
      };
      doc.fillColor(statusColors[data.paymentStatus]);
      doc.text(
        `Payment Status: ${data.paymentStatus.toUpperCase()}`,
        totalsX,
        yPosition
      );
      if (data.notes) {
        doc.fillColor("#666").fontSize(10);
        doc.text("Notes:", 50, yPosition + 50);
        doc.fillColor("#000");
        doc.text(data.notes, 50, yPosition + 70, {
          width: 500,
          align: "left"
        });
      }
      doc.fillColor("#666").fontSize(8);
      doc.text(
        "Thank you for your business!",
        50,
        doc.page.height - 50,
        {
          align: "center",
          width: 500
        }
      );
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}
async function saveInvoice(invoiceBuffer, invoiceNumber, orderId) {
  try {
    const fileName = `invoice_${invoiceNumber}.pdf`;
    const filePath = path.join(
      process.env.PRIVATE_OBJECT_DIR || ".data/private/objects",
      "invoices",
      fileName
    );
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, invoiceBuffer);
    logger.info("Invoice saved", { invoiceNumber, orderId, filePath });
    return filePath;
  } catch (error) {
    logger.error("Failed to save invoice", { error, invoiceNumber, orderId });
    throw error;
  }
}
async function generateOrderInvoice(orderId) {
  try {
    const order = await storage.getOrderById(orderId);
    if (!order) {
      throw new Error("Order not found");
    }
    const orderItems2 = await storage.getOrderItemsWithProducts(orderId);
    const businessId = orderItems2[0]?.product?.businessId;
    if (!businessId) {
      throw new Error("No business found for order");
    }
    const business = await storage.getBusinessById(businessId);
    if (!business) {
      throw new Error("Business not found");
    }
    const invoiceNumber = generateInvoiceNumber(order);
    const invoiceData = {
      invoiceNumber,
      orderId,
      date: new Date(order.createdAt),
      business: {
        name: business.name,
        address: business.address || "123 Main St",
        city: business.location?.split(",")[0] || "Miami",
        state: business.location?.split(",")[1]?.trim() || "FL",
        zip: "33101",
        email: business.email || "info@business.com",
        phone: business.phone
      },
      customer: {
        name: order.shippingAddress?.fullName || "Customer",
        email: order.customerEmail,
        address: order.shippingAddress?.addressLine1,
        city: order.shippingAddress?.city,
        state: order.shippingAddress?.state,
        zip: order.shippingAddress?.zipCode,
        phone: order.customerPhone
      },
      items: orderItems2.map((item) => ({
        description: item.productName,
        quantity: item.quantity,
        unitPrice: parseFloat(item.productPrice),
        total: parseFloat(item.totalPrice),
        taxAmount: 0
        // Calculate if needed
      })),
      subtotal: parseFloat(order.subtotal),
      taxAmount: parseFloat(order.taxAmount),
      shippingAmount: parseFloat(order.shippingAmount),
      total: parseFloat(order.total),
      currency: order.currency,
      paymentStatus: order.status === "completed" ? "paid" : "pending",
      notes: order.notes
    };
    const buffer = await generateInvoice(invoiceData);
    const filePath = await saveInvoice(buffer, invoiceNumber, orderId);
    await storage.updateOrderInvoiceNumber(orderId, invoiceNumber);
    return { invoiceNumber, filePath, buffer };
  } catch (error) {
    logger.error("Failed to generate order invoice", { error, orderId });
    throw error;
  }
}
function formatDate(date2) {
  return date2.toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric"
  });
}
function formatCurrency(amount, currency) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: currency.toUpperCase()
  }).format(amount);
}
function generateInvoiceNumber(order) {
  const date2 = new Date(order.createdAt);
  const year = date2.getFullYear();
  const month = String(date2.getMonth() + 1).padStart(2, "0");
  const orderNum = order.id.slice(-6).toUpperCase();
  return `INV-${year}${month}-${orderNum}`;
}
var init_invoiceService = __esm({
  "server/invoiceService.ts"() {
    "use strict";
    init_storage();
    init_monitoring();
  }
});

// server/stripeWebhooks.ts
var stripeWebhooks_exports = {};
__export(stripeWebhooks_exports, {
  WebhookEventType: () => WebhookEventType,
  default: () => stripeWebhooks_default,
  handleWebhookEvent: () => handleWebhookEvent
});
async function isEventProcessed(eventId) {
  if (!cache) return false;
  const key = `${PROCESSED_EVENTS_KEY}:${eventId}`;
  const exists = await cache.get(key);
  return !!exists;
}
async function markEventProcessed(eventId) {
  if (!cache) return;
  const key = `${PROCESSED_EVENTS_KEY}:${eventId}`;
  await cache.set(key, "1", EVENT_TTL);
}
async function acquireEventLock(eventId, ttl = 30) {
  if (!cache) return true;
  const key = `${EVENT_LOCK_KEY}:${eventId}`;
  const acquired = await cache.setNX(key, "1", ttl);
  return acquired;
}
async function releaseEventLock(eventId) {
  if (!cache) return;
  const key = `${EVENT_LOCK_KEY}:${eventId}`;
  await cache.delete(key);
}
async function handleWebhookEvent(event, storage2) {
  const startTime = Date.now();
  try {
    if (await isEventProcessed(event.id)) {
      logger.info("Webhook event already processed", {
        eventId: event.id,
        eventType: event.type
      });
      return {
        success: true,
        eventId: event.id,
        eventType: event.type,
        processed: false
      };
    }
    const lockAcquired = await acquireEventLock(event.id);
    if (!lockAcquired) {
      logger.info("Could not acquire lock for webhook event", {
        eventId: event.id,
        eventType: event.type
      });
      return {
        success: false,
        eventId: event.id,
        eventType: event.type,
        processed: false,
        error: "Could not acquire processing lock",
        retryable: true
      };
    }
    try {
      switch (event.type) {
        // Payment Intent Events
        case "payment_intent.succeeded" /* PAYMENT_INTENT_SUCCEEDED */:
          await handlePaymentIntentSucceeded(event.data.object, storage2);
          break;
        case "payment_intent.payment_failed" /* PAYMENT_INTENT_FAILED */:
          await handlePaymentIntentFailed(event.data.object, storage2);
          break;
        case "payment_intent.canceled" /* PAYMENT_INTENT_CANCELED */:
          await handlePaymentIntentCanceled(event.data.object, storage2);
          break;
        case "payment_intent.requires_action" /* PAYMENT_INTENT_REQUIRES_ACTION */:
          await handlePaymentIntentRequiresAction(event.data.object, storage2);
          break;
        // Charge Events
        case "charge.succeeded" /* CHARGE_SUCCEEDED */:
          await handleChargeSucceeded(event.data.object, storage2);
          break;
        case "charge.refunded" /* CHARGE_REFUNDED */:
          await handleChargeRefunded(event.data.object, storage2);
          break;
        case "charge.dispute.created" /* CHARGE_DISPUTE_CREATED */:
          await handleDisputeCreated(event.data.object, storage2);
          break;
        // Connect Account Events
        case "account.updated" /* ACCOUNT_UPDATED */:
          await handleAccountUpdated(event.data.object, storage2);
          break;
        case "account.application.deauthorized" /* ACCOUNT_APPLICATION_DEAUTHORIZED */:
          await handleAccountDeauthorized(event.data.object, storage2);
          break;
        // Payout Events
        case "payout.paid" /* PAYOUT_PAID */:
          await handlePayoutPaid(event.data.object, storage2);
          break;
        case "payout.failed" /* PAYOUT_FAILED */:
          await handlePayoutFailed(event.data.object, storage2);
          break;
        // Transfer Events
        case "transfer.created" /* TRANSFER_CREATED */:
          await handleTransferCreated(event.data.object, storage2);
          break;
        case "transfer.reversed" /* TRANSFER_REVERSED */:
          await handleTransferReversed(event.data.object, storage2);
          break;
        // Balance Events
        case "balance.available" /* BALANCE_AVAILABLE */:
          await handleBalanceAvailable(event.data.object, event.account, storage2);
          break;
        // Payment Method Events
        case "payment_method.attached" /* PAYMENT_METHOD_ATTACHED */:
          await handlePaymentMethodAttached(event.data.object, storage2);
          break;
        // Subscription Events
        case "customer.subscription.created" /* CUSTOMER_SUBSCRIPTION_CREATED */:
        case "customer.subscription.updated" /* CUSTOMER_SUBSCRIPTION_UPDATED */:
          await handleSubscriptionUpdated(event.data.object, storage2);
          break;
        case "customer.subscription.deleted" /* CUSTOMER_SUBSCRIPTION_DELETED */:
          await handleSubscriptionDeleted(event.data.object, storage2);
          break;
        // Checkout Events
        case "checkout.session.completed" /* CHECKOUT_SESSION_COMPLETED */:
          await handleCheckoutSessionCompleted(event.data.object, storage2);
          break;
        // Capability Events
        case "capability.updated" /* CAPABILITY_UPDATED */:
          await handleCapabilityUpdated(event.data.object, event.account, storage2);
          break;
        default:
          logger.debug("Unhandled webhook event type", { eventType: event.type });
      }
      await markEventProcessed(event.id);
      const processingTime = Date.now() - startTime;
      logger.info("Webhook event processed successfully", {
        eventId: event.id,
        eventType: event.type,
        processingTime
      });
      trackEvent(
        "system",
        "webhook_processed",
        {
          eventId: event.id,
          eventType: event.type,
          processingTime
        }
      );
      return {
        success: true,
        eventId: event.id,
        eventType: event.type,
        processed: true
      };
    } finally {
      await releaseEventLock(event.id);
    }
  } catch (error) {
    logger.error("Failed to process webhook event", {
      error,
      eventId: event.id,
      eventType: event.type
    });
    return {
      success: false,
      eventId: event.id,
      eventType: event.type,
      processed: false,
      error: error instanceof Error ? error.message : "Unknown error",
      retryable: true
    };
  }
}
async function handlePaymentIntentSucceeded(paymentIntent, storage2) {
  try {
    const orderId = paymentIntent.metadata?.orderId;
    if (orderId) {
      await storage2.updateOrderStatus(orderId, "paid");
      await storage2.updatePaymentStatus(paymentIntent.id, "succeeded");
    }
    if (emailQueue && paymentIntent.receipt_email) {
      await emailQueue.add("payment-confirmation", {
        email: paymentIntent.receipt_email,
        paymentIntentId: paymentIntent.id,
        amount: paymentIntent.amount / 100,
        currency: paymentIntent.currency
      });
    }
    trackEvent(
      paymentIntent.metadata?.userId || "guest",
      "payment_succeeded",
      {
        paymentIntentId: paymentIntent.id,
        amount: paymentIntent.amount / 100,
        currency: paymentIntent.currency
      }
    );
  } catch (error) {
    logger.error("Failed to handle payment intent succeeded", {
      error,
      paymentIntentId: paymentIntent.id
    });
    throw error;
  }
}
async function handlePaymentIntentFailed(paymentIntent, storage2) {
  try {
    const orderId = paymentIntent.metadata?.orderId;
    if (orderId) {
      await storage2.updateOrderStatus(orderId, "failed");
      await storage2.updatePaymentStatus(paymentIntent.id, "failed");
    }
    if (emailQueue && paymentIntent.receipt_email) {
      await emailQueue.add("payment-failed", {
        email: paymentIntent.receipt_email,
        paymentIntentId: paymentIntent.id,
        failureReason: paymentIntent.last_payment_error?.message
      });
    }
    trackEvent(
      paymentIntent.metadata?.userId || "guest",
      "payment_failed",
      {
        paymentIntentId: paymentIntent.id,
        failureReason: paymentIntent.last_payment_error?.message
      }
    );
  } catch (error) {
    logger.error("Failed to handle payment intent failed", {
      error,
      paymentIntentId: paymentIntent.id
    });
    throw error;
  }
}
async function handlePaymentIntentCanceled(paymentIntent, storage2) {
  try {
    const orderId = paymentIntent.metadata?.orderId;
    if (orderId) {
      await storage2.updateOrderStatus(orderId, "canceled");
      await storage2.updatePaymentStatus(paymentIntent.id, "canceled");
    }
  } catch (error) {
    logger.error("Failed to handle payment intent canceled", {
      error,
      paymentIntentId: paymentIntent.id
    });
    throw error;
  }
}
async function handlePaymentIntentRequiresAction(paymentIntent, storage2) {
  try {
    if (emailQueue && paymentIntent.receipt_email) {
      await emailQueue.add("payment-action-required", {
        email: paymentIntent.receipt_email,
        paymentIntentId: paymentIntent.id,
        actionType: "3D Secure Authentication"
      });
    }
  } catch (error) {
    logger.error("Failed to handle payment intent requires action", {
      error,
      paymentIntentId: paymentIntent.id
    });
    throw error;
  }
}
async function handleChargeSucceeded(charge, storage2) {
  try {
    logger.info("Charge succeeded", {
      chargeId: charge.id,
      amount: charge.amount / 100,
      currency: charge.currency
    });
    const sellerId = charge.metadata?.sellerId;
    if (sellerId) {
      await storage2.updateBusinessMetrics(sellerId, {
        totalRevenue: charge.amount / 100,
        transactionCount: 1
      });
    }
  } catch (error) {
    logger.error("Failed to handle charge succeeded", {
      error,
      chargeId: charge.id
    });
    throw error;
  }
}
async function handleChargeRefunded(charge, storage2) {
  try {
    const orderId = charge.metadata?.orderId;
    if (orderId) {
      const refundAmount = charge.amount_refunded / 100;
      const isFullRefund = charge.amount_refunded === charge.amount;
      await storage2.updateOrderStatus(
        orderId,
        isFullRefund ? "refunded" : "partially_refunded"
      );
      if (emailQueue && charge.receipt_email) {
        await emailQueue.add("refund-processed", {
          email: charge.receipt_email,
          chargeId: charge.id,
          refundAmount,
          isFullRefund
        });
      }
    }
  } catch (error) {
    logger.error("Failed to handle charge refunded", {
      error,
      chargeId: charge.id
    });
    throw error;
  }
}
async function handleDisputeCreated(dispute, storage2) {
  try {
    logger.warn("Dispute created", {
      disputeId: dispute.id,
      amount: dispute.amount / 100,
      reason: dispute.reason,
      chargeId: dispute.charge
    });
    if (emailQueue) {
      await emailQueue.add("dispute-alert", {
        disputeId: dispute.id,
        amount: dispute.amount / 100,
        reason: dispute.reason,
        evidenceDueBy: dispute.evidence_details?.due_by ? new Date(dispute.evidence_details.due_by * 1e3).toISOString() : null
      }, { priority: 1 });
    }
    trackEvent(
      "system",
      "dispute_created",
      {
        disputeId: dispute.id,
        amount: dispute.amount / 100,
        reason: dispute.reason
      }
    );
  } catch (error) {
    logger.error("Failed to handle dispute created", {
      error,
      disputeId: dispute.id
    });
    throw error;
  }
}
async function handleAccountUpdated(account, storage2) {
  try {
    const businessId = account.metadata?.businessId;
    if (businessId) {
      await storage2.updateBusinessStripeInfo(businessId, {
        stripeAccountId: account.id,
        chargesEnabled: account.charges_enabled,
        payoutsEnabled: account.payouts_enabled,
        detailsSubmitted: account.details_submitted,
        capabilities: account.capabilities
      });
      if (account.charges_enabled && account.payouts_enabled && account.details_submitted) {
        if (emailQueue) {
          await emailQueue.add("connect-onboarded", {
            businessId,
            accountId: account.id
          });
        }
        trackEvent(
          businessId,
          "connect_account_activated",
          { accountId: account.id }
        );
      }
      if (account.requirements?.currently_due?.length) {
        if (emailQueue) {
          await emailQueue.add("verification-required", {
            businessId,
            requirements: account.requirements.currently_due,
            deadline: account.requirements.current_deadline
          });
        }
      }
    }
  } catch (error) {
    logger.error("Failed to handle account updated", {
      error,
      accountId: account.id
    });
    throw error;
  }
}
async function handleAccountDeauthorized(account, storage2) {
  try {
    const businessId = account.metadata?.businessId;
    if (businessId) {
      await storage2.updateBusinessStripeInfo(businessId, {
        stripeAccountId: null,
        chargesEnabled: false,
        payoutsEnabled: false
      });
      logger.warn("Connect account deauthorized", {
        accountId: account.id,
        businessId
      });
    }
  } catch (error) {
    logger.error("Failed to handle account deauthorized", {
      error,
      accountId: account.id
    });
    throw error;
  }
}
async function handlePayoutPaid(payout, storage2) {
  try {
    logger.info("Payout paid", {
      payoutId: payout.id,
      amount: payout.amount / 100,
      currency: payout.currency
    });
    if (emailQueue) {
      const businessId = payout.metadata?.businessId;
      if (businessId) {
        await emailQueue.add("payout-success", {
          businessId,
          payoutId: payout.id,
          amount: payout.amount / 100,
          currency: payout.currency,
          arrivalDate: new Date(payout.arrival_date * 1e3).toISOString()
        });
      }
    }
    trackEvent(
      payout.metadata?.businessId || "system",
      "payout_succeeded",
      {
        payoutId: payout.id,
        amount: payout.amount / 100
      }
    );
  } catch (error) {
    logger.error("Failed to handle payout paid", {
      error,
      payoutId: payout.id
    });
    throw error;
  }
}
async function handlePayoutFailed(payout, storage2) {
  try {
    logger.error("Payout failed", {
      payoutId: payout.id,
      amount: payout.amount / 100,
      failureCode: payout.failure_code,
      failureMessage: payout.failure_message
    });
    if (emailQueue) {
      const businessId = payout.metadata?.businessId;
      if (businessId) {
        await emailQueue.add("payout-failed", {
          businessId,
          payoutId: payout.id,
          amount: payout.amount / 100,
          failureReason: payout.failure_message
        }, { priority: 1 });
      }
    }
  } catch (error) {
    logger.error("Failed to handle payout failed", {
      error,
      payoutId: payout.id
    });
    throw error;
  }
}
async function handleTransferCreated(transfer, storage2) {
  try {
    logger.info("Transfer created", {
      transferId: transfer.id,
      amount: transfer.amount / 100,
      destination: transfer.destination
    });
    const orderId = transfer.metadata?.orderId;
    if (orderId) {
      await storage2.createVendorTransaction({
        orderId,
        transferId: transfer.id,
        amount: transfer.amount / 100,
        destinationAccount: transfer.destination,
        status: "pending"
      });
    }
  } catch (error) {
    logger.error("Failed to handle transfer created", {
      error,
      transferId: transfer.id
    });
    throw error;
  }
}
async function handleTransferReversed(transfer, storage2) {
  try {
    logger.warn("Transfer reversed", {
      transferId: transfer.id,
      amount: transfer.amount_reversed / 100
    });
    await storage2.updateVendorTransactionStatus(transfer.id, "reversed");
    if (emailQueue) {
      const businessId = transfer.metadata?.businessId;
      if (businessId) {
        await emailQueue.add("transfer-reversed", {
          businessId,
          transferId: transfer.id,
          reversedAmount: transfer.amount_reversed / 100
        }, { priority: 1 });
      }
    }
  } catch (error) {
    logger.error("Failed to handle transfer reversed", {
      error,
      transferId: transfer.id
    });
    throw error;
  }
}
async function handleBalanceAvailable(balance, accountId, storage2) {
  try {
    const available = balance.available.reduce((sum2, b) => sum2 + b.amount, 0) / 100;
    const pending = balance.pending.reduce((sum2, b) => sum2 + b.amount, 0) / 100;
    logger.info("Balance updated", {
      accountId,
      available,
      pending
    });
    if (cache) {
      const cacheKey = `stripe:balance:${accountId}`;
      await cache.set(cacheKey, JSON.stringify({ available, pending }), 300);
    }
  } catch (error) {
    logger.error("Failed to handle balance available", {
      error,
      accountId
    });
    throw error;
  }
}
async function handlePaymentMethodAttached(paymentMethod, storage2) {
  try {
    logger.info("Payment method attached", {
      paymentMethodId: paymentMethod.id,
      type: paymentMethod.type,
      customerId: paymentMethod.customer
    });
    if (paymentMethod.customer) {
      trackEvent(
        paymentMethod.customer,
        "payment_method_saved",
        {
          paymentMethodId: paymentMethod.id,
          type: paymentMethod.type
        }
      );
    }
  } catch (error) {
    logger.error("Failed to handle payment method attached", {
      error,
      paymentMethodId: paymentMethod.id
    });
    throw error;
  }
}
async function handleSubscriptionUpdated(subscription, storage2) {
  try {
    const userId = subscription.metadata?.userId;
    if (userId) {
      await storage2.updateUserSubscription(userId, {
        subscriptionId: subscription.id,
        status: subscription.status,
        currentPeriodEnd: new Date(subscription.current_period_end * 1e3),
        cancelAtPeriodEnd: subscription.cancel_at_period_end
      });
      if (emailQueue && subscription.customer) {
        await emailQueue.add("subscription-updated", {
          customerId: subscription.customer,
          subscriptionId: subscription.id,
          status: subscription.status
        });
      }
    }
  } catch (error) {
    logger.error("Failed to handle subscription updated", {
      error,
      subscriptionId: subscription.id
    });
    throw error;
  }
}
async function handleSubscriptionDeleted(subscription, storage2) {
  try {
    const userId = subscription.metadata?.userId;
    if (userId) {
      await storage2.updateUserSubscription(userId, {
        subscriptionId: null,
        status: "canceled"
      });
      if (emailQueue && subscription.customer) {
        await emailQueue.add("subscription-canceled", {
          customerId: subscription.customer,
          subscriptionId: subscription.id
        });
      }
    }
  } catch (error) {
    logger.error("Failed to handle subscription deleted", {
      error,
      subscriptionId: subscription.id
    });
    throw error;
  }
}
async function handleCheckoutSessionCompleted(session2, storage2) {
  try {
    logger.info("Checkout session completed", {
      sessionId: session2.id,
      paymentStatus: session2.payment_status,
      amountTotal: session2.amount_total ? session2.amount_total / 100 : 0
    });
    if (session2.metadata?.cartId && session2.payment_status === "paid") {
      const order = await storage2.createOrderFromCart(
        session2.metadata.cartId,
        session2.payment_intent
      );
      if (emailQueue && session2.customer_email) {
        await emailQueue.add("order-confirmation", {
          email: session2.customer_email,
          orderId: order.id,
          amount: session2.amount_total ? session2.amount_total / 100 : 0
        });
      }
    }
  } catch (error) {
    logger.error("Failed to handle checkout session completed", {
      error,
      sessionId: session2.id
    });
    throw error;
  }
}
async function handleCapabilityUpdated(capability, accountId, storage2) {
  try {
    logger.info("Capability updated", {
      accountId,
      capabilityId: capability.id,
      status: capability.status
    });
    const businessId = capability.account;
    if (businessId) {
      await storage2.updateBusinessCapability(accountId, capability.id, capability.status);
    }
  } catch (error) {
    logger.error("Failed to handle capability updated", {
      error,
      capabilityId: capability.id,
      accountId
    });
    throw error;
  }
}
var WebhookEventType, PROCESSED_EVENTS_KEY, EVENT_LOCK_KEY, EVENT_TTL, stripeWebhooks_default;
var init_stripeWebhooks = __esm({
  "server/stripeWebhooks.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    WebhookEventType = /* @__PURE__ */ ((WebhookEventType2) => {
      WebhookEventType2["PAYMENT_INTENT_SUCCEEDED"] = "payment_intent.succeeded";
      WebhookEventType2["PAYMENT_INTENT_FAILED"] = "payment_intent.payment_failed";
      WebhookEventType2["PAYMENT_INTENT_CANCELED"] = "payment_intent.canceled";
      WebhookEventType2["PAYMENT_INTENT_PROCESSING"] = "payment_intent.processing";
      WebhookEventType2["PAYMENT_INTENT_REQUIRES_ACTION"] = "payment_intent.requires_action";
      WebhookEventType2["CHARGE_SUCCEEDED"] = "charge.succeeded";
      WebhookEventType2["CHARGE_FAILED"] = "charge.failed";
      WebhookEventType2["CHARGE_REFUNDED"] = "charge.refunded";
      WebhookEventType2["CHARGE_DISPUTE_CREATED"] = "charge.dispute.created";
      WebhookEventType2["CHARGE_DISPUTE_UPDATED"] = "charge.dispute.updated";
      WebhookEventType2["CHARGE_DISPUTE_CLOSED"] = "charge.dispute.closed";
      WebhookEventType2["ACCOUNT_UPDATED"] = "account.updated";
      WebhookEventType2["ACCOUNT_APPLICATION_DEAUTHORIZED"] = "account.application.deauthorized";
      WebhookEventType2["ACCOUNT_EXTERNAL_ACCOUNT_CREATED"] = "account.external_account.created";
      WebhookEventType2["ACCOUNT_EXTERNAL_ACCOUNT_DELETED"] = "account.external_account.deleted";
      WebhookEventType2["ACCOUNT_EXTERNAL_ACCOUNT_UPDATED"] = "account.external_account.updated";
      WebhookEventType2["PAYOUT_CREATED"] = "payout.created";
      WebhookEventType2["PAYOUT_UPDATED"] = "payout.updated";
      WebhookEventType2["PAYOUT_PAID"] = "payout.paid";
      WebhookEventType2["PAYOUT_FAILED"] = "payout.failed";
      WebhookEventType2["PAYOUT_CANCELED"] = "payout.canceled";
      WebhookEventType2["TRANSFER_CREATED"] = "transfer.created";
      WebhookEventType2["TRANSFER_UPDATED"] = "transfer.updated";
      WebhookEventType2["TRANSFER_REVERSED"] = "transfer.reversed";
      WebhookEventType2["BALANCE_AVAILABLE"] = "balance.available";
      WebhookEventType2["PAYMENT_METHOD_ATTACHED"] = "payment_method.attached";
      WebhookEventType2["PAYMENT_METHOD_DETACHED"] = "payment_method.detached";
      WebhookEventType2["PAYMENT_METHOD_UPDATED"] = "payment_method.updated";
      WebhookEventType2["CUSTOMER_CREATED"] = "customer.created";
      WebhookEventType2["CUSTOMER_UPDATED"] = "customer.updated";
      WebhookEventType2["CUSTOMER_DELETED"] = "customer.deleted";
      WebhookEventType2["CUSTOMER_SUBSCRIPTION_CREATED"] = "customer.subscription.created";
      WebhookEventType2["CUSTOMER_SUBSCRIPTION_UPDATED"] = "customer.subscription.updated";
      WebhookEventType2["CUSTOMER_SUBSCRIPTION_DELETED"] = "customer.subscription.deleted";
      WebhookEventType2["INVOICE_PAYMENT_SUCCEEDED"] = "invoice.payment_succeeded";
      WebhookEventType2["INVOICE_PAYMENT_FAILED"] = "invoice.payment_failed";
      WebhookEventType2["CHECKOUT_SESSION_COMPLETED"] = "checkout.session.completed";
      WebhookEventType2["CHECKOUT_SESSION_EXPIRED"] = "checkout.session.expired";
      WebhookEventType2["CAPABILITY_UPDATED"] = "capability.updated";
      WebhookEventType2["PERSON_CREATED"] = "person.created";
      WebhookEventType2["PERSON_UPDATED"] = "person.updated";
      WebhookEventType2["PERSON_DELETED"] = "person.deleted";
      return WebhookEventType2;
    })(WebhookEventType || {});
    PROCESSED_EVENTS_KEY = "stripe:webhook:processed";
    EVENT_LOCK_KEY = "stripe:webhook:lock";
    EVENT_TTL = 86400;
    stripeWebhooks_default = {
      handleWebhookEvent,
      WebhookEventType,
      isEventProcessed,
      markEventProcessed
    };
  }
});

// server/stripePayments.ts
var stripePayments_exports = {};
__export(stripePayments_exports, {
  PaymentMethodType: () => PaymentMethodType,
  PaymentStatus: () => PaymentStatus,
  TransferType: () => TransferType,
  calculateFees: () => calculateFees,
  calculateTax: () => calculateTax,
  cancelPaymentIntent: () => cancelPaymentIntent,
  cancelSubscription: () => cancelSubscription,
  confirmPaymentIntent: () => confirmPaymentIntent,
  createCoupon: () => createCoupon,
  createOrRetrieveCustomer: () => createOrRetrieveCustomer,
  createPaymentIntent: () => createPaymentIntent,
  createSubscription: () => createSubscription,
  createTransfer: () => createTransfer,
  default: () => stripePayments_default,
  deletePaymentMethod: () => deletePaymentMethod,
  generateFinancialReport: () => generateFinancialReport,
  handleDispute: () => handleDispute,
  listPaymentMethods: () => listPaymentMethods,
  processRefund: () => processRefund,
  savePaymentMethod: () => savePaymentMethod
});
function calculateFees(amount, options = {}) {
  const subtotal = amount;
  const platformFeePercentage = options.platformFeePercentage ?? PLATFORM_FEE_PERCENTAGE;
  const platformFeeFixed = (options.platformFeeFixed ?? PLATFORM_FEE_FIXED_CENTS) / 100;
  const taxRate = options.taxRate ?? TAX_RATE;
  const couponDiscount = options.couponDiscount ?? 0;
  const discountedSubtotal = Math.max(0, subtotal - couponDiscount);
  const platformFee = discountedSubtotal * platformFeePercentage / 100 + platformFeeFixed;
  const processingFee = discountedSubtotal * 0.029 + 0.3;
  const taxAmount = discountedSubtotal * (taxRate / 100);
  const total = discountedSubtotal + taxAmount;
  const sellerPayout = discountedSubtotal - platformFee - processingFee;
  return {
    subtotal: discountedSubtotal,
    platformFee: Math.round(platformFee * 100) / 100,
    processingFee: Math.round(processingFee * 100) / 100,
    taxAmount: Math.round(taxAmount * 100) / 100,
    total: Math.round(total * 100) / 100,
    sellerPayout: Math.max(0, Math.round(sellerPayout * 100) / 100)
  };
}
async function createPaymentIntent(options) {
  try {
    const stripeClient = getStripeClient();
    const fees = calculateFees(options.amount, {
      taxRate: options.taxAmount ? options.taxAmount / options.amount * 100 : void 0
    });
    const params = {
      amount: Math.round(fees.total * 100),
      // Convert to cents
      currency: options.currency || "usd",
      description: options.description,
      metadata: {
        ...options.metadata,
        platformFee: fees.platformFee.toString(),
        sellerPayout: fees.sellerPayout.toString(),
        taxAmount: fees.taxAmount.toString()
      },
      payment_method_types: options.paymentMethodTypes?.length ? options.paymentMethodTypes : ["card"],
      capture_method: options.captureMethod || "automatic",
      confirmation_method: options.confirmationMethod || "automatic",
      receipt_email: options.receiptEmail,
      shipping: options.shipping
    };
    if (options.customerId) {
      params.customer = options.customerId;
    }
    if (options.savePaymentMethod || options.setupFutureUsage) {
      params.setup_future_usage = options.setupFutureUsage || "off_session";
    }
    if (options.use3DSecure) {
      params.payment_method_options = {
        card: {
          request_three_d_secure: "any"
        }
      };
    }
    if (options.sellerId || options.transferData?.destination) {
      const destination = options.sellerId || options.transferData.destination;
      params.transfer_data = {
        destination,
        amount: options.transferData?.amount ? Math.round(options.transferData.amount * 100) : Math.round(fees.sellerPayout * 100)
      };
      params.application_fee_amount = options.applicationFeeAmount ? Math.round(options.applicationFeeAmount * 100) : Math.round(fees.platformFee * 100);
    }
    if (options.statementDescriptor) {
      params.statement_descriptor = options.statementDescriptor;
    }
    if (options.statementDescriptorSuffix) {
      params.statement_descriptor_suffix = options.statementDescriptorSuffix;
    }
    const paymentIntent = await stripeClient.paymentIntents.create(
      params,
      options.idempotencyKey ? { idempotencyKey: options.idempotencyKey } : {}
    );
    logger.info("Payment intent created", {
      paymentIntentId: paymentIntent.id,
      amount: options.amount,
      sellerId: options.sellerId,
      fees
    });
    trackEvent(
      options.customerId || "guest",
      "payment_intent_created",
      {
        paymentIntentId: paymentIntent.id,
        amount: options.amount,
        currency: options.currency,
        fees
      }
    );
    return paymentIntent;
  } catch (error) {
    logger.error("Failed to create payment intent", { error, options });
    throw new Error(
      `Failed to create payment: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function confirmPaymentIntent(paymentIntentId, paymentMethodId, returnUrl) {
  try {
    const stripeClient = getStripeClient();
    const confirmParams = {
      return_url: returnUrl
    };
    if (paymentMethodId) {
      confirmParams.payment_method = paymentMethodId;
    }
    const paymentIntent = await stripeClient.paymentIntents.confirm(
      paymentIntentId,
      confirmParams
    );
    logger.info("Payment intent confirmed", {
      paymentIntentId: paymentIntent.id,
      status: paymentIntent.status
    });
    return paymentIntent;
  } catch (error) {
    logger.error("Failed to confirm payment intent", { error, paymentIntentId });
    throw new Error(
      `Failed to confirm payment: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function cancelPaymentIntent(paymentIntentId, cancellationReason) {
  try {
    const stripeClient = getStripeClient();
    const paymentIntent = await stripeClient.paymentIntents.cancel(
      paymentIntentId,
      cancellationReason ? { cancellation_reason: cancellationReason } : {}
    );
    logger.info("Payment intent canceled", {
      paymentIntentId: paymentIntent.id
    });
    return paymentIntent;
  } catch (error) {
    logger.error("Failed to cancel payment intent", { error, paymentIntentId });
    throw new Error(
      `Failed to cancel payment: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function processRefund(options) {
  try {
    const stripeClient = getStripeClient();
    const refundParams = {
      payment_intent: options.paymentIntentId,
      amount: options.amount ? Math.round(options.amount * 100) : void 0,
      // Partial refund
      reason: options.reason,
      metadata: options.metadata,
      refund_application_fee: options.refundApplicationFee,
      reverse_transfer: options.reverseTransfer
    };
    const refund = await stripeClient.refunds.create(
      refundParams,
      options.idempotencyKey ? { idempotencyKey: options.idempotencyKey } : {}
    );
    logger.info("Refund processed", {
      refundId: refund.id,
      paymentIntentId: options.paymentIntentId,
      amount: refund.amount / 100
    });
    trackEvent(
      "system",
      "refund_processed",
      {
        refundId: refund.id,
        paymentIntentId: options.paymentIntentId,
        amount: refund.amount / 100,
        reason: options.reason
      }
    );
    return refund;
  } catch (error) {
    logger.error("Failed to process refund", { error, options });
    throw new Error(
      `Failed to process refund: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createOrRetrieveCustomer(userId, email, name) {
  try {
    const stripeClient = getStripeClient();
    const cacheKey = `stripe:customer:${userId}`;
    const cached = await cache?.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    const customers = await stripeClient.customers.list({
      limit: 1,
      email
    });
    let customer;
    if (customers.data.length > 0) {
      customer = customers.data[0];
    } else {
      customer = await stripeClient.customers.create({
        email,
        name,
        metadata: {
          userId
        }
      });
      logger.info("Stripe customer created", {
        customerId: customer.id,
        userId
      });
    }
    if (cache) {
      await cache.set(cacheKey, JSON.stringify(customer), 3600);
    }
    return customer;
  } catch (error) {
    logger.error("Failed to create/retrieve customer", { error, userId });
    throw new Error(
      `Failed to manage customer: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function savePaymentMethod(customerId, paymentMethodId, setAsDefault = false) {
  try {
    const stripeClient = getStripeClient();
    const paymentMethod = await stripeClient.paymentMethods.attach(
      paymentMethodId,
      { customer: customerId }
    );
    if (setAsDefault) {
      await stripeClient.customers.update(customerId, {
        invoice_settings: {
          default_payment_method: paymentMethodId
        }
      });
    }
    logger.info("Payment method saved", {
      paymentMethodId,
      customerId,
      setAsDefault
    });
    return paymentMethod;
  } catch (error) {
    logger.error("Failed to save payment method", { error, customerId, paymentMethodId });
    throw new Error(
      `Failed to save payment method: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function listPaymentMethods(customerId, type = "card") {
  try {
    const stripeClient = getStripeClient();
    const paymentMethods = await stripeClient.paymentMethods.list({
      customer: customerId,
      type
    });
    return paymentMethods.data;
  } catch (error) {
    logger.error("Failed to list payment methods", { error, customerId });
    throw new Error(
      `Failed to retrieve payment methods: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function deletePaymentMethod(paymentMethodId) {
  try {
    const stripeClient = getStripeClient();
    const paymentMethod = await stripeClient.paymentMethods.detach(paymentMethodId);
    logger.info("Payment method deleted", { paymentMethodId });
    return paymentMethod;
  } catch (error) {
    logger.error("Failed to delete payment method", { error, paymentMethodId });
    throw new Error(
      `Failed to delete payment method: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createSubscription(customerId, priceId, options = {}) {
  try {
    const stripeClient = getStripeClient();
    const subscriptionParams = {
      customer: customerId,
      items: [{ price: priceId }],
      metadata: options.metadata,
      trial_period_days: options.trialDays,
      coupon: options.coupon,
      payment_behavior: "default_incomplete",
      expand: ["latest_invoice.payment_intent"]
    };
    if (options.paymentMethodId) {
      subscriptionParams.default_payment_method = options.paymentMethodId;
    }
    const subscription = await stripeClient.subscriptions.create(subscriptionParams);
    logger.info("Subscription created", {
      subscriptionId: subscription.id,
      customerId,
      priceId
    });
    trackEvent(
      customerId,
      "subscription_created",
      {
        subscriptionId: subscription.id,
        priceId,
        trialDays: options.trialDays
      }
    );
    return subscription;
  } catch (error) {
    logger.error("Failed to create subscription", { error, customerId, priceId });
    throw new Error(
      `Failed to create subscription: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function cancelSubscription(subscriptionId, immediately = false) {
  try {
    const stripeClient = getStripeClient();
    const subscription = immediately ? await stripeClient.subscriptions.cancel(subscriptionId) : await stripeClient.subscriptions.update(subscriptionId, {
      cancel_at_period_end: true
    });
    logger.info("Subscription canceled", {
      subscriptionId,
      immediately
    });
    return subscription;
  } catch (error) {
    logger.error("Failed to cancel subscription", { error, subscriptionId });
    throw new Error(
      `Failed to cancel subscription: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createTransfer(amount, destinationAccountId, options = {}) {
  try {
    const stripeClient = getStripeClient();
    const transfer = await stripeClient.transfers.create({
      amount: Math.round(amount * 100),
      // Convert to cents
      currency: options.currency || "usd",
      destination: destinationAccountId,
      description: options.description,
      source_transaction: options.sourceTransaction,
      metadata: options.metadata,
      transfer_group: options.transferGroup
    });
    logger.info("Transfer created", {
      transferId: transfer.id,
      amount,
      destination: destinationAccountId
    });
    return transfer;
  } catch (error) {
    logger.error("Failed to create transfer", { error, amount, destinationAccountId });
    throw new Error(
      `Failed to create transfer: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function generateFinancialReport(startDate, endDate, options = {}) {
  try {
    const stripeClient = getStripeClient();
    const stripeAccount = options.accountId ? { stripeAccount: options.accountId } : {};
    const charges = options.includeCharges !== false ? await stripeClient.charges.list(
      {
        created: {
          gte: Math.floor(startDate.getTime() / 1e3),
          lte: Math.floor(endDate.getTime() / 1e3)
        },
        limit: 100
      },
      stripeAccount
    ) : { data: [] };
    const refunds = options.includeRefunds !== false ? await stripeClient.refunds.list(
      {
        created: {
          gte: Math.floor(startDate.getTime() / 1e3),
          lte: Math.floor(endDate.getTime() / 1e3)
        },
        limit: 100
      },
      stripeAccount
    ) : { data: [] };
    const payouts = options.includePayouts !== false && options.accountId ? await stripeClient.payouts.list(
      {
        created: {
          gte: Math.floor(startDate.getTime() / 1e3),
          lte: Math.floor(endDate.getTime() / 1e3)
        },
        limit: 100
      },
      stripeAccount
    ) : { data: [] };
    const totalRevenue = charges.data.reduce((sum2, charge) => sum2 + charge.amount, 0) / 100;
    const totalRefunds = refunds.data.reduce((sum2, refund) => sum2 + refund.amount, 0) / 100;
    const totalPayouts = payouts.data.reduce((sum2, payout) => sum2 + payout.amount, 0) / 100;
    const totalFees = charges.data.reduce(
      (sum2, charge) => sum2 + (charge.application_fee_amount || 0),
      0
    ) / 100;
    const summary = {
      totalRevenue,
      totalFees,
      totalPayouts,
      totalRefunds,
      netRevenue: totalRevenue - totalRefunds - totalFees
    };
    const byDay = {};
    charges.data.forEach((charge) => {
      const date2 = new Date(charge.created * 1e3).toISOString().split("T")[0];
      if (!byDay[date2]) byDay[date2] = { revenue: 0, refunds: 0, fees: 0, transactions: 0 };
      byDay[date2].revenue += charge.amount / 100;
      byDay[date2].fees += (charge.application_fee_amount || 0) / 100;
      byDay[date2].transactions += 1;
    });
    refunds.data.forEach((refund) => {
      const date2 = new Date(refund.created * 1e3).toISOString().split("T")[0];
      if (!byDay[date2]) byDay[date2] = { revenue: 0, refunds: 0, fees: 0, transactions: 0 };
      byDay[date2].refunds += refund.amount / 100;
    });
    const transactions = [
      ...charges.data.map((c) => ({ ...c, type: "charge" })),
      ...refunds.data.map((r) => ({ ...r, type: "refund" })),
      ...payouts.data.map((p) => ({ ...p, type: "payout" }))
    ].sort((a, b) => b.created - a.created);
    logger.info("Financial report generated", {
      startDate,
      endDate,
      summary
    });
    return {
      summary,
      transactions,
      byDay
    };
  } catch (error) {
    logger.error("Failed to generate financial report", { error, startDate, endDate });
    throw new Error(
      `Failed to generate report: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function createCoupon(options) {
  try {
    const stripeClient = getStripeClient();
    const couponParams = {
      percent_off: options.percentOff,
      amount_off: options.amountOff ? Math.round(options.amountOff * 100) : void 0,
      currency: options.currency || "usd",
      duration: options.duration,
      duration_in_months: options.durationInMonths,
      max_redemptions: options.maxRedemptions,
      redeem_by: options.redeemBy ? Math.floor(options.redeemBy.getTime() / 1e3) : void 0,
      id: options.id,
      name: options.name,
      metadata: options.metadata
    };
    const coupon = await stripeClient.coupons.create(couponParams);
    logger.info("Coupon created", {
      couponId: coupon.id,
      percentOff: options.percentOff,
      amountOff: options.amountOff
    });
    return coupon;
  } catch (error) {
    logger.error("Failed to create coupon", { error, options });
    throw new Error(
      `Failed to create coupon: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function calculateTax(amount, address) {
  try {
    const taxRate = TAX_RATE;
    const taxAmount = amount * (taxRate / 100);
    return {
      taxAmount: Math.round(taxAmount * 100) / 100,
      taxRate,
      jurisdiction: `${address.state}, ${address.country}`
    };
  } catch (error) {
    logger.error("Failed to calculate tax", { error, amount, address });
    throw new Error(
      `Failed to calculate tax: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function handleDispute(disputeId, evidence) {
  try {
    const stripeClient = getStripeClient();
    const dispute = await stripeClient.disputes.update(disputeId, {
      evidence: {
        customer_communication: evidence.customerCommunication,
        receipt: evidence.receipt,
        shipping_documentation: evidence.shippingDocumentation,
        service_documentation: evidence.serviceDocumentation,
        refund_policy: evidence.refundPolicy
      },
      metadata: evidence.metadata
    });
    logger.info("Dispute evidence submitted", {
      disputeId,
      hasReceipt: !!evidence.receipt,
      hasShipping: !!evidence.shippingDocumentation
    });
    return dispute;
  } catch (error) {
    logger.error("Failed to handle dispute", { error, disputeId });
    throw new Error(
      `Failed to handle dispute: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
var PLATFORM_FEE_PERCENTAGE, PLATFORM_FEE_FIXED_CENTS, TAX_RATE, PaymentMethodType, PaymentStatus, TransferType, stripePayments_default;
var init_stripePayments = __esm({
  "server/stripePayments.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    init_stripeConnect();
    PLATFORM_FEE_PERCENTAGE = 5;
    PLATFORM_FEE_FIXED_CENTS = 30;
    TAX_RATE = 7;
    PaymentMethodType = /* @__PURE__ */ ((PaymentMethodType2) => {
      PaymentMethodType2["CARD"] = "card";
      PaymentMethodType2["ACH_DEBIT"] = "ach_debit";
      PaymentMethodType2["APPLE_PAY"] = "apple_pay";
      PaymentMethodType2["GOOGLE_PAY"] = "google_pay";
      PaymentMethodType2["BANK_TRANSFER"] = "bank_transfer";
      return PaymentMethodType2;
    })(PaymentMethodType || {});
    PaymentStatus = /* @__PURE__ */ ((PaymentStatus2) => {
      PaymentStatus2["PENDING"] = "pending";
      PaymentStatus2["PROCESSING"] = "processing";
      PaymentStatus2["REQUIRES_ACTION"] = "requires_action";
      PaymentStatus2["SUCCEEDED"] = "succeeded";
      PaymentStatus2["FAILED"] = "failed";
      PaymentStatus2["CANCELED"] = "canceled";
      PaymentStatus2["REFUNDED"] = "refunded";
      PaymentStatus2["PARTIALLY_REFUNDED"] = "partially_refunded";
      return PaymentStatus2;
    })(PaymentStatus || {});
    TransferType = /* @__PURE__ */ ((TransferType2) => {
      TransferType2["IMMEDIATE"] = "immediate";
      TransferType2["DELAYED"] = "delayed";
      TransferType2["SCHEDULED"] = "scheduled";
      return TransferType2;
    })(TransferType || {});
    stripePayments_default = {
      createPaymentIntent,
      confirmPaymentIntent,
      cancelPaymentIntent,
      processRefund,
      createOrRetrieveCustomer,
      savePaymentMethod,
      listPaymentMethods,
      deletePaymentMethod,
      createSubscription,
      cancelSubscription,
      createTransfer,
      generateFinancialReport,
      createCoupon,
      calculateTax,
      calculateFees,
      handleDispute
    };
  }
});

// server/stripeCompliance.ts
var stripeCompliance_exports = {};
__export(stripeCompliance_exports, {
  ComplianceLevel: () => ComplianceLevel,
  RiskLevel: () => RiskLevel,
  blockCustomer: () => blockCustomer,
  default: () => stripeCompliance_default,
  generateComplianceReport: () => generateComplianceReport,
  generateTaxReport: () => generateTaxReport,
  performRadarCheck: () => performRadarCheck,
  performSecurityCheck: () => performSecurityCheck,
  recordFailedAttempt: () => recordFailedAttempt,
  recordSuccessfulPayment: () => recordSuccessfulPayment,
  requireSCA: () => requireSCA,
  unblockCustomer: () => unblockCustomer
});
import crypto3 from "crypto";
async function performSecurityCheck(paymentData) {
  const checks = {
    velocity: true,
    amount: true,
    country: true,
    time: true,
    history: true,
    device: true
  };
  const reasons = [];
  let riskLevel = "low" /* LOW */;
  try {
    if (paymentData.customerId) {
      const velocityCheck = await checkVelocityLimit(paymentData.customerId);
      checks.velocity = velocityCheck.passed;
      if (!velocityCheck.passed) {
        reasons.push(velocityCheck.reason);
        riskLevel = "high" /* HIGH */;
      }
    }
    if (paymentData.amount > FRAUD_THRESHOLDS.HIGH_RISK_AMOUNT) {
      checks.amount = false;
      reasons.push(`High-risk amount: $${paymentData.amount}`);
      riskLevel = "medium" /* MEDIUM */;
    }
    if (paymentData.country && FRAUD_THRESHOLDS.SUSPICIOUS_COUNTRY_LIST.includes(paymentData.country)) {
      checks.country = false;
      reasons.push(`High-risk country: ${paymentData.country}`);
      riskLevel = "high" /* HIGH */;
    }
    const hour = (/* @__PURE__ */ new Date()).getHours();
    if (hour >= FRAUD_THRESHOLDS.UNUSUAL_HOUR_START && hour <= FRAUD_THRESHOLDS.UNUSUAL_HOUR_END) {
      checks.time = false;
      reasons.push(`Unusual transaction time: ${hour}:00`);
      if (riskLevel === "low" /* LOW */) riskLevel = "medium" /* MEDIUM */;
    }
    if (paymentData.customerId) {
      const historyCheck = await checkCustomerHistory(paymentData.customerId);
      checks.history = historyCheck.trusted;
      if (!historyCheck.trusted) {
        reasons.push(historyCheck.reason);
        if (historyCheck.blocked) {
          riskLevel = "blocked" /* BLOCKED */;
        } else if (riskLevel === "low" /* LOW */) {
          riskLevel = "medium" /* MEDIUM */;
        }
      }
    }
    if (paymentData.ipAddress) {
      const deviceCheck = await checkDeviceFingerprint(
        paymentData.ipAddress,
        paymentData.userAgent
      );
      checks.device = deviceCheck.trusted;
      if (!deviceCheck.trusted) {
        reasons.push(deviceCheck.reason);
        if (riskLevel === "low" /* LOW */) riskLevel = "medium" /* MEDIUM */;
      }
    }
    const passed = Object.values(checks).every((check) => check);
    let suggestedAction = "proceed";
    let requiresAdditionalVerification = false;
    if (riskLevel === "blocked" /* BLOCKED */) {
      suggestedAction = "block";
    } else if (riskLevel === "high" /* HIGH */) {
      suggestedAction = "manual_review";
      requiresAdditionalVerification = true;
    } else if (riskLevel === "medium" /* MEDIUM */) {
      suggestedAction = "additional_verification";
      requiresAdditionalVerification = true;
    }
    logger.info("Security check completed", {
      customerId: paymentData.customerId,
      riskLevel,
      passed,
      reasons
    });
    return {
      passed,
      riskLevel,
      checks,
      reasons,
      requiresAdditionalVerification,
      suggestedAction
    };
  } catch (error) {
    logger.error("Security check failed", { error, paymentData });
    return {
      passed: false,
      riskLevel: "medium" /* MEDIUM */,
      checks,
      reasons: ["Security check error - flagged for review"],
      requiresAdditionalVerification: true,
      suggestedAction: "manual_review"
    };
  }
}
async function checkVelocityLimit(customerId) {
  const key = `fraud:velocity:${customerId}`;
  const hour = Math.floor(Date.now() / 36e5);
  const hourKey = `${key}:${hour}`;
  try {
    if (!cache) {
      return { passed: true, reason: "" };
    }
    const count2 = await cache.increment(hourKey);
    if (count2 === 1) {
      await cache.expire(hourKey, 3600);
    }
    if (count2 > FRAUD_THRESHOLDS.VELOCITY_LIMIT) {
      return {
        passed: false,
        reason: `Velocity limit exceeded: ${count2} transactions in current hour`
      };
    }
    return { passed: true, reason: "" };
  } catch (error) {
    logger.error("Velocity check failed", { error, customerId });
    return { passed: true, reason: "" };
  }
}
async function checkCustomerHistory(customerId) {
  const key = `fraud:history:${customerId}`;
  try {
    if (!cache) {
      return { trusted: true, blocked: false, reason: "" };
    }
    const blockedKey = `${key}:blocked`;
    const isBlocked = await cache.get(blockedKey);
    if (isBlocked) {
      return {
        trusted: false,
        blocked: true,
        reason: "Customer is blocked due to previous fraud"
      };
    }
    const failedKey = `${key}:failed`;
    const failedAttempts = await cache.get(failedKey);
    if (failedAttempts && failedAttempts > FRAUD_THRESHOLDS.MAX_FAILED_ATTEMPTS) {
      return {
        trusted: false,
        blocked: false,
        reason: `High number of failed attempts: ${failedAttempts}`
      };
    }
    const successKey = `${key}:success`;
    const successCount = await cache.get(successKey);
    if (!successCount || successCount < 1) {
      return {
        trusted: false,
        blocked: false,
        reason: "New customer - no payment history"
      };
    }
    return { trusted: true, blocked: false, reason: "" };
  } catch (error) {
    logger.error("History check failed", { error, customerId });
    return { trusted: true, blocked: false, reason: "" };
  }
}
async function checkDeviceFingerprint(ipAddress, userAgent) {
  if (!ipAddress) {
    return { trusted: true, reason: "" };
  }
  const fingerprint = generateDeviceFingerprint(ipAddress, userAgent);
  const key = `fraud:device:${fingerprint}`;
  try {
    if (!cache) {
      return { trusted: true, reason: "" };
    }
    const blacklisted = await cache.get(`${key}:blacklisted`);
    if (blacklisted) {
      return {
        trusted: false,
        reason: "Device is blacklisted"
      };
    }
    const usageKey = `${key}:usage`;
    const usageCount = await cache.increment(usageKey);
    if (usageCount === 1) {
      await cache.expire(usageKey, 86400);
    }
    if (usageCount > 10) {
      return {
        trusted: false,
        reason: `Suspicious device activity: ${usageCount} different accounts`
      };
    }
    return { trusted: true, reason: "" };
  } catch (error) {
    logger.error("Device check failed", { error, ipAddress });
    return { trusted: true, reason: "" };
  }
}
function generateDeviceFingerprint(ipAddress, userAgent) {
  const data = `${ipAddress}:${userAgent || "unknown"}`;
  return crypto3.createHash("sha256").update(data).digest("hex").substring(0, 16);
}
async function performRadarCheck(paymentIntentId) {
  try {
    const stripeClient = getStripeClient();
    const paymentIntent = await stripeClient.paymentIntents.retrieve(
      paymentIntentId,
      { expand: ["latest_charge.outcome"] }
    );
    const charge = paymentIntent.latest_charge;
    const outcome = charge?.outcome;
    if (!outcome) {
      return {
        score: 0,
        riskLevel: "low" /* LOW */,
        factors: [],
        blocked: false,
        requiresReview: false,
        recommendations: []
      };
    }
    let score = 0;
    const factors = [];
    const recommendations = [];
    if (outcome.risk_level === "highest") {
      score += 80;
      factors.push("Stripe marked as highest risk");
      recommendations.push("Block transaction");
    } else if (outcome.risk_level === "elevated") {
      score += 40;
      factors.push("Stripe marked as elevated risk");
      recommendations.push("Request additional verification");
    }
    if (outcome.risk_score && outcome.risk_score > 65) {
      score += 30;
      factors.push(`High Stripe risk score: ${outcome.risk_score}`);
    }
    if (outcome.type === "blocked") {
      score = 100;
      factors.push("Transaction blocked by Stripe");
      recommendations.push("Do not process");
    }
    const cvcCheck = charge?.payment_method_details?.card?.checks?.cvc_check;
    const addressCheck = charge?.payment_method_details?.card?.checks?.address_line1_check;
    if (cvcCheck === "fail") {
      score += 20;
      factors.push("CVC verification failed");
      recommendations.push("Request correct CVC");
    }
    if (addressCheck === "fail") {
      score += 15;
      factors.push("Address verification failed");
      recommendations.push("Verify billing address");
    }
    let riskLevel;
    let blocked = false;
    let requiresReview = false;
    if (score >= 80) {
      riskLevel = "blocked" /* BLOCKED */;
      blocked = true;
      requiresReview = true;
    } else if (score >= 50) {
      riskLevel = "high" /* HIGH */;
      requiresReview = true;
    } else if (score >= 25) {
      riskLevel = "medium" /* MEDIUM */;
      requiresReview = true;
    } else {
      riskLevel = "low" /* LOW */;
    }
    logger.info("Radar check completed", {
      paymentIntentId,
      score,
      riskLevel,
      factors
    });
    return {
      score,
      riskLevel,
      factors,
      blocked,
      requiresReview,
      recommendations
    };
  } catch (error) {
    logger.error("Radar check failed", { error, paymentIntentId });
    return {
      score: 50,
      riskLevel: "medium" /* MEDIUM */,
      factors: ["Unable to perform Radar check"],
      blocked: false,
      requiresReview: true,
      recommendations: ["Manual review required"]
    };
  }
}
async function requireSCA(paymentIntentId) {
  try {
    const stripeClient = getStripeClient();
    const paymentIntent = await stripeClient.paymentIntents.retrieve(paymentIntentId);
    const authenticationRequired = paymentIntent.status === "requires_action" && paymentIntent.next_action?.type === "use_stripe_sdk";
    if (authenticationRequired) {
      return {
        required: true,
        type: "3d_secure_2",
        status: "pending_authentication"
      };
    }
    const authenticated = paymentIntent.charges?.data[0]?.payment_method_details?.card?.three_d_secure;
    if (authenticated) {
      return {
        required: true,
        type: authenticated.version,
        status: authenticated.result || "unknown"
      };
    }
    return {
      required: false,
      type: "none",
      status: "not_required"
    };
  } catch (error) {
    logger.error("SCA check failed", { error, paymentIntentId });
    return {
      required: true,
      type: "3d_secure_2",
      status: "error"
    };
  }
}
async function generateComplianceReport(startDate, endDate) {
  try {
    const stripeClient = getStripeClient();
    const charges = await stripeClient.charges.list({
      created: {
        gte: Math.floor(startDate.getTime() / 1e3),
        lte: Math.floor(endDate.getTime() / 1e3)
      },
      limit: 100
    });
    const transactionCount = charges.data.length;
    let complianceLevel;
    const yearlyEstimate = transactionCount * 12;
    if (yearlyEstimate > 6e6) {
      complianceLevel = "level_1" /* LEVEL_1 */;
    } else if (yearlyEstimate > 1e6) {
      complianceLevel = "level_2" /* LEVEL_2 */;
    } else if (yearlyEstimate > 2e4) {
      complianceLevel = "level_3" /* LEVEL_3 */;
    } else {
      complianceLevel = "level_4" /* LEVEL_4 */;
    }
    const securityMetrics = {
      encryptedTransactions: transactionCount,
      // All Stripe transactions are encrypted
      tokenizedPayments: charges.data.filter((c) => c.payment_method).length,
      scaAuthentications: charges.data.filter(
        (c) => c.payment_method_details?.card?.three_d_secure
      ).length,
      failedSecurityChecks: charges.data.filter(
        (c) => c.outcome?.risk_level === "highest"
      ).length
    };
    const recommendations = [];
    if (securityMetrics.scaAuthentications < transactionCount * 0.3) {
      recommendations.push("Increase SCA adoption for European transactions");
    }
    if (securityMetrics.failedSecurityChecks > transactionCount * 0.05) {
      recommendations.push("Review and enhance fraud detection rules");
    }
    if (complianceLevel === "level_1" /* LEVEL_1 */ || complianceLevel === "level_2" /* LEVEL_2 */) {
      recommendations.push("Schedule quarterly security assessment");
      recommendations.push("Implement network segmentation");
    }
    recommendations.push("Regular security training for staff");
    recommendations.push("Update incident response procedures");
    const nextAuditDate = /* @__PURE__ */ new Date();
    if (complianceLevel === "level_1" /* LEVEL_1 */) {
      nextAuditDate.setMonth(nextAuditDate.getMonth() + 3);
    } else if (complianceLevel === "level_2" /* LEVEL_2 */) {
      nextAuditDate.setMonth(nextAuditDate.getMonth() + 3);
    } else if (complianceLevel === "level_3" /* LEVEL_3 */) {
      nextAuditDate.setMonth(nextAuditDate.getMonth() + 6);
    } else {
      nextAuditDate.setFullYear(nextAuditDate.getFullYear() + 1);
    }
    logger.info("Compliance report generated", {
      complianceLevel,
      transactionCount,
      period: { startDate, endDate }
    });
    return {
      complianceLevel,
      transactionCount,
      securityMetrics,
      recommendations,
      nextAuditDate
    };
  } catch (error) {
    logger.error("Failed to generate compliance report", { error, startDate, endDate });
    throw new Error(
      `Failed to generate compliance report: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function blockCustomer(customerId, reason) {
  try {
    if (!cache) return;
    const key = `fraud:history:${customerId}:blocked`;
    await cache.set(key, reason, 0);
    logger.warn("Customer blocked", { customerId, reason });
    trackEvent(
      "system",
      "customer_blocked",
      { customerId, reason }
    );
  } catch (error) {
    logger.error("Failed to block customer", { error, customerId });
    throw error;
  }
}
async function unblockCustomer(customerId) {
  try {
    if (!cache) return;
    const key = `fraud:history:${customerId}:blocked`;
    await cache.delete(key);
    logger.info("Customer unblocked", { customerId });
    trackEvent(
      "system",
      "customer_unblocked",
      { customerId }
    );
  } catch (error) {
    logger.error("Failed to unblock customer", { error, customerId });
    throw error;
  }
}
async function recordFailedAttempt(customerId, reason) {
  try {
    if (!cache) return;
    const key = `fraud:history:${customerId}:failed`;
    const count2 = await cache.increment(key);
    if (count2 === 1) {
      await cache.expire(key, 86400);
    }
    if (count2 > FRAUD_THRESHOLDS.MAX_FAILED_ATTEMPTS * 2) {
      await blockCustomer(customerId, "Too many failed payment attempts");
    }
    logger.info("Failed attempt recorded", { customerId, count: count2, reason });
  } catch (error) {
    logger.error("Failed to record failed attempt", { error, customerId });
  }
}
async function recordSuccessfulPayment(customerId, amount) {
  try {
    if (!cache) return;
    const successKey = `fraud:history:${customerId}:success`;
    const count2 = await cache.increment(successKey);
    const failedKey = `fraud:history:${customerId}:failed`;
    await cache.delete(failedKey);
    logger.info("Successful payment recorded", { customerId, count: count2, amount });
  } catch (error) {
    logger.error("Failed to record successful payment", { error, customerId });
  }
}
async function generateTaxReport(accountId, year) {
  try {
    const stripeClient = getStripeClient();
    const startDate = new Date(year, 0, 1);
    const endDate = new Date(year, 11, 31, 23, 59, 59);
    const transfers = await stripeClient.transfers.list(
      {
        destination: accountId,
        created: {
          gte: Math.floor(startDate.getTime() / 1e3),
          lte: Math.floor(endDate.getTime() / 1e3)
        },
        limit: 100
      }
    );
    const totalGrossVolume = transfers.data.reduce((sum2, t) => sum2 + t.amount, 0) / 100;
    const totalTransactions = transfers.data.length;
    const reportingRequired = totalGrossVolume >= 600;
    logger.info("Tax report generated", {
      accountId,
      year,
      totalGrossVolume,
      totalTransactions,
      reportingRequired
    });
    return {
      totalGrossVolume,
      totalTransactions,
      reportingRequired,
      form1099K: {
        grossAmount: totalGrossVolume,
        cardTransactions: totalTransactions,
        thirdPartyNetworkTransactions: 0
      }
    };
  } catch (error) {
    logger.error("Failed to generate tax report", { error, accountId, year });
    throw new Error(
      `Failed to generate tax report: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
var FRAUD_THRESHOLDS, ComplianceLevel, RiskLevel, stripeCompliance_default;
var init_stripeCompliance = __esm({
  "server/stripeCompliance.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    init_stripeConnect();
    FRAUD_THRESHOLDS = {
      HIGH_RISK_AMOUNT: 1e4,
      // $10,000
      VELOCITY_LIMIT: 5,
      // Max transactions per hour
      SUSPICIOUS_COUNTRY_LIST: ["NG", "PK", "ID", "VN"],
      // High-risk countries
      MAX_FAILED_ATTEMPTS: 3,
      UNUSUAL_HOUR_START: 2,
      // 2 AM
      UNUSUAL_HOUR_END: 5
      // 5 AM
    };
    ComplianceLevel = /* @__PURE__ */ ((ComplianceLevel2) => {
      ComplianceLevel2["LEVEL_1"] = "level_1";
      ComplianceLevel2["LEVEL_2"] = "level_2";
      ComplianceLevel2["LEVEL_3"] = "level_3";
      ComplianceLevel2["LEVEL_4"] = "level_4";
      return ComplianceLevel2;
    })(ComplianceLevel || {});
    RiskLevel = /* @__PURE__ */ ((RiskLevel2) => {
      RiskLevel2["LOW"] = "low";
      RiskLevel2["MEDIUM"] = "medium";
      RiskLevel2["HIGH"] = "high";
      RiskLevel2["BLOCKED"] = "blocked";
      return RiskLevel2;
    })(RiskLevel || {});
    stripeCompliance_default = {
      performSecurityCheck,
      performRadarCheck,
      requireSCA,
      generateComplianceReport,
      blockCustomer,
      unblockCustomer,
      recordFailedAttempt,
      recordSuccessfulPayment,
      generateTaxReport,
      ComplianceLevel,
      RiskLevel
    };
  }
});

// server/loyaltyStorage.ts
var loyaltyStorage_exports = {};
__export(loyaltyStorage_exports, {
  LoyaltyStorage: () => LoyaltyStorage,
  loyaltyStorage: () => loyaltyStorage
});
import { eq as eq6, and as and6, desc as desc4, sql as sql5, gte as gte3, lte as lte3, isNull as isNull2, or as or4 } from "drizzle-orm";
var LoyaltyStorage, loyaltyStorage;
var init_loyaltyStorage = __esm({
  "server/loyaltyStorage.ts"() {
    "use strict";
    init_db();
    init_schema();
    LoyaltyStorage = class {
      // ========================================
      // LOYALTY ACCOUNT MANAGEMENT
      // ========================================
      /**
       * Create a new loyalty account for a user (auto-enroll)
       */
      async createLoyaltyAccount(userId) {
        const existing = await this.getLoyaltyAccount(userId);
        if (existing) {
          return existing;
        }
        const bronzeTier = await db.select().from(loyaltyTiers).where(eq6(loyaltyTiers.level, 1)).limit(1);
        const [account] = await db.insert(loyaltyAccounts).values({
          userId,
          currentPoints: 0,
          lifetimePoints: 0,
          tierId: bronzeTier[0]?.id,
          tierName: "Bronze",
          tierLevel: 1
        }).returning();
        return account;
      }
      /**
       * Get loyalty account for a user
       */
      async getLoyaltyAccount(userId) {
        const [account] = await db.select().from(loyaltyAccounts).where(eq6(loyaltyAccounts.userId, userId)).limit(1);
        return account || null;
      }
      /**
       * Get or create loyalty account (ensures user has an account)
       */
      async getOrCreateLoyaltyAccount(userId) {
        const existing = await this.getLoyaltyAccount(userId);
        if (existing) {
          return existing;
        }
        return await this.createLoyaltyAccount(userId);
      }
      /**
       * Award points to a user
       */
      async awardPoints(userId, points, source, sourceId, description, metadata) {
        const account = await this.getOrCreateLoyaltyAccount(userId);
        const expiresAt = /* @__PURE__ */ new Date();
        expiresAt.setFullYear(expiresAt.getFullYear() + 1);
        const newBalance = account.currentPoints + points;
        const newLifetimePoints = account.lifetimePoints + points;
        await db.update(loyaltyAccounts).set({
          currentPoints: newBalance,
          lifetimePoints: newLifetimePoints,
          lastActivityAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq6(loyaltyAccounts.id, account.id));
        const [transaction] = await db.insert(loyaltyTransactions).values({
          userId,
          accountId: account.id,
          type: "earned",
          points,
          balanceAfter: newBalance,
          source,
          sourceId,
          description: description || `Earned ${points} points from ${source}`,
          expiresAt,
          metadata
        }).returning();
        await this.checkAndUpgradeTier(userId);
        return transaction;
      }
      /**
       * Redeem (spend) points
       */
      async redeemPoints(userId, points, source, sourceId, description) {
        const account = await this.getLoyaltyAccount(userId);
        if (!account) {
          throw new Error("Loyalty account not found");
        }
        if (account.currentPoints < points) {
          throw new Error("Insufficient points");
        }
        const newBalance = account.currentPoints - points;
        await db.update(loyaltyAccounts).set({
          currentPoints: newBalance,
          lastActivityAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq6(loyaltyAccounts.id, account.id));
        const [transaction] = await db.insert(loyaltyTransactions).values({
          userId,
          accountId: account.id,
          type: "redeemed",
          points: -points,
          // Negative for spent points
          balanceAfter: newBalance,
          source,
          sourceId,
          description: description || `Redeemed ${points} points for ${source}`
        }).returning();
        return transaction;
      }
      /**
       * Get user's points transactions
       */
      async getTransactions(userId, filters) {
        const { type, limit = 50, offset = 0 } = filters || {};
        let query = db.select().from(loyaltyTransactions).where(eq6(loyaltyTransactions.userId, userId)).$dynamic();
        if (type) {
          query = query.where(eq6(loyaltyTransactions.type, type));
        }
        query = query.orderBy(desc4(loyaltyTransactions.createdAt)).limit(limit).offset(offset);
        return await query;
      }
      /**
       * Get transaction summary (total earned, spent, expired)
       */
      async getTransactionSummary(userId) {
        const account = await this.getLoyaltyAccount(userId);
        if (!account) {
          return { totalEarned: 0, totalSpent: 0, totalExpired: 0, pointsExpiringIn30Days: 0 };
        }
        const thirtyDaysFromNow = /* @__PURE__ */ new Date();
        thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
        const expiringPoints = await db.select({
          total: sql5`COALESCE(SUM(${loyaltyTransactions.points}), 0)`
        }).from(loyaltyTransactions).where(
          and6(
            eq6(loyaltyTransactions.userId, userId),
            eq6(loyaltyTransactions.type, "earned"),
            eq6(loyaltyTransactions.isExpired, false),
            lte3(loyaltyTransactions.expiresAt, thirtyDaysFromNow),
            gte3(loyaltyTransactions.expiresAt, /* @__PURE__ */ new Date())
          )
        );
        return {
          totalEarned: account.lifetimePoints,
          totalSpent: account.lifetimePoints - account.currentPoints,
          totalExpired: 0,
          // Would need to track expired separately
          pointsExpiringIn30Days: Number(expiringPoints[0]?.total || 0)
        };
      }
      // ========================================
      // TIER MANAGEMENT
      // ========================================
      /**
       * Get all loyalty tiers
       */
      async getTiers() {
        return await db.select().from(loyaltyTiers).orderBy(loyaltyTiers.level);
      }
      /**
       * Get tier by ID
       */
      async getTierById(id) {
        const [tier] = await db.select().from(loyaltyTiers).where(eq6(loyaltyTiers.id, id)).limit(1);
        return tier || null;
      }
      /**
       * Check and upgrade user's tier based on lifetime points
       */
      async checkAndUpgradeTier(userId) {
        const account = await this.getLoyaltyAccount(userId);
        if (!account) return false;
        const tiers = await this.getTiers();
        let newTier = null;
        for (const tier of tiers.reverse()) {
          if (account.lifetimePoints >= tier.pointsRequired) {
            newTier = tier;
            break;
          }
        }
        if (newTier && newTier.level > account.tierLevel) {
          await db.update(loyaltyAccounts).set({
            tierId: newTier.id,
            tierName: newTier.name,
            tierLevel: newTier.level,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq6(loyaltyAccounts.id, account.id));
          return true;
        }
        return false;
      }
      /**
       * Get user's tier progress (points to next tier)
       */
      async getTierProgress(userId) {
        const account = await this.getLoyaltyAccount(userId);
        if (!account) {
          return {
            currentTier: null,
            nextTier: null,
            pointsToNextTier: 0,
            progressPercentage: 0
          };
        }
        const tiers = await this.getTiers();
        const currentTier = tiers.find((t) => t.level === account.tierLevel);
        const nextTier = tiers.find((t) => t.level === account.tierLevel + 1);
        if (!nextTier) {
          return {
            currentTier: currentTier || null,
            nextTier: null,
            pointsToNextTier: 0,
            progressPercentage: 100
          };
        }
        const pointsToNextTier = nextTier.pointsRequired - account.lifetimePoints;
        const pointsInCurrentTier = nextTier.pointsRequired - (currentTier?.pointsRequired || 0);
        const pointsEarned = account.lifetimePoints - (currentTier?.pointsRequired || 0);
        const progressPercentage = Math.min(100, pointsEarned / pointsInCurrentTier * 100);
        return {
          currentTier: currentTier || null,
          nextTier,
          pointsToNextTier: Math.max(0, pointsToNextTier),
          progressPercentage: Math.round(progressPercentage)
        };
      }
      // ========================================
      // POINTS CALCULATION (RULES ENGINE)
      // ========================================
      /**
       * Calculate points for a purchase
       */
      async calculatePointsForPurchase(userId, orderAmount) {
        const account = await this.getOrCreateLoyaltyAccount(userId);
        const [rule] = await db.select().from(loyaltyRules).where(
          and6(
            eq6(loyaltyRules.eventType, "purchase"),
            eq6(loyaltyRules.isActive, true)
          )
        ).limit(1);
        if (!rule) {
          return Math.floor(orderAmount);
        }
        let points = 0;
        if (rule.calculationType === "percentage" && rule.calculationValue) {
          points = Math.floor(orderAmount * (Number(rule.calculationValue) / 100));
        } else if (rule.calculationType === "fixed") {
          points = rule.pointsAwarded;
        } else {
          points = Math.floor(orderAmount);
        }
        const tierMultipliers = rule.tierMultipliers;
        if (tierMultipliers && account.tierName) {
          const multiplier = tierMultipliers[account.tierName] || 1;
          points = Math.floor(points * multiplier);
        }
        if (rule.maxPoints && points > rule.maxPoints) {
          points = rule.maxPoints;
        }
        return points;
      }
      /**
       * Award points for a specific event
       */
      async awardPointsForEvent(userId, eventType, sourceId) {
        const [rule] = await db.select().from(loyaltyRules).where(
          and6(
            eq6(loyaltyRules.eventType, eventType),
            eq6(loyaltyRules.isActive, true)
          )
        ).limit(1);
        if (!rule) {
          return null;
        }
        return await this.awardPoints(
          userId,
          rule.pointsAwarded,
          eventType,
          sourceId,
          rule.description || void 0
        );
      }
      // ========================================
      // REWARDS CATALOG
      // ========================================
      /**
       * Get rewards catalog
       */
      async getRewards(filters) {
        const {
          businessId,
          category,
          isActive = true,
          isFeatured,
          minTierLevel,
          limit = 50,
          offset = 0
        } = filters || {};
        let query = db.select().from(rewards).$dynamic();
        const conditions = [];
        if (isActive !== void 0) conditions.push(eq6(rewards.isActive, isActive));
        if (isFeatured !== void 0) conditions.push(eq6(rewards.isFeatured, isFeatured));
        if (businessId) conditions.push(eq6(rewards.businessId, businessId));
        if (category) conditions.push(eq6(rewards.category, category));
        if (minTierLevel !== void 0) {
          conditions.push(
            or4(
              isNull2(rewards.tierRestriction),
              lte3(rewards.tierRestriction, minTierLevel)
            )
          );
        }
        if (conditions.length > 0) {
          query = query.where(and6(...conditions));
        }
        query = query.orderBy(desc4(rewards.isFeatured), rewards.pointsCost).limit(limit).offset(offset);
        return await query;
      }
      /**
       * Get reward by ID
       */
      async getRewardById(id) {
        const [reward] = await db.select().from(rewards).where(eq6(rewards.id, id)).limit(1);
        return reward || null;
      }
      /**
       * Redeem a reward
       */
      async redeemReward(userId, rewardId) {
        const reward = await this.getRewardById(rewardId);
        if (!reward) {
          throw new Error("Reward not found");
        }
        if (!reward.isActive) {
          throw new Error("Reward is not active");
        }
        if (reward.stockQuantity !== null && reward.stockQuantity <= 0) {
          throw new Error("Reward is out of stock");
        }
        const account = await this.getLoyaltyAccount(userId);
        if (!account) {
          throw new Error("Loyalty account not found");
        }
        if (account.currentPoints < reward.pointsCost) {
          throw new Error("Insufficient points");
        }
        if (reward.tierRestriction && account.tierLevel < reward.tierRestriction) {
          throw new Error("Tier level too low for this reward");
        }
        if (reward.maxRedemptionsPerUser) {
          const redemptionCount = await db.select({ count: sql5`COUNT(*)` }).from(rewardRedemptions).where(
            and6(
              eq6(rewardRedemptions.userId, userId),
              eq6(rewardRedemptions.rewardId, rewardId)
            )
          );
          if (Number(redemptionCount[0].count) >= reward.maxRedemptionsPerUser) {
            throw new Error("Maximum redemptions per user reached");
          }
        }
        const transaction = await this.redeemPoints(
          userId,
          reward.pointsCost,
          "reward_redemption",
          rewardId,
          `Redeemed: ${reward.name}`
        );
        const redemptionCode = this.generateRedemptionCode();
        const expiresAt = /* @__PURE__ */ new Date();
        expiresAt.setDate(expiresAt.getDate() + 30);
        const [redemption] = await db.insert(rewardRedemptions).values({
          userId,
          rewardId,
          transactionId: transaction.id,
          pointsSpent: reward.pointsCost,
          status: "pending",
          redemptionCode,
          expiresAt
        }).returning();
        if (reward.stockQuantity !== null) {
          await db.update(rewards).set({
            stockQuantity: sql5`${rewards.stockQuantity} - 1`,
            redemptionCount: sql5`${rewards.redemptionCount} + 1`,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq6(rewards.id, rewardId));
        } else {
          await db.update(rewards).set({
            redemptionCount: sql5`${rewards.redemptionCount} + 1`,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq6(rewards.id, rewardId));
        }
        return redemption;
      }
      /**
       * Get user's redemptions
       */
      async getUserRedemptions(userId, filters) {
        const { status, limit = 50, offset = 0 } = filters || {};
        let query = db.select({
          redemption: rewardRedemptions,
          reward: rewards
        }).from(rewardRedemptions).leftJoin(rewards, eq6(rewardRedemptions.rewardId, rewards.id)).where(eq6(rewardRedemptions.userId, userId)).$dynamic();
        if (status) {
          query = query.where(eq6(rewardRedemptions.status, status));
        }
        query = query.orderBy(desc4(rewardRedemptions.redeemedAt)).limit(limit).offset(offset);
        return await query;
      }
      /**
       * Get redemption by code
       */
      async getRedemptionByCode(code) {
        const [result] = await db.select({
          redemption: rewardRedemptions,
          reward: rewards
        }).from(rewardRedemptions).leftJoin(rewards, eq6(rewardRedemptions.rewardId, rewards.id)).where(eq6(rewardRedemptions.redemptionCode, code)).limit(1);
        return result || null;
      }
      /**
       * Generate unique redemption code
       */
      generateRedemptionCode() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let code = "";
        for (let i = 0; i < 12; i++) {
          code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
      }
      // ========================================
      // REFERRAL SYSTEM
      // ========================================
      /**
       * Generate referral code for a user
       */
      async generateReferralCode(userId) {
        const [existing] = await db.select().from(referrals).where(eq6(referrals.referrerId, userId)).limit(1);
        if (existing) {
          return existing.referralCode;
        }
        const code = `REF${userId.substring(0, 4).toUpperCase()}${Math.random().toString(36).substring(2, 8).toUpperCase()}`;
        await db.insert(referrals).values({
          referrerId: userId,
          referralCode: code
        });
        return code;
      }
      /**
       * Get referral by code
       */
      async getReferralByCode(code) {
        const [referral] = await db.select().from(referrals).where(eq6(referrals.referralCode, code)).limit(1);
        return referral || null;
      }
      /**
       * Process referral signup (when referee signs up)
       */
      async processReferralSignup(referralCode, newUserId) {
        const referral = await this.getReferralByCode(referralCode);
        if (!referral) {
          throw new Error("Invalid referral code");
        }
        if (referral.refereeId) {
          throw new Error("Referral code already used");
        }
        await db.update(referrals).set({
          refereeId: newUserId,
          status: "signed_up",
          signedUpAt: /* @__PURE__ */ new Date()
        }).where(eq6(referrals.id, referral.id));
        await this.awardPointsForEvent(newUserId, "referral_signup", referral.id);
      }
      /**
       * Process referral completion (when referee makes first purchase)
       */
      async processReferralCompletion(refereeId) {
        const [referral] = await db.select().from(referrals).where(
          and6(
            eq6(referrals.refereeId, refereeId),
            eq6(referrals.status, "signed_up")
          )
        ).limit(1);
        if (!referral) {
          return;
        }
        await db.update(referrals).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date(),
          refereeFirstPurchaseAt: /* @__PURE__ */ new Date()
        }).where(eq6(referrals.id, referral.id));
        await this.awardPointsForEvent(
          referral.referrerId,
          "referral_complete",
          referral.id
        );
        await this.awardPointsForEvent(refereeId, "referral_complete", referral.id);
      }
      /**
       * Get referral statistics for a user
       */
      async getReferralStats(userId) {
        const allReferrals = await db.select().from(referrals).where(eq6(referrals.referrerId, userId));
        const stats = {
          totalReferrals: allReferrals.length,
          pendingReferrals: allReferrals.filter((r) => r.status === "pending").length,
          completedReferrals: allReferrals.filter((r) => r.status === "completed").length,
          totalPointsEarned: allReferrals.reduce(
            (sum2, r) => sum2 + r.referrerRewardPoints,
            0
          )
        };
        return stats;
      }
      /**
       * Get referral leaderboard (top referrers)
       */
      async getReferralLeaderboard(limit = 10) {
        const leaderboard = await db.select({
          userId: referrals.referrerId,
          completedReferrals: sql5`COUNT(*)`,
          totalPoints: sql5`SUM(${referrals.referrerRewardPoints})`
        }).from(referrals).where(eq6(referrals.status, "completed")).groupBy(referrals.referrerId).orderBy(desc4(sql5`COUNT(*)`)).limit(limit);
        const leaderboardWithUsers = await Promise.all(
          leaderboard.map(async (entry) => {
            const [user] = await db.select({
              id: users.id,
              firstName: users.firstName,
              lastName: users.lastName
            }).from(users).where(eq6(users.id, entry.userId)).limit(1);
            return {
              ...entry,
              user
            };
          })
        );
        return leaderboardWithUsers;
      }
      // ========================================
      // ADMIN METHODS
      // ========================================
      /**
       * Get all loyalty accounts (admin only)
       */
      async getAllAccounts(filters) {
        const { limit = 1e3, offset = 0 } = filters || {};
        return await db.select().from(loyaltyAccounts).orderBy(desc4(loyaltyAccounts.lifetimePoints)).limit(limit).offset(offset);
      }
      /**
       * Get all tiers (admin only)
       */
      async getAllTiers() {
        return await db.select().from(loyaltyTiers).orderBy(loyaltyTiers.level);
      }
      /**
       * Get all rewards (admin only)
       */
      async getAllRewards(filters) {
        const { limit = 100, offset = 0 } = filters || {};
        return await db.select().from(rewards).orderBy(desc4(rewards.createdAt)).limit(limit).offset(offset);
      }
      /**
       * Get recent redemptions (admin only)
       */
      async getRecentRedemptions(filters) {
        const { limit = 50, offset = 0 } = filters || {};
        return await db.select().from(rewardRedemptions).orderBy(desc4(rewardRedemptions.redeemedAt)).limit(limit).offset(offset);
      }
      /**
       * Get transaction history for a user
       */
      async getTransactionHistory(userId, filters) {
        const { limit = 10 } = filters || {};
        return await db.select().from(loyaltyTransactions).where(eq6(loyaltyTransactions.userId, userId)).orderBy(desc4(loyaltyTransactions.createdAt)).limit(limit);
      }
      /**
       * Get referrals made by a user
       */
      async getUserReferrals(userId) {
        return await db.select().from(referrals).where(eq6(referrals.referrerId, userId)).orderBy(desc4(referrals.createdAt));
      }
    };
    loyaltyStorage = new LoyaltyStorage();
  }
});

// server/emailService.ts
var emailService_exports = {};
__export(emailService_exports, {
  EmailService: () => EmailService,
  emailService: () => emailService
});
var EmailService, emailService;
var init_emailService = __esm({
  "server/emailService.ts"() {
    "use strict";
    EmailService = class {
      constructor() {
        this.baseUrl = process.env.APP_URL || "http://localhost:5000";
        if (process.env.MAILJET_API_KEY && process.env.MAILJET_SECRET_KEY) {
          this.provider = "mailjet";
          this.apiKey = process.env.MAILJET_API_KEY;
          this.apiSecret = process.env.MAILJET_SECRET_KEY;
          console.log("\u2705 Email provider: Mailjet");
        } else if (process.env.SENDGRID_API_KEY) {
          this.provider = "sendgrid";
          this.apiKey = process.env.SENDGRID_API_KEY;
          console.log("\u2705 Email provider: SendGrid");
        } else if (process.env.GMAIL_CLIENT_ID && process.env.GMAIL_CLIENT_SECRET && process.env.GMAIL_REFRESH_TOKEN) {
          this.provider = "gmail";
          this.gmailCredentials = {
            clientId: process.env.GMAIL_CLIENT_ID,
            clientSecret: process.env.GMAIL_CLIENT_SECRET,
            refreshToken: process.env.GMAIL_REFRESH_TOKEN,
            user: process.env.GMAIL_USER || "me"
          };
          console.log("\u2705 Email provider: Gmail (Google)");
        } else if (process.env.MAILGUN_API_KEY && process.env.MAILGUN_DOMAIN) {
          this.provider = "mailgun";
          this.apiKey = process.env.MAILGUN_API_KEY;
          this.domain = process.env.MAILGUN_DOMAIN;
          console.log("\u2705 Email provider: Mailgun");
        } else if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
          this.provider = "ses";
          this.apiKey = process.env.AWS_ACCESS_KEY_ID;
          console.log("\u2705 Email provider: AWS SES");
        } else {
          this.provider = "sendgrid";
          this.apiKey = "";
          console.warn("\u26A0\uFE0F  No email provider configured. Emails will be logged to console only.");
        }
      }
      /**
       * Send a single email
       */
      async sendEmail(options) {
        try {
          if (options.testMode) {
            console.log("\u{1F4E7} [TEST MODE] Email would be sent:", {
              to: options.to,
              subject: options.subject,
              from: options.from
            });
            return {
              success: true,
              messageId: `test-${Date.now()}`,
              recipientEmail: Array.isArray(options.to) ? options.to[0].email : options.to.email
            };
          }
          let html = options.html;
          const recipient = Array.isArray(options.to) ? options.to[0] : options.to;
          html = this.personalizeContent(html, recipient);
          if (options.trackOpens && options.recipientId) {
            html = this.addTrackingPixel(html, options.recipientId);
          }
          if (options.trackClicks && options.campaignId) {
            html = await this.wrapLinksForTracking(html, options.campaignId);
          }
          switch (this.provider) {
            case "mailjet":
              return await this.sendViaMailjet(options, html);
            case "sendgrid":
              return await this.sendViaSendGrid(options, html);
            case "gmail":
              return await this.sendViaGmail(options, html);
            case "mailgun":
              return await this.sendViaMailgun(options, html);
            case "ses":
              return await this.sendViaSES(options, html);
            default:
              throw new Error(`Unsupported email provider: ${this.provider}`);
          }
        } catch (error) {
          console.error("\u274C Email sending failed:", error);
          return {
            success: false,
            error: error.message || "Unknown error",
            recipientEmail: Array.isArray(options.to) ? options.to[0].email : options.to.email
          };
        }
      }
      /**
       * Send bulk emails (for campaigns)
       */
      async sendBulkEmails(emails) {
        const results = [];
        let totalSent = 0;
        let totalFailed = 0;
        const batchSize = 100;
        for (let i = 0; i < emails.length; i += batchSize) {
          const batch = emails.slice(i, i + batchSize);
          const batchResults = await Promise.all(
            batch.map((email) => this.sendEmail(email))
          );
          for (const result of batchResults) {
            results.push(result);
            if (result.success) {
              totalSent++;
            } else {
              totalFailed++;
            }
          }
          if (i + batchSize < emails.length) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
        return {
          totalSent,
          totalFailed,
          results
        };
      }
      /**
       * Add tracking pixel to HTML for open tracking
       */
      addTrackingPixel(html, recipientId) {
        const trackingPixel = `<img src="${this.baseUrl}/api/marketing/track/open/${recipientId}" width="1" height="1" alt="" style="display:block;border:0;outline:none;" />`;
        if (html.includes("</body>")) {
          return html.replace("</body>", `${trackingPixel}</body>`);
        }
        return html + trackingPixel;
      }
      /**
       * Wrap all links in HTML for click tracking
       *
       * Parses HTML and replaces all links with tracking URLs that redirect to original destination
       */
      async wrapLinksForTracking(html, campaignId) {
        const { MarketingStorage: MarketingStorage2 } = await Promise.resolve().then(() => (init_marketingStorage(), marketingStorage_exports));
        const storage2 = new MarketingStorage2();
        const linkRegex = /<a\s+(?:[^>]*?\s+)?href=(["'])((?:(?!\1).)*?)\1/gi;
        const matches = html.matchAll(linkRegex);
        const replacements = [];
        for (const match of matches) {
          const fullMatch = match[0];
          const originalUrl = match[2];
          if (originalUrl.includes("/api/marketing/track/") || originalUrl.startsWith("#") || originalUrl.startsWith("mailto:") || originalUrl.startsWith("tel:")) {
            continue;
          }
          const shortCode = this.generateShortCode();
          try {
            await storage2.createCampaignLink({
              campaignId,
              originalUrl,
              shortCode,
              clickCount: 0,
              uniqueClickCount: 0,
              createdAt: /* @__PURE__ */ new Date()
            });
            const trackingUrl = `${this.baseUrl}/api/marketing/track/click/${shortCode}`;
            const replacement = fullMatch.replace(originalUrl, trackingUrl);
            replacements.push({ original: fullMatch, replacement });
          } catch (error) {
            console.error(`Failed to create tracking link for ${originalUrl}:`, error);
          }
        }
        let trackedHtml = html;
        for (const { original, replacement } of replacements) {
          trackedHtml = trackedHtml.replace(original, replacement);
        }
        return trackedHtml;
      }
      /**
       * Generate a unique short code for link tracking
       */
      generateShortCode() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        let code = "";
        for (let i = 0; i < 8; i++) {
          code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
      }
      /**
       * Send email via Mailjet
       */
      async sendViaMailjet(options, html) {
        if (!this.apiKey || !this.apiSecret) {
          console.log("\u{1F4E7} [MAILJET MOCK] Email:", {
            to: options.to,
            from: options.from,
            subject: options.subject
          });
          return {
            success: true,
            messageId: `mailjet-mock-${Date.now()}`,
            recipientEmail: Array.isArray(options.to) ? options.to[0].email : options.to.email
          };
        }
        try {
          const Mailjet = (await import("node-mailjet")).default;
          const mailjet = new Mailjet({
            apiKey: this.apiKey,
            apiSecret: this.apiSecret
          });
          const recipient = Array.isArray(options.to) ? options.to[0] : options.to;
          const request = mailjet.post("send", { version: "v3.1" }).request({
            Messages: [
              {
                From: {
                  Email: options.from.email,
                  Name: options.from.name
                },
                To: [
                  {
                    Email: recipient.email,
                    Name: recipient.firstName ? `${recipient.firstName} ${recipient.lastName || ""}`.trim() : void 0
                  }
                ],
                Subject: options.subject,
                HTMLPart: html,
                TextPart: options.text || void 0,
                CustomID: options.recipientId || void 0
              }
            ]
          });
          const response = await request;
          const messageId = response.body.Messages[0].To[0].MessageID;
          return {
            success: true,
            messageId: messageId.toString(),
            recipientEmail: recipient.email
          };
        } catch (error) {
          console.error("Mailjet send error:", error);
          throw new Error(`Mailjet error: ${error.message}`);
        }
      }
      /**
       * Send email via Gmail (Google API)
       */
      async sendViaGmail(options, html) {
        if (!this.gmailCredentials) {
          console.log("\u{1F4E7} [GMAIL MOCK] Email:", {
            to: options.to,
            from: options.from,
            subject: options.subject
          });
          return {
            success: true,
            messageId: `gmail-mock-${Date.now()}`,
            recipientEmail: Array.isArray(options.to) ? options.to[0].email : options.to.email
          };
        }
        try {
          const { google } = await import("googleapis");
          const oauth2Client = new google.auth.OAuth2(
            this.gmailCredentials.clientId,
            this.gmailCredentials.clientSecret
          );
          oauth2Client.setCredentials({
            refresh_token: this.gmailCredentials.refreshToken
          });
          const gmail = google.gmail({ version: "v1", auth: oauth2Client });
          const recipient = Array.isArray(options.to) ? options.to[0] : options.to;
          const subject = options.subject;
          const utf8Subject = `=?utf-8?B?${Buffer.from(subject).toString("base64")}?=`;
          const messageParts = [
            `From: ${options.from.name} <${options.from.email}>`,
            `To: ${recipient.email}`,
            `Subject: ${utf8Subject}`,
            "MIME-Version: 1.0",
            "Content-Type: text/html; charset=utf-8",
            "",
            html
          ];
          const message = messageParts.join("\n");
          const encodedMessage = Buffer.from(message).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
          const response = await gmail.users.messages.send({
            userId: "me",
            requestBody: {
              raw: encodedMessage
            }
          });
          return {
            success: true,
            messageId: response.data.id || void 0,
            recipientEmail: recipient.email
          };
        } catch (error) {
          console.error("Gmail send error:", error);
          throw new Error(`Gmail error: ${error.message}`);
        }
      }
      /**
       * Send email via SendGrid
       */
      async sendViaSendGrid(options, html) {
        if (!this.apiKey) {
          console.log("\u{1F4E7} [SENDGRID MOCK] Email:", {
            to: options.to,
            from: options.from,
            subject: options.subject
          });
          return {
            success: true,
            messageId: `mock-${Date.now()}`,
            recipientEmail: Array.isArray(options.to) ? options.to[0].email : options.to.email
          };
        }
        try {
          const sgMail = (await import("@sendgrid/mail")).default;
          sgMail.setApiKey(this.apiKey);
          const recipient = Array.isArray(options.to) ? options.to[0] : options.to;
          const msg = {
            to: recipient.email,
            from: {
              email: options.from.email,
              name: options.from.name
            },
            subject: options.subject,
            html,
            text: options.text
          };
          const [response] = await sgMail.send(msg);
          return {
            success: true,
            messageId: response.headers["x-message-id"],
            recipientEmail: recipient.email
          };
        } catch (error) {
          console.error("SendGrid send error:", error);
          throw new Error(`SendGrid error: ${error.message}`);
        }
      }
      /**
       * Send email via Mailgun
       */
      async sendViaMailgun(options, html) {
        if (!this.apiKey || !this.domain) {
          console.log("\u{1F4E7} [MAILGUN MOCK] Email:", {
            to: options.to,
            from: options.from,
            subject: options.subject
          });
          return {
            success: true,
            messageId: `mailgun-mock-${Date.now()}`,
            recipientEmail: Array.isArray(options.to) ? options.to[0].email : options.to.email
          };
        }
        try {
          const formData = await import("form-data");
          const Mailgun = (await import("mailgun.js")).default;
          const mailgun = new Mailgun(formData.default);
          const mg = mailgun.client({
            username: "api",
            key: this.apiKey,
            url: "https://api.mailgun.net"
            // EU: 'https://api.eu.mailgun.net'
          });
          const recipient = Array.isArray(options.to) ? options.to[0] : options.to;
          const messageData = {
            from: `${options.from.name} <${options.from.email}>`,
            to: recipient.email,
            subject: options.subject,
            html,
            text: options.text,
            "h:Reply-To": options.replyTo,
            "v:recipient-id": options.recipientId,
            "v:campaign-id": options.campaignId
          };
          const response = await mg.messages.create(this.domain, messageData);
          return {
            success: true,
            messageId: response.id,
            recipientEmail: recipient.email
          };
        } catch (error) {
          console.error("Mailgun send error:", error);
          throw new Error(`Mailgun error: ${error.message}`);
        }
      }
      /**
       * Send email via AWS SES
       */
      async sendViaSES(options, html) {
        if (!this.apiKey) {
          console.log("\u{1F4E7} [AWS SES MOCK] Email:", {
            to: options.to,
            from: options.from,
            subject: options.subject
          });
          return {
            success: true,
            messageId: `ses-mock-${Date.now()}`,
            recipientEmail: Array.isArray(options.to) ? options.to[0].email : options.to.email
          };
        }
        try {
          const AWS = await import("aws-sdk");
          const ses = new AWS.SES({
            accessKeyId: process.env.AWS_ACCESS_KEY_ID,
            secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
            region: process.env.AWS_REGION || "us-east-1"
          });
          const recipient = Array.isArray(options.to) ? options.to[0] : options.to;
          const params = {
            Source: `${options.from.name} <${options.from.email}>`,
            Destination: {
              ToAddresses: [recipient.email]
            },
            Message: {
              Subject: {
                Data: options.subject,
                Charset: "UTF-8"
              },
              Body: {
                Html: {
                  Data: html,
                  Charset: "UTF-8"
                },
                Text: options.text ? {
                  Data: options.text,
                  Charset: "UTF-8"
                } : void 0
              }
            },
            ReplyToAddresses: options.replyTo ? [options.replyTo] : void 0
          };
          const response = await ses.sendEmail(params).promise();
          return {
            success: true,
            messageId: response.MessageId,
            recipientEmail: recipient.email
          };
        } catch (error) {
          console.error("AWS SES send error:", error);
          throw new Error(`AWS SES error: ${error.message}`);
        }
      }
      /**
       * Personalize email content with recipient data
       *
       * Replaces template variables like {{firstName}}, {{lastName}}, {{email}}
       */
      personalizeContent(html, recipient) {
        let personalizedHtml = html;
        const replacements = {
          "{{firstName}}": recipient.firstName || "",
          "{{first_name}}": recipient.firstName || "",
          "{{lastName}}": recipient.lastName || "",
          "{{last_name}}": recipient.lastName || "",
          "{{email}}": recipient.email || "",
          "{{fullName}}": [recipient.firstName, recipient.lastName].filter(Boolean).join(" ") || recipient.email,
          "{{full_name}}": [recipient.firstName, recipient.lastName].filter(Boolean).join(" ") || recipient.email
        };
        for (const [token, value] of Object.entries(replacements)) {
          const regex = new RegExp(token.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
          personalizedHtml = personalizedHtml.replace(regex, value);
        }
        const conditionalRegex = /\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/gi;
        personalizedHtml = personalizedHtml.replace(conditionalRegex, (match, field, content) => {
          if (field === "firstName" && recipient.firstName) {
            return content;
          } else if (field === "lastName" && recipient.lastName) {
            return content;
          }
          return "";
        });
        return personalizedHtml;
      }
      /**
       * Validate email address format
       */
      static isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }
      /**
       * Generate unsubscribe link
       */
      generateUnsubscribeLink(token) {
        return `${this.baseUrl}/unsubscribe?token=${token}`;
      }
      /**
       * Get provider info
       */
      getProviderInfo() {
        return {
          provider: this.provider,
          configured: !!this.apiKey
        };
      }
    };
    emailService = new EmailService();
  }
});

// server/marketingStorage.ts
var marketingStorage_exports = {};
__export(marketingStorage_exports, {
  MarketingStorage: () => MarketingStorage,
  marketingStorage: () => marketingStorage
});
import { eq as eq7, and as and7, or as or5, desc as desc5, sql as sql6, inArray as inArray4, gt, lt as lt2, gte as gte4, lte as lte4 } from "drizzle-orm";
var MarketingStorage, marketingStorage;
var init_marketingStorage = __esm({
  "server/marketingStorage.ts"() {
    "use strict";
    init_db();
    init_schema();
    MarketingStorage = class {
      // ========================================
      // MARKETING CAMPAIGNS
      // ========================================
      /**
       * Get all campaigns for a business
       */
      async getMarketingCampaigns(businessId, filters) {
        const {
          status,
          type,
          limit = 50,
          offset = 0
        } = filters || {};
        let query = db.select().from(marketingCampaigns).where(eq7(marketingCampaigns.businessId, businessId)).$dynamic();
        const conditions = [];
        if (status) conditions.push(eq7(marketingCampaigns.status, status));
        if (type) conditions.push(eq7(marketingCampaigns.type, type));
        if (conditions.length > 0) {
          query = query.where(and7(...conditions));
        }
        query = query.orderBy(desc5(marketingCampaigns.createdAt)).limit(limit).offset(offset);
        return await query;
      }
      /**
       * Get a single campaign by ID
       */
      async getMarketingCampaign(id) {
        const [campaign] = await db.select().from(marketingCampaigns).where(eq7(marketingCampaigns.id, id)).limit(1);
        return campaign || null;
      }
      /**
       * Create a new marketing campaign
       */
      async createMarketingCampaign(data) {
        const [campaign] = await db.insert(marketingCampaigns).values(data).returning();
        return campaign;
      }
      /**
       * Update a marketing campaign
       */
      async updateMarketingCampaign(id, data) {
        const [campaign] = await db.update(marketingCampaigns).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(marketingCampaigns.id, id)).returning();
        return campaign;
      }
      /**
       * Delete a marketing campaign
       */
      async deleteMarketingCampaign(id) {
        await db.delete(marketingCampaigns).where(eq7(marketingCampaigns.id, id));
      }
      /**
       * Mark campaign as sent
       */
      async markCampaignAsSent(id) {
        await db.update(marketingCampaigns).set({
          status: "active",
          sentAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(marketingCampaigns.id, id));
      }
      /**
       * Update campaign metrics
       */
      async updateCampaignMetrics(id, metrics) {
        const updates = { updatedAt: /* @__PURE__ */ new Date() };
        if (metrics.sentCount !== void 0) {
          updates.sentCount = sql6`${marketingCampaigns.sentCount} + ${metrics.sentCount}`;
        }
        if (metrics.deliveredCount !== void 0) {
          updates.deliveredCount = sql6`${marketingCampaigns.deliveredCount} + ${metrics.deliveredCount}`;
        }
        if (metrics.openedCount !== void 0) {
          updates.openedCount = sql6`${marketingCampaigns.openedCount} + ${metrics.openedCount}`;
        }
        if (metrics.clickedCount !== void 0) {
          updates.clickedCount = sql6`${marketingCampaigns.clickedCount} + ${metrics.clickedCount}`;
        }
        if (metrics.bouncedCount !== void 0) {
          updates.bouncedCount = sql6`${marketingCampaigns.bouncedCount} + ${metrics.bouncedCount}`;
        }
        if (metrics.unsubscribedCount !== void 0) {
          updates.unsubscribedCount = sql6`${marketingCampaigns.unsubscribedCount} + ${metrics.unsubscribedCount}`;
        }
        await db.update(marketingCampaigns).set(updates).where(eq7(marketingCampaigns.id, id));
        await this.recalculateCampaignRates(id);
      }
      /**
       * Recalculate campaign performance rates
       */
      async recalculateCampaignRates(id) {
        const [campaign] = await db.select().from(marketingCampaigns).where(eq7(marketingCampaigns.id, id)).limit(1);
        if (!campaign) return;
        const deliveryRate = campaign.sentCount > 0 ? campaign.deliveredCount / campaign.sentCount * 100 : 0;
        const openRate = campaign.deliveredCount > 0 ? campaign.openedCount / campaign.deliveredCount * 100 : 0;
        const clickRate = campaign.deliveredCount > 0 ? campaign.clickedCount / campaign.deliveredCount * 100 : 0;
        await db.update(marketingCampaigns).set({
          deliveryRate: deliveryRate.toFixed(2),
          openRate: openRate.toFixed(2),
          clickRate: clickRate.toFixed(2),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(marketingCampaigns.id, id));
      }
      // ========================================
      // CAMPAIGN RECIPIENTS
      // ========================================
      /**
       * Get all recipients for a campaign
       */
      async getCampaignRecipients(campaignId, filters) {
        const { status, limit = 100, offset = 0 } = filters || {};
        let query = db.select().from(campaignRecipients).where(eq7(campaignRecipients.campaignId, campaignId)).$dynamic();
        if (status) {
          query = query.where(eq7(campaignRecipients.status, status));
        }
        query = query.limit(limit).offset(offset);
        return await query;
      }
      /**
       * Create campaign recipients (bulk)
       */
      async createCampaignRecipients(recipients) {
        if (recipients.length === 0) return [];
        return await db.insert(campaignRecipients).values(recipients).returning();
      }
      /**
       * Update campaign recipient status
       */
      async updateCampaignRecipient(id, data) {
        const [recipient] = await db.update(campaignRecipients).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(campaignRecipients.id, id)).returning();
        return recipient;
      }
      /**
       * Track email open
       */
      async trackEmailOpen(recipientId) {
        const [recipient] = await db.select().from(campaignRecipients).where(eq7(campaignRecipients.id, recipientId)).limit(1);
        if (!recipient) return;
        await db.update(campaignRecipients).set({
          status: "opened",
          openCount: sql6`${campaignRecipients.openCount} + 1`,
          lastOpenedAt: /* @__PURE__ */ new Date(),
          openedAt: recipient.openedAt || /* @__PURE__ */ new Date(),
          // Only set first time
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(campaignRecipients.id, recipientId));
        if (!recipient.openedAt) {
          await this.updateCampaignMetrics(recipient.campaignId, { openedCount: 1 });
        }
      }
      // ========================================
      // CAMPAIGN LINKS & CLICKS
      // ========================================
      /**
       * Create a campaign link
       */
      async createCampaignLink(data) {
        const [link] = await db.insert(campaignLinks).values(data).returning();
        return link;
      }
      /**
       * Get campaign link by short code
       */
      async getCampaignLinkByShortCode(shortCode) {
        const [link] = await db.select().from(campaignLinks).where(eq7(campaignLinks.shortCode, shortCode)).limit(1);
        return link || null;
      }
      /**
       * Track link click
       */
      async trackLinkClick(data) {
        await db.insert(campaignClicks).values(data);
        await db.update(campaignLinks).set({
          clickCount: sql6`${campaignLinks.clickCount} + 1`
        }).where(eq7(campaignLinks.id, data.linkId));
        const [recipient] = await db.select().from(campaignRecipients).where(eq7(campaignRecipients.id, data.recipientId)).limit(1);
        if (recipient) {
          await db.update(campaignRecipients).set({
            status: "clicked",
            clickCount: sql6`${campaignRecipients.clickCount} + 1`,
            lastClickedAt: /* @__PURE__ */ new Date(),
            firstClickedAt: recipient.firstClickedAt || /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq7(campaignRecipients.id, data.recipientId));
          if (!recipient.firstClickedAt) {
            await this.updateCampaignMetrics(data.campaignId, { clickedCount: 1 });
          }
        }
      }
      /**
       * Get campaign analytics
       */
      async getCampaignAnalytics(campaignId) {
        const [campaign] = await db.select().from(marketingCampaigns).where(eq7(marketingCampaigns.id, campaignId)).limit(1);
        if (!campaign) return null;
        const links = await db.select().from(campaignLinks).where(eq7(campaignLinks.campaignId, campaignId)).orderBy(desc5(campaignLinks.clickCount));
        const clickData = await db.select({
          country: campaignClicks.country,
          city: campaignClicks.city,
          deviceType: campaignClicks.deviceType,
          browser: campaignClicks.browser
        }).from(campaignClicks).where(eq7(campaignClicks.campaignId, campaignId));
        const geographicData = {};
        const deviceBreakdown = { desktop: 0, mobile: 0, tablet: 0, unknown: 0 };
        const browserBreakdown = {};
        for (const click of clickData) {
          if (click.country) {
            geographicData[click.country] = (geographicData[click.country] || 0) + 1;
          }
          if (click.deviceType) {
            if (click.deviceType in deviceBreakdown) {
              deviceBreakdown[click.deviceType]++;
            } else {
              deviceBreakdown.unknown++;
            }
          }
          if (click.browser) {
            browserBreakdown[click.browser] = (browserBreakdown[click.browser] || 0) + 1;
          }
        }
        return {
          campaign,
          links: links.map((link) => ({
            url: link.originalUrl,
            clicks: link.clickCount,
            uniqueClicks: link.uniqueClickCount
          })),
          geographicData: Object.entries(geographicData).map(([country, count2]) => ({
            country,
            count: count2
          })),
          deviceBreakdown,
          browserBreakdown: Object.entries(browserBreakdown).map(([browser, count2]) => ({
            browser,
            count: count2
          }))
        };
      }
      // ========================================
      // CUSTOMER SEGMENTS
      // ========================================
      /**
       * Get all segments for a business
       */
      async getCustomerSegments(businessId) {
        return await db.select().from(customerSegments).where(and7(
          eq7(customerSegments.businessId, businessId),
          eq7(customerSegments.isActive, true)
        )).orderBy(desc5(customerSegments.createdAt));
      }
      /**
       * Get a single segment
       */
      async getCustomerSegment(id) {
        const [segment] = await db.select().from(customerSegments).where(eq7(customerSegments.id, id)).limit(1);
        return segment || null;
      }
      /**
       * Create a customer segment
       */
      async createCustomerSegment(data) {
        const [segment] = await db.insert(customerSegments).values(data).returning();
        return segment;
      }
      /**
       * Update a customer segment
       */
      async updateCustomerSegment(id, data) {
        const [segment] = await db.update(customerSegments).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(customerSegments.id, id)).returning();
        return segment;
      }
      /**
       * Delete a customer segment
       */
      async deleteCustomerSegment(id) {
        await db.delete(customerSegments).where(eq7(customerSegments.id, id));
      }
      /**
       * Calculate segment members based on criteria
       *
       * This evaluates the segment's criteria rules and returns matching user IDs
       */
      async calculateSegmentMembers(segmentId) {
        const segment = await this.getCustomerSegment(segmentId);
        if (!segment || !segment.criteria) return [];
        const criteria = segment.criteria;
        const rules = criteria.rules || [];
        const logic = criteria.logic || "AND";
        if (rules.length === 0) {
          return [];
        }
        try {
          const conditions = [];
          for (const rule of rules) {
            const { field, operator, value } = rule;
            const fieldMap = {
              "email": users.email,
              "firstName": users.firstName,
              "lastName": users.lastName,
              "phoneNumber": users.phoneNumber,
              "createdAt": users.createdAt,
              "lastActive": users.lastActive,
              "emailVerified": users.emailVerified,
              "role": users.role,
              "totalSpent": sql6`(SELECT COALESCE(SUM(amount), 0) FROM orders WHERE user_id = ${users.id})`,
              "orderCount": sql6`(SELECT COUNT(*) FROM orders WHERE user_id = ${users.id})`,
              "lastOrderDate": sql6`(SELECT MAX(created_at) FROM orders WHERE user_id = ${users.id})`
            };
            const column = fieldMap[field];
            if (!column) {
              console.warn(`Unknown field in segment rule: ${field}`);
              continue;
            }
            let condition;
            switch (operator) {
              case "equals":
              case "=":
                condition = eq7(column, value);
                break;
              case "not_equals":
              case "!=":
                condition = sql6`${column} != ${value}`;
                break;
              case "contains":
                condition = sql6`${column} LIKE ${"%" + value + "%"}`;
                break;
              case "not_contains":
                condition = sql6`${column} NOT LIKE ${"%" + value + "%"}`;
                break;
              case "starts_with":
                condition = sql6`${column} LIKE ${value + "%"}`;
                break;
              case "ends_with":
                condition = sql6`${column} LIKE ${"%" + value}`;
                break;
              case "greater_than":
              case ">":
                condition = gt(column, value);
                break;
              case "less_than":
              case "<":
                condition = lt2(column, value);
                break;
              case "greater_or_equal":
              case ">=":
                condition = gte4(column, value);
                break;
              case "less_or_equal":
              case "<=":
                condition = lte4(column, value);
                break;
              case "is_empty":
                condition = or5(eq7(column, ""), sql6`${column} IS NULL`);
                break;
              case "is_not_empty":
                condition = and7(sql6`${column} != ''`, sql6`${column} IS NOT NULL`);
                break;
              case "in":
                const values = Array.isArray(value) ? value : [value];
                condition = inArray4(column, values);
                break;
              case "not_in":
                const notValues = Array.isArray(value) ? value : [value];
                condition = sql6`${column} NOT IN (${sql6.join(notValues.map((v) => sql6`${v}`), sql6`, `)})`;
                break;
              default:
                console.warn(`Unknown operator in segment rule: ${operator}`);
                continue;
            }
            if (condition) {
              conditions.push(condition);
            }
          }
          if (conditions.length === 0) {
            return [];
          }
          const whereClause = logic === "OR" ? or5(...conditions) : and7(...conditions);
          const matchingUsers = await db.select({ id: users.id }).from(users).where(whereClause).limit(1e4);
          const userIds = matchingUsers.map((u) => u.id);
          console.log(`Calculated segment ${segmentId}: ${userIds.length} members found`);
          return userIds;
        } catch (error) {
          console.error(`Error calculating segment members for ${segmentId}:`, error);
          return [];
        }
      }
      /**
       * Add members to a segment
       */
      async addSegmentMembers(segmentId, userIds, source = "automatic") {
        const members = userIds.map((userId) => ({
          segmentId,
          userId,
          source
        }));
        try {
          await db.insert(segmentMembers).values(members);
          await db.update(customerSegments).set({
            memberCount: sql6`${customerSegments.memberCount} + ${userIds.length}`,
            lastCalculatedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq7(customerSegments.id, segmentId));
        } catch (error) {
          console.error("Error adding segment members:", error);
        }
      }
      /**
       * Get segment members
       */
      async getSegmentMembers(segmentId, limit = 100, offset = 0) {
        return await db.select({
          member: segmentMembers,
          user: {
            id: users.id,
            firstName: users.firstName,
            lastName: users.lastName,
            email: users.email,
            phoneNumber: users.phoneNumber
          }
        }).from(segmentMembers).leftJoin(users, eq7(segmentMembers.userId, users.id)).where(eq7(segmentMembers.segmentId, segmentId)).limit(limit).offset(offset);
      }
      // ========================================
      // MARKETING WORKFLOWS
      // ========================================
      /**
       * Get all workflows for a business
       */
      async getMarketingWorkflows(businessId) {
        return await db.select().from(marketingWorkflows).where(eq7(marketingWorkflows.businessId, businessId)).orderBy(desc5(marketingWorkflows.createdAt));
      }
      /**
       * Get a single workflow
       */
      async getMarketingWorkflow(id) {
        const [workflow] = await db.select().from(marketingWorkflows).where(eq7(marketingWorkflows.id, id)).limit(1);
        return workflow || null;
      }
      /**
       * Create a marketing workflow
       */
      async createMarketingWorkflow(data) {
        const [workflow] = await db.insert(marketingWorkflows).values(data).returning();
        return workflow;
      }
      /**
       * Update a marketing workflow
       */
      async updateMarketingWorkflow(id, data) {
        const [workflow] = await db.update(marketingWorkflows).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(marketingWorkflows.id, id)).returning();
        return workflow;
      }
      /**
       * Delete a marketing workflow
       */
      async deleteMarketingWorkflow(id) {
        await db.delete(marketingWorkflows).where(eq7(marketingWorkflows.id, id));
      }
      /**
       * Activate a workflow
       */
      async activateWorkflow(id) {
        await db.update(marketingWorkflows).set({
          status: "active",
          activatedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(marketingWorkflows.id, id));
      }
      /**
       * Pause a workflow
       */
      async pauseWorkflow(id) {
        await db.update(marketingWorkflows).set({
          status: "paused",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(marketingWorkflows.id, id));
      }
      /**
       * Enroll a user in a workflow
       */
      async enrollInWorkflow(data) {
        const [enrollment] = await db.insert(workflowEnrollments).values(data).returning();
        await db.update(marketingWorkflows).set({
          totalEnrolled: sql6`${marketingWorkflows.totalEnrolled} + 1`,
          activeEnrollments: sql6`${marketingWorkflows.activeEnrollments} + 1`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(marketingWorkflows.id, data.workflowId));
        return enrollment;
      }
      /**
       * Get workflow enrollments
       */
      async getWorkflowEnrollments(workflowId, filters) {
        const { status, limit = 100, offset = 0 } = filters || {};
        let query = db.select({
          enrollment: workflowEnrollments,
          user: {
            id: users.id,
            firstName: users.firstName,
            lastName: users.lastName,
            email: users.email
          }
        }).from(workflowEnrollments).leftJoin(users, eq7(workflowEnrollments.userId, users.id)).where(eq7(workflowEnrollments.workflowId, workflowId)).$dynamic();
        if (status) {
          query = query.where(eq7(workflowEnrollments.status, status));
        }
        query = query.orderBy(desc5(workflowEnrollments.enrolledAt)).limit(limit).offset(offset);
        return await query;
      }
      /**
       * Update workflow enrollment
       */
      async updateWorkflowEnrollment(id, data) {
        const [enrollment] = await db.update(workflowEnrollments).set(data).where(eq7(workflowEnrollments.id, id)).returning();
        return enrollment;
      }
      /**
       * Complete workflow enrollment
       */
      async completeWorkflowEnrollment(id) {
        const [enrollment] = await db.select().from(workflowEnrollments).where(eq7(workflowEnrollments.id, id)).limit(1);
        if (!enrollment) return;
        await db.update(workflowEnrollments).set({
          status: "completed",
          completedAt: /* @__PURE__ */ new Date()
        }).where(eq7(workflowEnrollments.id, id));
        await db.update(marketingWorkflows).set({
          activeEnrollments: sql6`${marketingWorkflows.activeEnrollments} - 1`,
          completedEnrollments: sql6`${marketingWorkflows.completedEnrollments} + 1`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(marketingWorkflows.id, enrollment.workflowId));
      }
      /**
       * Log workflow step execution
       */
      async logWorkflowStep(data) {
        const [log3] = await db.insert(workflowStepLogs).values(data).returning();
        return log3;
      }
      /**
       * Update workflow step log
       */
      async updateWorkflowStepLog(id, data) {
        await db.update(workflowStepLogs).set(data).where(eq7(workflowStepLogs.id, id));
      }
      /**
       * Get workflow step logs for an enrollment
       */
      async getWorkflowStepLogs(enrollmentId) {
        return await db.select().from(workflowStepLogs).where(eq7(workflowStepLogs.enrollmentId, enrollmentId)).orderBy(workflowStepLogs.startedAt);
      }
      // ========================================
      // LEAD CAPTURE FORMS
      // ========================================
      /**
       * Get all forms for a business
       */
      async getLeadCaptureForms(businessId) {
        return await db.select().from(leadCaptureForms).where(eq7(leadCaptureForms.businessId, businessId)).orderBy(desc5(leadCaptureForms.createdAt));
      }
      /**
       * Get a single form
       */
      async getLeadCaptureForm(id) {
        const [form] = await db.select().from(leadCaptureForms).where(eq7(leadCaptureForms.id, id)).limit(1);
        return form || null;
      }
      /**
       * Create a lead capture form
       */
      async createLeadCaptureForm(data) {
        const [form] = await db.insert(leadCaptureForms).values(data).returning();
        return form;
      }
      /**
       * Update a lead capture form
       */
      async updateLeadCaptureForm(id, data) {
        const [form] = await db.update(leadCaptureForms).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(leadCaptureForms.id, id)).returning();
        return form;
      }
      /**
       * Delete a lead capture form
       */
      async deleteLeadCaptureForm(id) {
        await db.delete(leadCaptureForms).where(eq7(leadCaptureForms.id, id));
      }
      /**
       * Submit a lead capture form
       */
      async submitLeadForm(data) {
        const [submission] = await db.insert(leadSubmissions).values(data).returning();
        await db.update(leadCaptureForms).set({
          submissionCount: sql6`${leadCaptureForms.submissionCount} + 1`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq7(leadCaptureForms.id, data.formId));
        return submission;
      }
      /**
       * Get lead submissions for a form
       */
      async getLeadSubmissions(formId, filters) {
        const { status, limit = 100, offset = 0 } = filters || {};
        let query = db.select().from(leadSubmissions).where(eq7(leadSubmissions.formId, formId)).$dynamic();
        if (status) {
          query = query.where(eq7(leadSubmissions.status, status));
        }
        query = query.orderBy(desc5(leadSubmissions.submittedAt)).limit(limit).offset(offset);
        return await query;
      }
      /**
       * Update lead submission status
       */
      async updateLeadSubmission(id, data) {
        const [submission] = await db.update(leadSubmissions).set(data).where(eq7(leadSubmissions.id, id)).returning();
        return submission;
      }
      // ========================================
      // ADMIN METHODS
      // ========================================
      /**
       * Get all campaigns across all businesses (admin only)
       */
      async getAllCampaigns(filters) {
        const { limit = 100, offset = 0 } = filters || {};
        return await db.select().from(marketingCampaigns).orderBy(desc5(marketingCampaigns.createdAt)).limit(limit).offset(offset);
      }
      /**
       * Get all segments across all businesses (admin only)
       */
      async getAllSegments(filters) {
        const { limit = 100, offset = 0 } = filters || {};
        return await db.select().from(customerSegments).orderBy(desc5(customerSegments.createdAt)).limit(limit).offset(offset);
      }
      // ========================================
      // SMS OPT-OUT TRACKING
      // ========================================
      /**
       * Check if phone number is opted out of SMS
       */
      async isSMSOptedOut(phoneNumber) {
        try {
          const [user] = await db.select().from(users).where(and7(
            eq7(users.phoneNumber, phoneNumber),
            eq7(users.smsOptOut, true)
          )).limit(1);
          return !!user;
        } catch (error) {
          console.error("Error checking SMS opt-out status:", error);
          return false;
        }
      }
      /**
       * Mark phone number as opted out of SMS
       */
      async markSMSOptedOut(phoneNumber) {
        try {
          await db.update(users).set({
            smsOptOut: true,
            smsOptOutDate: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq7(users.phoneNumber, phoneNumber));
          console.log(`\u{1F4F1} Marked ${phoneNumber} as opted out of SMS`);
          await db.update(campaignRecipients).set({
            status: "unsubscribed",
            unsubscribedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(and7(
            eq7(campaignRecipients.phone, phoneNumber),
            sql6`${campaignRecipients.status} != 'unsubscribed'`
          ));
        } catch (error) {
          console.error("Error marking SMS opt-out:", error);
        }
      }
      /**
       * Mark phone number as opted in to SMS (resubscribe)
       */
      async markSMSOptedIn(phoneNumber) {
        try {
          await db.update(users).set({
            smsOptOut: false,
            smsOptOutDate: null,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq7(users.phoneNumber, phoneNumber));
          console.log(`\u{1F4F1} Marked ${phoneNumber} as opted in to SMS`);
        } catch (error) {
          console.error("Error marking SMS opt-in:", error);
        }
      }
      /**
       * Get all opted-out phone numbers
       */
      async getOptedOutPhoneNumbers() {
        try {
          const optedOut = await db.select({ phoneNumber: users.phoneNumber }).from(users).where(and7(
            sql6`${users.phoneNumber} IS NOT NULL`,
            eq7(users.smsOptOut, true)
          ));
          return optedOut.map((u) => u.phoneNumber).filter(Boolean);
        } catch (error) {
          console.error("Error getting opted-out phone numbers:", error);
          return [];
        }
      }
      /**
       * Send email with tracking (integrates with email service)
       */
      async sendEmail(campaign, recipient) {
        try {
          const { emailService: emailService2 } = await Promise.resolve().then(() => (init_emailService(), emailService_exports));
          const emailOptions = {
            to: {
              email: recipient.email,
              firstName: recipient.firstName || void 0,
              lastName: recipient.lastName || void 0
            },
            from: {
              email: campaign.fromEmail || "noreply@example.com",
              name: campaign.fromName || "Marketing Team"
            },
            subject: campaign.subject || "Marketing Message",
            html: campaign.content || "",
            text: campaign.textContent || void 0,
            replyTo: campaign.replyTo || void 0,
            trackOpens: true,
            trackClicks: true,
            campaignId: campaign.id,
            recipientId: recipient.id,
            testMode: campaign.status === "draft"
          };
          const result = await emailService2.sendEmail(emailOptions);
          if (result.success) {
            await this.updateCampaignRecipient(recipient.id, {
              status: "sent",
              sentAt: /* @__PURE__ */ new Date(),
              messageId: result.messageId
            });
            await this.updateCampaignMetrics(campaign.id, { sentCount: 1 });
            return true;
          } else {
            await this.updateCampaignRecipient(recipient.id, {
              status: "failed",
              failedAt: /* @__PURE__ */ new Date(),
              failureReason: result.error
            });
            return false;
          }
        } catch (error) {
          console.error("Error sending email:", error);
          return false;
        }
      }
    };
    marketingStorage = new MarketingStorage();
  }
});

// server/openaiService.ts
import OpenAI2 from "openai";
import crypto4 from "crypto";
var DEFAULT_MODEL, MODEL_COSTS, OpenAIService, openAIService;
var init_openaiService = __esm({
  "server/openaiService.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    init_storage();
    DEFAULT_MODEL = "gpt-5";
    MODEL_COSTS = {
      "gpt-5": { input: 0.015, output: 0.075 },
      "gpt-4o": { input: 5e-3, output: 0.015 },
      "gpt-4o-mini": { input: 15e-5, output: 6e-4 },
      "gpt-3.5-turbo": { input: 5e-4, output: 15e-4 },
      "dall-e-3": { "1024x1024": 0.04, "1024x1792": 0.08, "1792x1024": 0.08 }
    };
    OpenAIService = class {
      constructor() {
        this.client = null;
        this.retryAttempts = 3;
        this.retryDelay = 1e3;
        this.cacheExpiry = 3600;
        // 1 hour
        this.isConfigured = false;
        if (!process.env.OPENAI_API_KEY) {
          logger.warn("\u26A0\uFE0F OpenAI API key not configured - AI features will be disabled");
          this.isConfigured = false;
          return;
        }
        this.client = new OpenAI2({
          apiKey: process.env.OPENAI_API_KEY
        });
        this.isConfigured = true;
        logger.info("\u2705 OpenAI Service initialized");
      }
      checkConfiguration() {
        if (!this.isConfigured || !this.client) {
          throw new Error("OpenAI API key not configured. Please add OPENAI_API_KEY to your environment variables.");
        }
      }
      /**
       * Generate content with advanced features
       */
      async generateContent(options) {
        this.checkConfiguration();
        const startTime = Date.now();
        const cacheKey = this.getCacheKey(options);
        if (options.useCache !== false) {
          const cached = await this.getCachedContent(cacheKey);
          if (cached) {
            logger.info("Content retrieved from cache", { cacheKey });
            return cached;
          }
        }
        try {
          const prompt = await this.buildPrompt(options);
          const model = this.selectModel(options);
          const response = await this.generateWithRetry(prompt, model, options);
          const processedContent = await this.processContent(response, options);
          const metadata = await this.calculateMetadata(processedContent, model, response);
          const qualityMetrics = await this.performQualityChecks(processedContent);
          const result = {
            id: crypto4.randomBytes(16).toString("hex"),
            content: processedContent,
            type: options.type,
            platform: options.platform,
            metadata: {
              ...metadata,
              generationTime: Date.now() - startTime
            },
            qualityMetrics,
            createdAt: /* @__PURE__ */ new Date()
          };
          if (options.useCache !== false) {
            await this.cacheContent(cacheKey, result);
          }
          await this.trackUsage(options.businessId || "system", metadata);
          logger.info("Content generated successfully", {
            type: options.type,
            platform: options.platform,
            tokensUsed: metadata.tokensUsed,
            cost: metadata.cost
          });
          return result;
        } catch (error) {
          logger.error("Content generation failed", { error, options });
          throw new Error(`Failed to generate content: ${error.message}`);
        }
      }
      /**
       * Build optimized prompt based on content type
       */
      async buildPrompt(options) {
        const business = options.businessId ? await storage.getBusinessById(options.businessId) : null;
        const basePrompts = {
          business_description: `Create a compelling business description that highlights unique value propositions, services/products offered, and target audience appeal. Include a clear call-to-action.`,
          product_description: `Write an engaging product description that emphasizes benefits over features, addresses customer pain points, and includes relevant keywords for SEO. Make it scannable with bullet points where appropriate.`,
          blog_post: `Write an informative and engaging blog post that provides value to readers, includes relevant examples, and maintains a consistent tone throughout. Structure with clear headings and subheadings.`,
          social_media: `Create an engaging social media post optimized for ${options.platform || "general"} that drives engagement, uses appropriate hashtags, and includes a clear call-to-action.`,
          email_template: `Design an effective email template with a compelling subject line, personalized greeting, clear value proposition, and strong call-to-action. Ensure mobile-friendly formatting.`,
          review_response: `Craft a professional and empathetic response to a customer review that acknowledges their feedback, addresses concerns if any, and maintains brand voice while showing genuine care for customer experience.`,
          faq: `Create comprehensive FAQ entries that anticipate customer questions, provide clear and concise answers, and reduce support burden while building trust.`,
          tagline: `Generate a memorable and impactful tagline that captures the essence of the brand, is easy to remember, and differentiates from competitors.`
        };
        let prompt = basePrompts[options.type] || "Generate professional content.";
        if (business) {
          prompt += `

Business Context:
- Name: ${business.name}
- Category: ${business.category}
- Description: ${business.description}
- Tagline: ${business.tagline}
- Location: ${business.location}`;
        }
        if (options.tone) {
          prompt += `

Tone: ${options.tone}`;
        }
        if (options.keywords && options.keywords.length > 0) {
          prompt += `

Include these keywords naturally: ${options.keywords.join(", ")}`;
        }
        if (options.platform) {
          const platformLimits = {
            twitter: 280,
            instagram: 2200,
            facebook: 63206,
            linkedin: 3e3,
            gmb: 1500
          };
          const limit = platformLimits[options.platform];
          if (limit) {
            prompt += `

Optimize for ${options.platform} (max ${limit} characters)`;
          }
        }
        if (options.language && options.language !== "en") {
          prompt += `

Generate content in ${options.language}`;
        }
        if (options.maxLength) {
          prompt += `

Maximum length: ${options.maxLength} characters`;
        }
        if (options.context) {
          prompt += `

Additional context: ${JSON.stringify(options.context)}`;
        }
        return prompt;
      }
      /**
       * Select optimal model based on task
       */
      selectModel(options) {
        if (options.type === "blog_post" || options.type === "email_template") {
          return DEFAULT_MODEL;
        }
        if (options.type === "tagline" || options.type === "review_response") {
          return "gpt-4o-mini";
        }
        return DEFAULT_MODEL;
      }
      /**
       * Generate content with retry logic
       */
      async generateWithRetry(prompt, model, options) {
        let lastError = null;
        for (let attempt = 0; attempt < this.retryAttempts; attempt++) {
          try {
            if (options.stream) {
              return await this.streamGeneration(prompt, model);
            }
            const response = await this.client.chat.completions.create({
              model,
              messages: [
                {
                  role: "system",
                  content: "You are a professional content creator specializing in business marketing and communication. Create high-quality, engaging content that drives results."
                },
                {
                  role: "user",
                  content: prompt
                }
              ],
              max_completion_tokens: options.maxLength ? Math.min(options.maxLength, 8192) : 2048,
              response_format: options.type === "faq" ? { type: "json_object" } : void 0
            });
            return response;
          } catch (error) {
            lastError = error;
            logger.warn(`Generation attempt ${attempt + 1} failed`, { error: lastError.message });
            if (attempt < this.retryAttempts - 1) {
              await new Promise(
                (resolve) => setTimeout(resolve, this.retryDelay * Math.pow(2, attempt))
              );
            }
          }
        }
        throw lastError || new Error("Failed to generate content after retries");
      }
      /**
       * Stream content generation for long-form content
       */
      async streamGeneration(prompt, model) {
        const stream = await this.client.chat.completions.create({
          model,
          messages: [
            {
              role: "system",
              content: "You are a professional content creator. Generate high-quality content."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          stream: true,
          max_completion_tokens: 8192
        });
        let fullContent = "";
        for await (const chunk of stream) {
          if (chunk.choices[0]?.delta?.content) {
            fullContent += chunk.choices[0].delta.content;
          }
        }
        return {
          choices: [{
            message: { content: fullContent }
          }],
          usage: {
            prompt_tokens: Math.ceil(prompt.length / 4),
            completion_tokens: Math.ceil(fullContent.length / 4),
            total_tokens: Math.ceil((prompt.length + fullContent.length) / 4)
          }
        };
      }
      /**
       * Process and enhance generated content
       */
      async processContent(response, options) {
        let content = response.choices[0].message.content;
        if (options.platform && ["instagram", "twitter", "linkedin"].includes(options.platform)) {
          content = await this.addHashtags(content, options.platform);
        }
        if (options.keywords && options.keywords.length > 0) {
          content = await this.optimizeForSEO(content, options.keywords);
        }
        if (options.platform) {
          content = this.formatForPlatform(content, options.platform);
        }
        return content;
      }
      /**
       * Add relevant hashtags
       */
      async addHashtags(content, platform) {
        const maxHashtags = platform === "instagram" ? 30 : 5;
        const keywords = content.match(/\b\w{4,}\b/g) || [];
        const uniqueKeywords = [...new Set(keywords.slice(0, maxHashtags))];
        const hashtags = uniqueKeywords.slice(0, Math.min(maxHashtags, 10)).map((word) => `#${word.toLowerCase()}`).join(" ");
        return `${content}

${hashtags}`;
      }
      /**
       * Optimize content for SEO
       */
      async optimizeForSEO(content, keywords) {
        let optimized = content;
        for (const keyword of keywords) {
          const regex = new RegExp(`\\b${keyword}\\b`, "gi");
          const matches = optimized.match(regex);
          if (!matches || matches.length < 2) {
            const sentences = optimized.split(". ");
            const midPoint = Math.floor(sentences.length / 2);
            sentences[midPoint] += ` featuring ${keyword}`;
            optimized = sentences.join(". ");
          }
        }
        return optimized;
      }
      /**
       * Format content for specific platform
       */
      formatForPlatform(content, platform) {
        const platformLimits = {
          twitter: 280,
          instagram: 2200,
          facebook: 63206,
          linkedin: 3e3,
          gmb: 1500
        };
        const limit = platformLimits[platform];
        if (limit && content.length > limit) {
          const truncated = content.substring(0, limit - 3);
          const lastPeriod = truncated.lastIndexOf(".");
          return lastPeriod > 0 ? truncated.substring(0, lastPeriod + 1) : truncated + "...";
        }
        return content;
      }
      /**
       * Calculate content metadata
       */
      async calculateMetadata(content, model, response) {
        const tokensUsed = response.usage?.total_tokens || 0;
        const modelCost = MODEL_COSTS[model] || MODEL_COSTS[DEFAULT_MODEL];
        const inputCost = (response.usage?.prompt_tokens || 0) / 1e3 * modelCost.input;
        const outputCost = (response.usage?.completion_tokens || 0) / 1e3 * modelCost.output;
        const totalCost = inputCost + outputCost;
        const words = content.split(/\s+/).length;
        const readingTime = Math.ceil(words / 200);
        const hashtags = content.match(/#\w+/g) || [];
        const seoScore = await this.calculateSEOScore(content);
        const sentimentScore = await this.analyzeSentiment(content);
        return {
          model,
          tokensUsed,
          cost: totalCost,
          characterCount: content.length,
          wordCount: words,
          readingTime,
          seoScore,
          sentimentScore,
          hashtags
        };
      }
      /**
       * Calculate SEO score
       */
      async calculateSEOScore(content) {
        let score = 50;
        if (content.includes("#") || content.includes("**")) score += 10;
        if (content.length > 300) score += 10;
        if (content.length > 600) score += 10;
        if (content.includes("\u2022") || content.includes("-") || content.includes("1.")) score += 5;
        if (content.includes("?")) score += 5;
        const ctaKeywords = ["contact", "visit", "learn more", "shop", "buy", "order"];
        if (ctaKeywords.some((keyword) => content.toLowerCase().includes(keyword))) score += 10;
        return Math.min(100, score);
      }
      /**
       * Analyze sentiment
       */
      async analyzeSentiment(content) {
        const positiveWords = ["great", "excellent", "amazing", "wonderful", "fantastic", "love", "best", "perfect", "beautiful", "outstanding"];
        const negativeWords = ["bad", "poor", "terrible", "awful", "horrible", "worst", "hate", "disappointing", "failed", "problem"];
        const lowerContent = content.toLowerCase();
        let score = 0;
        positiveWords.forEach((word) => {
          if (lowerContent.includes(word)) score += 0.1;
        });
        negativeWords.forEach((word) => {
          if (lowerContent.includes(word)) score -= 0.1;
        });
        return Math.max(0, Math.min(1, 0.5 + score));
      }
      /**
       * Perform quality checks
       */
      async performQualityChecks(content) {
        const clarity = this.calculateReadability(content);
        const engagement = this.calculateEngagement(content);
        const hasProfanity = await this.checkProfanity(content);
        const brandSafety = !hasProfanity && !this.containsSensitiveContent(content);
        return {
          clarity,
          engagement,
          brandSafety,
          hasProfanity
        };
      }
      /**
       * Calculate readability score
       */
      calculateReadability(content) {
        const sentences = content.split(/[.!?]+/).filter((s) => s.trim().length > 0);
        const words = content.split(/\s+/).filter((w) => w.length > 0);
        if (sentences.length === 0 || words.length === 0) return 0;
        const avgWordsPerSentence = words.length / sentences.length;
        if (avgWordsPerSentence < 10) return 0.9;
        if (avgWordsPerSentence < 15) return 0.8;
        if (avgWordsPerSentence < 20) return 0.7;
        if (avgWordsPerSentence < 25) return 0.6;
        return 0.5;
      }
      /**
       * Calculate engagement score
       */
      calculateEngagement(content) {
        let score = 0.5;
        if (content.includes("?")) score += 0.1;
        const ctaPatterns = ["click", "visit", "learn", "discover", "explore", "join", "sign up", "get started"];
        if (ctaPatterns.some((pattern) => content.toLowerCase().includes(pattern))) score += 0.15;
        const emotionalWords = ["amazing", "incredible", "exciting", "love", "passionate", "revolutionary"];
        if (emotionalWords.some((word) => content.toLowerCase().includes(word))) score += 0.1;
        if (content.includes("story") || content.includes("journey") || content.includes("experience")) score += 0.05;
        if (content.includes("\u2022") || content.includes("-") || /\d\./.test(content)) score += 0.1;
        return Math.min(1, score);
      }
      /**
       * Check for profanity
       */
      async checkProfanity(content) {
        const profanityList = ["damn", "hell"];
        const lowerContent = content.toLowerCase();
        return profanityList.some((word) => {
          const regex = new RegExp(`\\b${word}\\b`, "i");
          return regex.test(lowerContent);
        });
      }
      /**
       * Check for sensitive content
       */
      containsSensitiveContent(content) {
        const sensitiveTopics = ["politics", "religion", "violence", "adult", "gambling", "alcohol", "tobacco"];
        const lowerContent = content.toLowerCase();
        return sensitiveTopics.some((topic) => lowerContent.includes(topic));
      }
      /**
       * Generate cache key
       */
      getCacheKey(options) {
        const key = {
          type: options.type,
          platform: options.platform,
          tone: options.tone,
          keywords: options.keywords?.sort().join(","),
          language: options.language,
          businessId: options.businessId
        };
        return `content:${crypto4.createHash("md5").update(JSON.stringify(key)).digest("hex")}`;
      }
      /**
       * Get cached content
       */
      async getCachedContent(key) {
        try {
          const cached = await cache.get(key);
          if (cached) {
            return JSON.parse(cached);
          }
        } catch (error) {
          logger.error("Cache retrieval error", { error, key });
        }
        return null;
      }
      /**
       * Cache generated content
       */
      async cacheContent(key, content) {
        try {
          await cache.setex(key, this.cacheExpiry, JSON.stringify(content));
        } catch (error) {
          logger.error("Cache storage error", { error, key });
        }
      }
      /**
       * Track API usage for billing
       */
      async trackUsage(businessId, metadata) {
        try {
          await storage.trackAIUsage({
            businessId,
            service: "openai",
            model: metadata.model,
            tokensUsed: metadata.tokensUsed,
            cost: metadata.cost,
            type: "content_generation"
          });
        } catch (error) {
          logger.error("Failed to track usage", { error, businessId });
        }
      }
      /**
       * Generate content templates
       */
      async getContentTemplates(category) {
        const templates = [
          {
            id: "biz-desc-1",
            name: "Professional Business Description",
            description: "Create a compelling business overview",
            type: "business_description",
            category: "business",
            prompt: "Write a professional business description for {businessName} that operates in {industry}. Highlight {uniqueValue} and appeal to {targetAudience}.",
            variables: ["businessName", "industry", "uniqueValue", "targetAudience"],
            tone: "professional",
            isActive: true
          },
          {
            id: "prod-desc-1",
            name: "Product Launch Description",
            description: "Perfect for introducing new products",
            type: "product_description",
            category: "product",
            prompt: "Create an exciting product description for {productName}. Emphasize {keyFeatures} and how it solves {customerProblem}. Include benefits for {targetCustomer}.",
            variables: ["productName", "keyFeatures", "customerProblem", "targetCustomer"],
            tone: "casual",
            isActive: true
          },
          {
            id: "social-1",
            name: "Instagram Product Showcase",
            description: "Eye-catching Instagram post for products",
            type: "social_media",
            category: "social",
            prompt: "Create an Instagram post showcasing {product}. Include 3 key benefits, use emojis, and add 10 relevant hashtags. Make it visually descriptive.",
            variables: ["product"],
            tone: "friendly",
            isActive: true
          },
          {
            id: "email-1",
            name: "Welcome Email Series",
            description: "Onboard new customers effectively",
            type: "email_template",
            category: "email",
            prompt: "Write a welcome email for new customers of {businessName}. Thank them for joining, highlight {topBenefits}, and include a {specialOffer}.",
            variables: ["businessName", "topBenefits", "specialOffer"],
            tone: "friendly",
            isActive: true
          },
          {
            id: "review-1",
            name: "Positive Review Response",
            description: "Thank customers for positive feedback",
            type: "review_response",
            category: "customer_service",
            prompt: "Respond to a positive review for {businessName}. Thank the customer {customerName}, mention {specificDetail} they liked, and invite them back.",
            variables: ["businessName", "customerName", "specificDetail"],
            tone: "friendly",
            isActive: true
          },
          {
            id: "blog-1",
            name: "How-To Guide Blog Post",
            description: "Educational content that provides value",
            type: "blog_post",
            category: "blog",
            prompt: "Write a how-to guide about {topic} for {targetAudience}. Include {numberOfSteps} clear steps, practical examples, and expert tips.",
            variables: ["topic", "targetAudience", "numberOfSteps"],
            tone: "professional",
            isActive: true
          }
        ];
        if (category) {
          return templates.filter((t) => t.category === category);
        }
        return templates;
      }
      /**
       * Generate content from template
       */
      async generateFromTemplate(templateId, variables, options) {
        const templates = await this.getContentTemplates();
        const template = templates.find((t) => t.id === templateId);
        if (!template) {
          throw new Error(`Template ${templateId} not found`);
        }
        let prompt = template.prompt;
        for (const [key, value] of Object.entries(variables)) {
          prompt = prompt.replace(new RegExp(`{${key}}`, "g"), value);
        }
        return this.generateContent({
          type: template.type,
          tone: template.tone,
          useCache: true,
          ...options,
          context: { prompt, template: template.name }
        });
      }
      /**
       * Batch content generation
       */
      async generateBatch(requests) {
        const results = [];
        const concurrency = 3;
        for (let i = 0; i < requests.length; i += concurrency) {
          const batch = requests.slice(i, i + concurrency);
          const batchResults = await Promise.all(
            batch.map((req) => this.generateContent(req))
          );
          results.push(...batchResults);
        }
        return results;
      }
      /**
       * Moderate content for safety and compliance
       */
      async moderateContent(content) {
        this.checkConfiguration();
        try {
          const response = await this.client.moderations.create({
            input: content
          });
          return response.results[0];
        } catch (error) {
          logger.error("Content moderation failed", { error });
          throw error;
        }
      }
    };
    openAIService = new OpenAIService();
  }
});

// server/imageGeneration.ts
import OpenAI3 from "openai";
import sharp from "sharp";
import crypto5 from "crypto";
import path2 from "path";
import fs2 from "fs/promises";
var DALL_E_MODEL, IMAGE_COSTS, ImageGenerationService, imageGenerationService;
var init_imageGeneration = __esm({
  "server/imageGeneration.ts"() {
    "use strict";
    init_monitoring();
    init_redis();
    init_storage();
    init_objectStorage();
    DALL_E_MODEL = "dall-e-3";
    IMAGE_COSTS = {
      "1024x1024": 0.04,
      "1024x1792": 0.08,
      "1792x1024": 0.08
    };
    ImageGenerationService = class {
      constructor() {
        this.client = null;
        this.storageService = null;
        this.localStoragePath = path2.join(process.cwd(), "attached_assets", "generated_images");
        this.cacheExpiry = 86400;
        // 24 hours
        this.isConfigured = false;
        if (!process.env.OPENAI_API_KEY) {
          logger.warn("\u26A0\uFE0F OpenAI API key not configured - Image generation features will be disabled");
          this.isConfigured = false;
          return;
        }
        this.client = new OpenAI3({
          apiKey: process.env.OPENAI_API_KEY
        });
        this.isConfigured = true;
        this.initializeStorage();
        this.ensureLocalStorage();
        logger.info("\u2705 Image Generation Service initialized");
      }
      checkConfiguration() {
        if (!this.isConfigured || !this.client) {
          throw new Error("OpenAI API key not configured. Please add OPENAI_API_KEY to your environment variables.");
        }
      }
      /**
       * Initialize storage service (S3 or Object Storage)
       */
      async initializeStorage() {
        try {
          if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
            this.storageService = new S3Service();
            logger.info("Using S3 for image storage");
          } else if (process.env.PUBLIC_OBJECT_SEARCH_PATHS) {
            this.storageService = new ObjectStorageService();
            logger.info("Using Object Storage for images");
          }
        } catch (error) {
          logger.warn("No cloud storage configured, using local storage only");
        }
      }
      /**
       * Ensure local storage directory exists
       */
      async ensureLocalStorage() {
        try {
          await fs2.mkdir(this.localStoragePath, { recursive: true });
        } catch (error) {
          logger.error("Failed to create local storage directory", { error });
        }
      }
      /**
       * Generate image with DALL-E 3
       */
      async generateImage(options) {
        this.checkConfiguration();
        const startTime = Date.now();
        const cacheKey = this.getCacheKey(options);
        if (options.useCache !== false) {
          const cached = await this.getCachedImage(cacheKey);
          if (cached) {
            logger.info("Image retrieved from cache", { cacheKey });
            return cached;
          }
        }
        try {
          const finalPrompt = options.enhancePrompt ? await this.enhancePrompt(options.prompt, options) : options.prompt;
          const promptWithNegative = options.negativePrompt ? `${finalPrompt}. Avoid: ${options.negativePrompt}` : finalPrompt;
          const response = await this.client.images.generate({
            model: DALL_E_MODEL,
            prompt: promptWithNegative,
            n: 1,
            // DALL-E 3 only supports n=1
            size: options.size || "1024x1024",
            style: options.style || "vivid",
            quality: options.quality || "standard"
          });
          const imageUrl = response.data[0].url;
          const revisedPrompt = response.data[0].revised_prompt;
          if (!imageUrl) {
            throw new Error("No image URL returned from API");
          }
          const savedImage = await this.saveImage(imageUrl, options);
          const cost = IMAGE_COSTS[options.size || "1024x1024"];
          const dimensions = this.getDimensions(options.size || "1024x1024");
          const result = {
            id: crypto5.randomBytes(16).toString("hex"),
            url: imageUrl,
            localPath: savedImage.localPath,
            s3Url: savedImage.s3Url,
            prompt: options.prompt,
            enhancedPrompt: revisedPrompt || finalPrompt,
            metadata: {
              size: options.size || "1024x1024",
              style: options.style || "vivid",
              quality: options.quality || "standard",
              model: DALL_E_MODEL,
              cost,
              generationTime: Date.now() - startTime,
              fileSize: savedImage.fileSize,
              format: "png",
              dimensions
            },
            category: options.category,
            businessId: options.businessId,
            tags: this.extractTags(options.prompt),
            createdAt: /* @__PURE__ */ new Date()
          };
          if (options.useCache !== false) {
            await this.cacheImage(cacheKey, result);
          }
          await this.trackUsage(options.businessId || "system", result);
          await this.storeImageRecord(result);
          logger.info("Image generated successfully", {
            id: result.id,
            cost,
            generationTime: result.metadata.generationTime
          });
          if (options.variations && options.numberOfImages && options.numberOfImages > 1) {
            const variations = await this.generateVariations(
              options,
              options.numberOfImages - 1
            );
          }
          return result;
        } catch (error) {
          logger.error("Image generation failed", { error, options });
          throw new Error(`Failed to generate image: ${error.message}`);
        }
      }
      /**
       * Enhance prompt for better results
       */
      async enhancePrompt(prompt, options) {
        const categoryEnhancements = {
          product: "professional product photography, studio lighting, high quality, commercial, clean background",
          logo: "minimalist logo design, vector style, scalable, memorable, professional branding",
          social: "eye-catching social media graphic, engaging, shareable, modern design",
          banner: "website banner, hero image, high resolution, impactful, professional",
          background: "seamless pattern, website background, subtle, elegant, professional",
          marketing: "marketing material, promotional, attention-grabbing, call-to-action, professional design"
        };
        const styleEnhancements = {
          vivid: "vibrant colors, high contrast, dynamic, bold",
          natural: "realistic, photorealistic, natural lighting, authentic"
        };
        let enhanced = prompt;
        if (options.category && categoryEnhancements[options.category]) {
          enhanced += `, ${categoryEnhancements[options.category]}`;
        }
        if (options.style && styleEnhancements[options.style]) {
          enhanced += `, ${styleEnhancements[options.style]}`;
        }
        if (options.quality === "hd") {
          enhanced += ", ultra HD, 4K quality, highly detailed, sharp focus";
        }
        enhanced += ", professional photography, commercial use, high resolution";
        return enhanced;
      }
      /**
       * Save image locally and to cloud storage
       */
      async saveImage(imageUrl, options) {
        try {
          const response = await fetch(imageUrl);
          const buffer = Buffer.from(await response.arrayBuffer());
          const timestamp2 = Date.now();
          const hash = crypto5.randomBytes(8).toString("hex");
          const category = options.category || "general";
          const filename = `${category}_${timestamp2}_${hash}.png`;
          const localPath = path2.join(this.localStoragePath, filename);
          await fs2.writeFile(localPath, buffer);
          const optimizedBuffer = await this.optimizeImage(buffer, options);
          const optimizedPath = localPath.replace(".png", "_optimized.png");
          await fs2.writeFile(optimizedPath, optimizedBuffer);
          let s3Url;
          if (this.storageService) {
            const s3Key = `generated-images/${options.businessId || "system"}/${filename}`;
            s3Url = await this.storageService.uploadFile(optimizedBuffer, s3Key, "image/png");
          }
          return {
            localPath: `attached_assets/generated_images/${filename}`,
            s3Url,
            fileSize: optimizedBuffer.length
          };
        } catch (error) {
          logger.error("Failed to save image", { error });
          throw new Error("Failed to save generated image");
        }
      }
      /**
       * Optimize image for web use
       */
      async optimizeImage(buffer, options) {
        try {
          let pipeline = sharp(buffer);
          if (options.category === "social") {
            pipeline = pipeline.jpeg({ quality: 85, progressive: true }).resize(1200, 630, { fit: "cover" });
          } else if (options.category === "product") {
            pipeline = pipeline.png({ compressionLevel: 9 }).resize(1500, 1500, { fit: "inside", withoutEnlargement: true });
          } else if (options.category === "logo") {
            pipeline = pipeline.png({ compressionLevel: 9 }).resize(500, 500, { fit: "inside", withoutEnlargement: true });
          } else {
            pipeline = pipeline.jpeg({ quality: 90, progressive: true });
          }
          return await pipeline.toBuffer();
        } catch (error) {
          logger.error("Image optimization failed", { error });
          return buffer;
        }
      }
      /**
       * Generate multiple variations
       */
      async generateVariations(baseOptions, count2) {
        const variations = [];
        const variationPrompts = this.createVariationPrompts(baseOptions.prompt, count2);
        for (const varPrompt of variationPrompts) {
          try {
            const variation = await this.generateImage({
              ...baseOptions,
              prompt: varPrompt,
              variations: false
              // Prevent recursive variations
            });
            variations.push(variation);
          } catch (error) {
            logger.error("Failed to generate variation", { error });
          }
        }
        return variations;
      }
      /**
       * Create variation prompts
       */
      createVariationPrompts(basePrompt, count2) {
        const modifiers = [
          "different angle",
          "alternative style",
          "varied composition",
          "unique perspective",
          "creative interpretation",
          "fresh approach",
          "innovative design",
          "distinctive look"
        ];
        const prompts = [];
        for (let i = 0; i < count2 && i < modifiers.length; i++) {
          prompts.push(`${basePrompt}, ${modifiers[i]}`);
        }
        return prompts;
      }
      /**
       * Get image dimensions from size string
       */
      getDimensions(size) {
        const [width, height] = size.split("x").map(Number);
        return { width, height };
      }
      /**
       * Extract tags from prompt
       */
      extractTags(prompt) {
        const words = prompt.toLowerCase().split(/\s+/);
        const stopWords = ["the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by"];
        return words.filter((word) => word.length > 3 && !stopWords.includes(word)).slice(0, 10);
      }
      /**
       * Generate cache key
       */
      getCacheKey(options) {
        const key = {
          prompt: options.prompt,
          size: options.size,
          style: options.style,
          quality: options.quality,
          category: options.category
        };
        return `image:${crypto5.createHash("md5").update(JSON.stringify(key)).digest("hex")}`;
      }
      /**
       * Get cached image
       */
      async getCachedImage(key) {
        try {
          const cached = await cache.get(key);
          if (cached) {
            return JSON.parse(cached);
          }
        } catch (error) {
          logger.error("Cache retrieval error", { error, key });
        }
        return null;
      }
      /**
       * Cache generated image
       */
      async cacheImage(key, image) {
        try {
          await cache.setex(key, this.cacheExpiry, JSON.stringify(image));
        } catch (error) {
          logger.error("Cache storage error", { error, key });
        }
      }
      /**
       * Track image generation usage
       */
      async trackUsage(businessId, image) {
        try {
          await storage.trackAIUsage({
            businessId,
            service: "openai",
            model: DALL_E_MODEL,
            tokensUsed: 0,
            // Images don't use tokens
            cost: image.metadata.cost,
            type: "image_generation",
            metadata: {
              size: image.metadata.size,
              quality: image.metadata.quality,
              category: image.category
            }
          });
        } catch (error) {
          logger.error("Failed to track usage", { error, businessId });
        }
      }
      /**
       * Store image record in database
       */
      async storeImageRecord(image) {
        try {
          await storage.createGeneratedImage({
            id: image.id,
            businessId: image.businessId,
            prompt: image.prompt,
            enhancedPrompt: image.enhancedPrompt,
            url: image.url,
            localPath: image.localPath,
            s3Url: image.s3Url,
            metadata: image.metadata,
            category: image.category,
            tags: image.tags
          });
        } catch (error) {
          logger.error("Failed to store image record", { error });
        }
      }
      /**
       * Get image templates
       */
      async getImageTemplates(category) {
        const templates = [
          {
            id: "product-hero",
            name: "Product Hero Shot",
            description: "Professional product photography for e-commerce",
            category: "product",
            basePrompt: "professional product photography of {product}, white background, studio lighting, commercial quality, centered composition",
            styleModifiers: ["minimal shadows", "high key lighting", "clean aesthetic"],
            defaultSize: "1024x1024"
          },
          {
            id: "product-lifestyle",
            name: "Product Lifestyle",
            description: "Product in real-world setting",
            category: "product",
            basePrompt: "{product} in use, lifestyle photography, natural setting, warm lighting, authentic feel",
            styleModifiers: ["bokeh background", "golden hour", "candid style"],
            defaultSize: "1792x1024"
          },
          {
            id: "logo-minimal",
            name: "Minimalist Logo",
            description: "Clean, modern logo design",
            category: "logo",
            basePrompt: "minimalist logo for {businessName}, simple geometric shapes, vector style, scalable design, {primaryColor} color scheme",
            styleModifiers: ["flat design", "negative space", "timeless"],
            defaultSize: "1024x1024"
          },
          {
            id: "social-announcement",
            name: "Social Media Announcement",
            description: "Eye-catching social media post",
            category: "social",
            basePrompt: "social media graphic announcing {announcement}, bold typography, {brandColors}, modern design, Instagram-ready",
            styleModifiers: ["gradient background", "trendy", "shareable"],
            defaultSize: "1024x1024"
          },
          {
            id: "banner-hero",
            name: "Website Hero Banner",
            description: "Impactful website header image",
            category: "banner",
            basePrompt: "website hero banner for {businessType}, professional, {mood} atmosphere, high resolution, panoramic view",
            styleModifiers: ["cinematic", "depth of field", "dramatic lighting"],
            defaultSize: "1792x1024"
          },
          {
            id: "marketing-flyer",
            name: "Marketing Flyer",
            description: "Professional marketing material",
            category: "marketing",
            basePrompt: "marketing flyer design for {offer}, professional layout, clear hierarchy, {brandColors}, call-to-action prominent",
            styleModifiers: ["corporate style", "clean layout", "print-ready"],
            defaultSize: "1024x1792"
          }
        ];
        if (category) {
          return templates.filter((t) => t.category === category);
        }
        return templates;
      }
      /**
       * Generate from template
       */
      async generateFromTemplate(templateId, variables, options) {
        const templates = await this.getImageTemplates();
        const template = templates.find((t) => t.id === templateId);
        if (!template) {
          throw new Error(`Template ${templateId} not found`);
        }
        let prompt = template.basePrompt;
        for (const [key, value] of Object.entries(variables)) {
          prompt = prompt.replace(new RegExp(`{${key}}`, "g"), value);
        }
        if (template.styleModifiers.length > 0) {
          prompt += `, ${template.styleModifiers.join(", ")}`;
        }
        return this.generateImage({
          prompt,
          size: template.defaultSize,
          category: template.category,
          enhancePrompt: true,
          ...options
        });
      }
      /**
       * Batch image generation
       */
      async generateBatch(requests) {
        const results = [];
        for (const request of requests) {
          try {
            const image = await this.generateImage(request);
            results.push(image);
            await new Promise((resolve) => setTimeout(resolve, 2e3));
          } catch (error) {
            logger.error("Batch generation error", { error, request });
          }
        }
        return results;
      }
      /**
       * Get image history
       */
      async getImageHistory(businessId, options) {
        try {
          return await storage.getGeneratedImages(businessId, options);
        } catch (error) {
          logger.error("Failed to get image history", { error });
          return [];
        }
      }
      /**
       * Delete generated image
       */
      async deleteImage(imageId, businessId) {
        try {
          const image = await storage.getGeneratedImage(imageId);
          if (!image || image.businessId !== businessId) {
            throw new Error("Image not found or unauthorized");
          }
          if (image.localPath) {
            const fullPath = path2.join(process.cwd(), image.localPath);
            await fs2.unlink(fullPath).catch(() => {
            });
          }
          if (image.s3Url && this.storageService) {
            await this.storageService.deleteFile(image.s3Url);
          }
          await storage.deleteGeneratedImage(imageId);
          logger.info("Image deleted", { imageId, businessId });
        } catch (error) {
          logger.error("Failed to delete image", { error, imageId });
          throw error;
        }
      }
    };
    imageGenerationService = new ImageGenerationService();
  }
});

// server/aiContentRoutes.ts
var aiContentRoutes_exports = {};
__export(aiContentRoutes_exports, {
  aiContentRoutes: () => router3
});
import { Router as Router3 } from "express";
import { z } from "zod";
var router3;
var init_aiContentRoutes = __esm({
  "server/aiContentRoutes.ts"() {
    "use strict";
    init_auth();
    init_rateLimit();
    init_openaiService();
    init_imageGeneration();
    init_storage();
    init_monitoring();
    router3 = Router3();
    router3.post(
      "/content/generate",
      isAuthenticated,
      generalAPIRateLimit,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid().optional(),
            type: z.enum([
              "business_description",
              "product_description",
              "blog_post",
              "social_media",
              "email_template",
              "review_response",
              "faq",
              "tagline"
            ]),
            platform: z.enum([
              "facebook",
              "instagram",
              "twitter",
              "linkedin",
              "gmb",
              "email",
              "general"
            ]).optional(),
            content: z.string().min(1).max(1e4),
            // Input context/idea
            tone: z.enum([
              "professional",
              "casual",
              "friendly",
              "formal",
              "humorous",
              "inspirational"
            ]).optional(),
            language: z.string().optional().default("en"),
            keywords: z.array(z.string()).optional(),
            maxLength: z.number().optional(),
            useCache: z.boolean().optional().default(true),
            stream: z.boolean().optional().default(false),
            saveToHistory: z.boolean().optional().default(true)
          });
          const data = schema.parse(req.body);
          const userId = req.user?.id;
          const result = await openAIService.generateContent({
            businessId: data.businessId,
            type: data.type,
            platform: data.platform,
            tone: data.tone,
            language: data.language,
            keywords: data.keywords,
            maxLength: data.maxLength,
            context: { userInput: data.content },
            useCache: data.useCache,
            stream: data.stream
          });
          if (data.saveToHistory && data.businessId) {
            await storage.createGeneratedContent({
              businessId: data.businessId,
              userId,
              type: data.type,
              platform: data.platform || "general",
              content: result.content,
              prompt: data.content,
              enhancedPrompt: result.metadata.model,
              tone: data.tone,
              language: data.language,
              keywords: data.keywords,
              hashtags: result.metadata.hashtags,
              metadata: result.metadata,
              qualityMetrics: result.qualityMetrics,
              status: "draft"
            });
          }
          res.json({
            success: true,
            data: result
          });
        } catch (error) {
          logger.error("Content generation failed", { error });
          res.status(500).json({
            error: "Failed to generate content",
            message: error.message
          });
        }
      }
    );
    router3.post(
      "/content/generate-batch",
      isAuthenticated,
      strictRateLimit,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid(),
            requests: z.array(z.object({
              type: z.enum([
                "business_description",
                "product_description",
                "social_media",
                "email_template",
                "review_response"
              ]),
              platform: z.string().optional(),
              content: z.string(),
              tone: z.string().optional()
            })).min(1).max(10)
          });
          const data = schema.parse(req.body);
          const requests = data.requests.map((req2) => ({
            businessId: data.businessId,
            type: req2.type,
            platform: req2.platform,
            tone: req2.tone,
            context: { userInput: req2.content }
          }));
          const results = await openAIService.generateBatch(requests);
          const userId = req.user?.id;
          for (const result of results) {
            await storage.createGeneratedContent({
              businessId: data.businessId,
              userId,
              type: result.type,
              platform: result.platform || "general",
              content: result.content,
              metadata: result.metadata,
              qualityMetrics: result.qualityMetrics,
              status: "draft"
            });
          }
          res.json({
            success: true,
            data: results
          });
        } catch (error) {
          logger.error("Batch content generation failed", { error });
          res.status(500).json({
            error: "Failed to generate batch content"
          });
        }
      }
    );
    router3.post(
      "/content/improve",
      isAuthenticated,
      generalAPIRateLimit,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid().optional(),
            content: z.string().min(1).max(1e4),
            improvementType: z.enum([
              "seo",
              "clarity",
              "engagement",
              "grammar",
              "tone",
              "length"
            ]),
            targetTone: z.string().optional(),
            targetLength: z.number().optional(),
            keywords: z.array(z.string()).optional()
          });
          const data = schema.parse(req.body);
          const prompt = `Improve the following content for ${data.improvementType}:
        ${data.targetTone ? `Target tone: ${data.targetTone}` : ""}
        ${data.targetLength ? `Target length: ${data.targetLength} words` : ""}
        ${data.keywords ? `Include keywords: ${data.keywords.join(", ")}` : ""}
        
        Original content:
        ${data.content}`;
          const result = await openAIService.generateContent({
            businessId: data.businessId,
            type: "business_description",
            // Generic type
            context: { prompt },
            useCache: false
          });
          res.json({
            success: true,
            data: {
              original: data.content,
              improved: result.content,
              metrics: result.qualityMetrics,
              changes: {
                lengthDiff: result.content.length - data.content.length,
                wordCountDiff: result.metadata.wordCount - data.content.split(/\s+/).length
              }
            }
          });
        } catch (error) {
          logger.error("Content improvement failed", { error });
          res.status(500).json({
            error: "Failed to improve content"
          });
        }
      }
    );
    router3.get(
      "/templates",
      isAuthenticated,
      async (req, res) => {
        try {
          const { businessId, type, category, isGlobal } = req.query;
          const templates = await storage.getContentTemplates(
            businessId,
            {
              type,
              category,
              isGlobal: isGlobal === "true",
              isActive: true
            }
          );
          const builtInTemplates = await openAIService.getContentTemplates(category);
          res.json({
            success: true,
            data: {
              custom: templates,
              builtIn: builtInTemplates
            }
          });
        } catch (error) {
          logger.error("Failed to get templates", { error });
          res.status(500).json({
            error: "Failed to retrieve templates"
          });
        }
      }
    );
    router3.post(
      "/templates",
      isAuthenticated,
      generalAPIRateLimit,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid().optional(),
            name: z.string().min(1).max(255),
            description: z.string().optional(),
            type: z.string(),
            category: z.string(),
            prompt: z.string().min(1),
            variables: z.array(z.string()).optional(),
            examples: z.array(z.string()).optional(),
            tone: z.string().optional(),
            platform: z.string().optional(),
            isGlobal: z.boolean().optional().default(false)
          });
          const data = schema.parse(req.body);
          const userId = req.user?.id;
          const template = await storage.createContentTemplate({
            ...data,
            createdBy: userId,
            isActive: true,
            usageCount: 0,
            rating: "0"
          });
          res.json({
            success: true,
            data: template
          });
        } catch (error) {
          logger.error("Template creation failed", { error });
          res.status(500).json({
            error: "Failed to create template"
          });
        }
      }
    );
    router3.post(
      "/templates/:templateId/generate",
      isAuthenticated,
      generalAPIRateLimit,
      async (req, res) => {
        try {
          const { templateId } = req.params;
          const schema = z.object({
            businessId: z.string().uuid().optional(),
            variables: z.record(z.string()),
            saveToHistory: z.boolean().optional().default(true)
          });
          const data = schema.parse(req.body);
          const customTemplate = await storage.getContentTemplate(templateId);
          let result;
          if (customTemplate) {
            result = await openAIService.generateContent({
              businessId: data.businessId,
              type: customTemplate.type,
              platform: customTemplate.platform,
              tone: customTemplate.tone,
              context: {
                prompt: customTemplate.prompt,
                variables: data.variables
              }
            });
            await storage.updateContentTemplate(templateId, {
              usageCount: customTemplate.usageCount + 1
            });
          } else {
            result = await openAIService.generateFromTemplate(
              templateId,
              data.variables,
              { businessId: data.businessId }
            );
          }
          if (data.saveToHistory && data.businessId) {
            const userId = req.user?.id;
            await storage.createGeneratedContent({
              businessId: data.businessId,
              userId,
              type: result.type,
              platform: result.platform || "general",
              content: result.content,
              templateName: customTemplate?.name || templateId,
              isTemplate: true,
              metadata: result.metadata,
              qualityMetrics: result.qualityMetrics,
              status: "draft"
            });
          }
          res.json({
            success: true,
            data: result
          });
        } catch (error) {
          logger.error("Template generation failed", { error });
          res.status(500).json({
            error: "Failed to generate from template"
          });
        }
      }
    );
    router3.post(
      "/images/generate",
      isAuthenticated,
      strictRateLimit,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid().optional(),
            prompt: z.string().min(1).max(1e3),
            negativePrompt: z.string().optional(),
            size: z.enum(["1024x1024", "1024x1792", "1792x1024"]).optional(),
            style: z.enum(["vivid", "natural"]).optional(),
            quality: z.enum(["standard", "hd"]).optional(),
            category: z.enum([
              "product",
              "logo",
              "social",
              "banner",
              "background",
              "marketing"
            ]).optional(),
            numberOfImages: z.number().min(1).max(4).optional().default(1),
            enhancePrompt: z.boolean().optional().default(true),
            variations: z.boolean().optional().default(false)
          });
          const data = schema.parse(req.body);
          const result = await imageGenerationService.generateImage({
            businessId: data.businessId,
            prompt: data.prompt,
            negativePrompt: data.negativePrompt,
            size: data.size,
            style: data.style,
            quality: data.quality,
            category: data.category,
            numberOfImages: data.numberOfImages,
            enhancePrompt: data.enhancePrompt,
            variations: data.variations
          });
          res.json({
            success: true,
            data: result
          });
        } catch (error) {
          logger.error("Image generation failed", { error });
          res.status(500).json({
            error: "Failed to generate image",
            message: error.message
          });
        }
      }
    );
    router3.get(
      "/images/templates",
      isAuthenticated,
      async (req, res) => {
        try {
          const { category } = req.query;
          const templates = await imageGenerationService.getImageTemplates(
            category
          );
          res.json({
            success: true,
            data: templates
          });
        } catch (error) {
          logger.error("Failed to get image templates", { error });
          res.status(500).json({
            error: "Failed to retrieve image templates"
          });
        }
      }
    );
    router3.post(
      "/images/templates/:templateId/generate",
      isAuthenticated,
      strictRateLimit,
      async (req, res) => {
        try {
          const { templateId } = req.params;
          const schema = z.object({
            businessId: z.string().uuid().optional(),
            variables: z.record(z.string()),
            size: z.enum(["1024x1024", "1024x1792", "1792x1024"]).optional(),
            quality: z.enum(["standard", "hd"]).optional()
          });
          const data = schema.parse(req.body);
          const result = await imageGenerationService.generateFromTemplate(
            templateId,
            data.variables,
            {
              businessId: data.businessId,
              size: data.size,
              quality: data.quality
            }
          );
          res.json({
            success: true,
            data: result
          });
        } catch (error) {
          logger.error("Template image generation failed", { error });
          res.status(500).json({
            error: "Failed to generate image from template"
          });
        }
      }
    );
    router3.get(
      "/images/history",
      isAuthenticated,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid(),
            category: z.string().optional(),
            limit: z.number().optional().default(20),
            offset: z.number().optional().default(0)
          });
          const data = schema.parse(req.query);
          const images = await storage.getGeneratedImages(data.businessId, {
            category: data.category,
            limit: data.limit,
            offset: data.offset
          });
          res.json({
            success: true,
            data: images
          });
        } catch (error) {
          logger.error("Failed to get image history", { error });
          res.status(500).json({
            error: "Failed to retrieve image history"
          });
        }
      }
    );
    router3.delete(
      "/images/:imageId",
      isAuthenticated,
      async (req, res) => {
        try {
          const { imageId } = req.params;
          const { businessId } = req.query;
          if (!businessId) {
            return res.status(400).json({
              error: "Business ID is required"
            });
          }
          await imageGenerationService.deleteImage(
            imageId,
            businessId
          );
          res.json({
            success: true,
            message: "Image deleted successfully"
          });
        } catch (error) {
          logger.error("Image deletion failed", { error });
          res.status(500).json({
            error: "Failed to delete image"
          });
        }
      }
    );
    router3.get(
      "/content/history",
      isAuthenticated,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid(),
            type: z.string().optional(),
            platform: z.string().optional(),
            status: z.string().optional(),
            limit: z.number().optional().default(20),
            offset: z.number().optional().default(0)
          });
          const data = schema.parse(req.query);
          const history = await storage.getGeneratedContentHistory(
            data.businessId,
            {
              type: data.type,
              platform: data.platform,
              status: data.status,
              limit: data.limit,
              offset: data.offset
            }
          );
          res.json({
            success: true,
            data: history
          });
        } catch (error) {
          logger.error("Failed to get content history", { error });
          res.status(500).json({
            error: "Failed to retrieve content history"
          });
        }
      }
    );
    router3.patch(
      "/content/:contentId",
      isAuthenticated,
      async (req, res) => {
        try {
          const { contentId } = req.params;
          const schema = z.object({
            content: z.string().optional(),
            status: z.enum(["draft", "published", "archived"]).optional(),
            isFavorite: z.boolean().optional(),
            performanceMetrics: z.object({
              views: z.number().optional(),
              clicks: z.number().optional(),
              conversions: z.number().optional(),
              engagement: z.number().optional()
            }).optional()
          });
          const data = schema.parse(req.body);
          await storage.updateGeneratedContent(contentId, {
            ...data,
            updatedAt: /* @__PURE__ */ new Date()
          });
          res.json({
            success: true,
            message: "Content updated successfully"
          });
        } catch (error) {
          logger.error("Content update failed", { error });
          res.status(500).json({
            error: "Failed to update content"
          });
        }
      }
    );
    router3.post(
      "/content/:contentId/favorite",
      isAuthenticated,
      async (req, res) => {
        try {
          const { contentId } = req.params;
          const { isFavorite } = req.body;
          await storage.markContentAsFavorite(contentId, isFavorite);
          res.json({
            success: true,
            message: `Content ${isFavorite ? "favorited" : "unfavorited"} successfully`
          });
        } catch (error) {
          logger.error("Failed to toggle favorite", { error });
          res.status(500).json({
            error: "Failed to update favorite status"
          });
        }
      }
    );
    router3.get(
      "/usage",
      isAuthenticated,
      async (req, res) => {
        try {
          const { businessId, billingPeriod } = req.query;
          if (!businessId) {
            return res.status(400).json({
              error: "Business ID is required"
            });
          }
          const usage = await storage.getAIUsageByBusiness(
            businessId,
            billingPeriod
          );
          const summary = await storage.getAIUsageSummary(businessId);
          res.json({
            success: true,
            data: {
              usage,
              summary
            }
          });
        } catch (error) {
          logger.error("Failed to get usage statistics", { error });
          res.status(500).json({
            error: "Failed to retrieve usage statistics"
          });
        }
      }
    );
    router3.post(
      "/tests",
      isAuthenticated,
      generalAPIRateLimit,
      async (req, res) => {
        try {
          const schema = z.object({
            businessId: z.string().uuid(),
            name: z.string().min(1).max(255),
            description: z.string().optional(),
            type: z.string(),
            variants: z.array(z.object({
              id: z.string(),
              content: z.string()
            })).min(2).max(5)
          });
          const data = schema.parse(req.body);
          const test = await storage.createContentTest({
            ...data,
            status: "draft",
            startDate: /* @__PURE__ */ new Date()
          });
          res.json({
            success: true,
            data: test
          });
        } catch (error) {
          logger.error("A/B test creation failed", { error });
          res.status(500).json({
            error: "Failed to create A/B test"
          });
        }
      }
    );
    router3.get(
      "/tests",
      isAuthenticated,
      async (req, res) => {
        try {
          const { businessId, status } = req.query;
          if (!businessId) {
            return res.status(400).json({
              error: "Business ID is required"
            });
          }
          const tests = await storage.getContentTests(
            businessId,
            status
          );
          res.json({
            success: true,
            data: tests
          });
        } catch (error) {
          logger.error("Failed to get A/B tests", { error });
          res.status(500).json({
            error: "Failed to retrieve A/B tests"
          });
        }
      }
    );
    router3.post(
      "/moderate",
      isAuthenticated,
      generalAPIRateLimit,
      async (req, res) => {
        try {
          const schema = z.object({
            content: z.string().min(1),
            contentType: z.enum(["text", "prompt"]),
            businessId: z.string().uuid().optional()
          });
          const data = schema.parse(req.body);
          const moderationResult = await openAIService.moderateContent(data.content);
          if (data.businessId) {
            await storage.logModeration({
              contentType: "generated_content",
              businessId: data.businessId,
              moderationResult,
              isSafe: !moderationResult.flagged,
              action: moderationResult.flagged ? "rejected" : "approved",
              moderatedBy: "system"
            });
          }
          res.json({
            success: true,
            data: {
              isSafe: !moderationResult.flagged,
              flags: moderationResult.categories,
              scores: moderationResult.category_scores
            }
          });
        } catch (error) {
          logger.error("Content moderation failed", { error });
          res.status(500).json({
            error: "Failed to moderate content"
          });
        }
      }
    );
  }
});

// server/blogRoutes.ts
var blogRoutes_exports = {};
__export(blogRoutes_exports, {
  registerBlogRoutes: () => registerBlogRoutes
});
import { z as z2 } from "zod";
function registerBlogRoutes(app) {
  app.get("/api/blog/posts", publicEndpointRateLimit, async (req, res) => {
    try {
      const {
        status = "published",
        categoryId,
        tag,
        authorId,
        featured,
        limit = "20",
        offset = "0",
        orderBy = "publishedAt",
        order = "desc"
      } = req.query;
      const posts2 = await storage.getBlogPosts({
        status,
        categoryId,
        tag,
        authorId,
        featured: featured === "true",
        limit: parseInt(limit),
        offset: parseInt(offset),
        orderBy,
        order
      });
      res.json(posts2);
    } catch (error) {
      console.error("Error fetching blog posts:", error);
      res.status(500).json({ message: "Failed to fetch blog posts" });
    }
  });
  app.get("/api/blog/posts/by-slug/:slug", publicEndpointRateLimit, async (req, res) => {
    try {
      const { slug } = req.params;
      const post = await storage.getBlogPostBySlug(slug);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (req.headers["x-session-id"]) {
        await storage.trackBlogAnalytics({
          postId: post.id,
          userId: req.user?.claims?.sub || null,
          sessionId: req.headers["x-session-id"],
          viewType: "page_view",
          referrer: req.headers.referer,
          deviceType: req.headers["user-agent"]?.includes("Mobile") ? "mobile" : "desktop"
        });
      }
      res.json(post);
    } catch (error) {
      console.error("Error fetching blog post:", error);
      res.status(500).json({ message: "Failed to fetch blog post" });
    }
  });
  app.get("/api/blog/posts/:id", publicEndpointRateLimit, async (req, res) => {
    try {
      const { id } = req.params;
      const post = await storage.getBlogPost(id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      res.json(post);
    } catch (error) {
      console.error("Error fetching blog post:", error);
      res.status(500).json({ message: "Failed to fetch blog post" });
    }
  });
  app.post("/api/blog/posts", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tags, ...postData } = req.body;
      const validatedData = insertBlogPostSchema.parse({
        ...postData,
        authorId: userId
      });
      const post = await storage.createBlogPost(validatedData);
      if (tags && Array.isArray(tags) && tags.length > 0) {
        await storage.addTagsToBlogPost(post.id, tags);
      }
      res.json(post);
    } catch (error) {
      console.error("Error creating blog post:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to create blog post" });
    }
  });
  app.put("/api/blog/posts/:id", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const { tags, ...postData } = req.body;
      const existingPost = await storage.getBlogPost(id);
      if (!existingPost) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (existingPost.authorId !== userId) {
        return res.status(403).json({ message: "You don't have permission to edit this post" });
      }
      const validatedData = updateBlogPostSchema.parse(postData);
      const updatedPost = await storage.updateBlogPost(id, {
        ...validatedData,
        lastEditedBy: userId,
        lastEditedAt: /* @__PURE__ */ new Date()
      });
      if (tags && Array.isArray(tags)) {
        await storage.updateBlogPostTags(id, tags);
      }
      res.json(updatedPost);
    } catch (error) {
      console.error("Error updating blog post:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to update blog post" });
    }
  });
  app.delete("/api/blog/posts/:id", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const existingPost = await storage.getBlogPost(id);
      if (!existingPost) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (existingPost.authorId !== userId) {
        return res.status(403).json({ message: "You don't have permission to delete this post" });
      }
      await storage.deleteBlogPost(id);
      res.json({ message: "Post deleted successfully" });
    } catch (error) {
      console.error("Error deleting blog post:", error);
      res.status(500).json({ message: "Failed to delete blog post" });
    }
  });
  app.get("/api/blog/posts/:id/related", publicEndpointRateLimit, async (req, res) => {
    try {
      const { id } = req.params;
      const { limit = "5" } = req.query;
      const relatedPosts = await storage.getRelatedBlogPosts(id, parseInt(limit));
      res.json(relatedPosts);
    } catch (error) {
      console.error("Error fetching related posts:", error);
      res.status(500).json({ message: "Failed to fetch related posts" });
    }
  });
  app.get("/api/blog/categories", publicEndpointRateLimit, async (req, res) => {
    try {
      const categories = await storage.getBlogCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching blog categories:", error);
      res.status(500).json({ message: "Failed to fetch blog categories" });
    }
  });
  app.post("/api/blog/categories", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const validatedData = insertBlogCategorySchema.parse(req.body);
      const category = await storage.createBlogCategory(validatedData);
      res.json(category);
    } catch (error) {
      console.error("Error creating blog category:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to create blog category" });
    }
  });
  app.get("/api/blog/tags", publicEndpointRateLimit, async (req, res) => {
    try {
      const { limit = "50", popular } = req.query;
      const tags = await storage.getBlogTags({
        limit: parseInt(limit),
        popular: popular === "true"
      });
      res.json(tags);
    } catch (error) {
      console.error("Error fetching blog tags:", error);
      res.status(500).json({ message: "Failed to fetch blog tags" });
    }
  });
  app.get("/api/blog/posts/:postId/comments", publicEndpointRateLimit, async (req, res) => {
    try {
      const { postId } = req.params;
      const comments = await storage.getBlogComments(postId);
      res.json(comments);
    } catch (error) {
      console.error("Error fetching blog comments:", error);
      res.status(500).json({ message: "Failed to fetch blog comments" });
    }
  });
  app.post("/api/blog/posts/:postId/comments", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { postId } = req.params;
      const validatedData = insertBlogCommentSchema.parse({
        ...req.body,
        postId,
        authorId: userId
      });
      const comment = await storage.createBlogComment(validatedData);
      res.json(comment);
    } catch (error) {
      console.error("Error creating blog comment:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to create blog comment" });
    }
  });
  app.put("/api/blog/comments/:id", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const existingComment = await storage.getBlogComment(id);
      if (!existingComment) {
        return res.status(404).json({ message: "Comment not found" });
      }
      if (existingComment.authorId !== userId) {
        return res.status(403).json({ message: "You don't have permission to edit this comment" });
      }
      const validatedData = updateBlogCommentSchema.parse(req.body);
      const updatedComment = await storage.updateBlogComment(id, {
        ...validatedData,
        isEdited: true,
        editedAt: /* @__PURE__ */ new Date()
      });
      res.json(updatedComment);
    } catch (error) {
      console.error("Error updating blog comment:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to update blog comment" });
    }
  });
  app.delete("/api/blog/comments/:id", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const existingComment = await storage.getBlogComment(id);
      if (!existingComment) {
        return res.status(404).json({ message: "Comment not found" });
      }
      if (existingComment.authorId !== userId) {
        return res.status(403).json({ message: "You don't have permission to delete this comment" });
      }
      await storage.deleteBlogComment(id);
      res.json({ message: "Comment deleted successfully" });
    } catch (error) {
      console.error("Error deleting blog comment:", error);
      res.status(500).json({ message: "Failed to delete blog comment" });
    }
  });
  app.get("/api/blog/posts/:postId/reactions", publicEndpointRateLimit, async (req, res) => {
    try {
      const { postId } = req.params;
      const reactions = await storage.getBlogReactions(postId);
      res.json(reactions);
    } catch (error) {
      console.error("Error fetching blog reactions:", error);
      res.status(500).json({ message: "Failed to fetch blog reactions" });
    }
  });
  app.post("/api/blog/posts/:postId/reactions", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { postId } = req.params;
      const { reactionType, count: count2 } = req.body;
      const validatedData = insertBlogReactionSchema.parse({
        postId,
        userId,
        reactionType,
        count: count2 || 1
      });
      const reaction = await storage.upsertBlogReaction(validatedData);
      res.json(reaction);
    } catch (error) {
      console.error("Error creating blog reaction:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to create blog reaction" });
    }
  });
  app.delete("/api/blog/posts/:postId/reactions/:reactionType", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { postId, reactionType } = req.params;
      await storage.deleteBlogReaction(postId, userId, reactionType);
      res.json({ message: "Reaction removed successfully" });
    } catch (error) {
      console.error("Error removing blog reaction:", error);
      res.status(500).json({ message: "Failed to remove blog reaction" });
    }
  });
  app.get("/api/blog/bookmarks", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const bookmarks = await storage.getBlogBookmarks(userId);
      res.json(bookmarks);
    } catch (error) {
      console.error("Error fetching blog bookmarks:", error);
      res.status(500).json({ message: "Failed to fetch blog bookmarks" });
    }
  });
  app.post("/api/blog/posts/:postId/bookmark", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { postId } = req.params;
      const { readingListId, notes } = req.body;
      const validatedData = insertBlogBookmarkSchema.parse({
        postId,
        userId,
        readingListId: readingListId || null,
        notes: notes || null
      });
      const bookmark = await storage.createBlogBookmark(validatedData);
      res.json(bookmark);
    } catch (error) {
      console.error("Error creating blog bookmark:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to create blog bookmark" });
    }
  });
  app.delete("/api/blog/posts/:postId/bookmark", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { postId } = req.params;
      await storage.deleteBlogBookmark(postId, userId);
      res.json({ message: "Bookmark removed successfully" });
    } catch (error) {
      console.error("Error removing blog bookmark:", error);
      res.status(500).json({ message: "Failed to remove blog bookmark" });
    }
  });
  app.post("/api/blog/subscribe", generalAPIRateLimit, async (req, res) => {
    try {
      const userId = req.user?.claims?.sub || null;
      const { email, subscribedToAll, subscribedCategories, subscribedAuthors, frequency } = req.body;
      const validatedData = insertBlogSubscriptionSchema.parse({
        userId,
        email,
        subscribedToAll: subscribedToAll !== void 0 ? subscribedToAll : true,
        subscribedCategories: subscribedCategories || null,
        subscribedAuthors: subscribedAuthors || null,
        frequency: frequency || "instant",
        unsubscribeToken: generateUnsubscribeToken()
      });
      const subscription = await storage.createBlogSubscription(validatedData);
      res.json(subscription);
    } catch (error) {
      console.error("Error creating blog subscription:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: error.message || "Failed to create blog subscription" });
    }
  });
  app.post("/api/blog/unsubscribe", publicEndpointRateLimit, async (req, res) => {
    try {
      const { token } = req.body;
      if (!token) {
        return res.status(400).json({ message: "Unsubscribe token is required" });
      }
      await storage.unsubscribeBlog(token);
      res.json({ message: "Unsubscribed successfully" });
    } catch (error) {
      console.error("Error unsubscribing from blog:", error);
      res.status(500).json({ message: "Failed to unsubscribe from blog" });
    }
  });
  app.post("/api/blog/posts/:postId/analytics", publicEndpointRateLimit, async (req, res) => {
    try {
      const { postId } = req.params;
      const {
        viewType,
        scrollDepth,
        timeSpentSeconds,
        sessionId,
        referrer,
        utmSource,
        utmMedium,
        utmCampaign
      } = req.body;
      const userId = req.user?.claims?.sub || null;
      await storage.trackBlogAnalytics({
        postId,
        userId,
        sessionId: sessionId || req.headers["x-session-id"],
        viewType,
        scrollDepth,
        timeSpentSeconds,
        referrer: referrer || req.headers.referer,
        utmSource,
        utmMedium,
        utmCampaign,
        deviceType: req.headers["user-agent"]?.includes("Mobile") ? "mobile" : "desktop",
        browser: extractBrowser(req.headers["user-agent"]),
        os: extractOS(req.headers["user-agent"])
      });
      res.json({ message: "Analytics tracked successfully" });
    } catch (error) {
      console.error("Error tracking blog analytics:", error);
      res.status(500).json({ message: "Failed to track blog analytics" });
    }
  });
  app.get("/api/blog/posts/:postId/analytics", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { postId } = req.params;
      const post = await storage.getBlogPost(postId);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== userId) {
        return res.status(403).json({ message: "You don't have permission to view analytics for this post" });
      }
      const analytics = await storage.getBlogPostAnalytics(postId);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching blog analytics:", error);
      res.status(500).json({ message: "Failed to fetch blog analytics" });
    }
  });
}
function generateUnsubscribeToken() {
  return Array.from(
    { length: 32 },
    () => Math.floor(Math.random() * 16).toString(16)
  ).join("");
}
function extractBrowser(userAgent) {
  if (!userAgent) return "unknown";
  if (userAgent.includes("Chrome")) return "chrome";
  if (userAgent.includes("Safari")) return "safari";
  if (userAgent.includes("Firefox")) return "firefox";
  if (userAgent.includes("Edge")) return "edge";
  return "other";
}
function extractOS(userAgent) {
  if (!userAgent) return "unknown";
  if (userAgent.includes("Windows")) return "windows";
  if (userAgent.includes("Mac")) return "macos";
  if (userAgent.includes("Linux")) return "linux";
  if (userAgent.includes("Android")) return "android";
  if (userAgent.includes("iOS")) return "ios";
  return "other";
}
var init_blogRoutes = __esm({
  "server/blogRoutes.ts"() {
    "use strict";
    init_storage();
    init_auth();
    init_rateLimit();
    init_schema();
  }
});

// server/smsService.ts
var SMSService, smsService;
var init_smsService = __esm({
  "server/smsService.ts"() {
    "use strict";
    SMSService = class {
      // Average cost per SMS in USD
      constructor() {
        this.costPerSMS = 75e-4;
        this.baseUrl = process.env.APP_URL || "http://localhost:5000";
        this.accountSid = process.env.TWILIO_ACCOUNT_SID || "";
        this.authToken = process.env.TWILIO_AUTH_TOKEN || "";
        this.fromPhone = process.env.TWILIO_PHONE_NUMBER || "";
        if (!this.accountSid || !this.authToken || !this.fromPhone) {
          console.warn("\u26A0\uFE0F  Twilio not configured. SMS messages will be logged to console only.");
        }
      }
      /**
       * Send a single SMS
       */
      async sendSMS(options) {
        try {
          if (options.testMode) {
            console.log("\u{1F4F1} [TEST MODE] SMS would be sent:", {
              to: options.to,
              from: options.from,
              message: options.message.substring(0, 50) + "..."
            });
            return {
              success: true,
              messageId: `test-${Date.now()}`,
              recipientPhone: Array.isArray(options.to) ? options.to[0].phone : options.to.phone,
              status: "test"
            };
          }
          const recipient = Array.isArray(options.to) ? options.to[0] : options.to;
          if (!this.isValidPhoneNumber(recipient.phone)) {
            return {
              success: false,
              error: "Invalid phone number format",
              recipientPhone: recipient.phone
            };
          }
          let message = options.message;
          if (!message.toLowerCase().includes("stop") && !message.toLowerCase().includes("opt out")) {
            message += "\n\nReply STOP to unsubscribe.";
          }
          if (message.length > 1600) {
            return {
              success: false,
              error: "Message too long (max 1600 characters)",
              recipientPhone: recipient.phone
            };
          }
          return await this.sendViaTwilio(recipient.phone, options.from, message, options.metadata);
        } catch (error) {
          console.error("\u274C SMS sending failed:", error);
          return {
            success: false,
            error: error.message || "Unknown error",
            recipientPhone: Array.isArray(options.to) ? options.to[0].phone : options.to.phone
          };
        }
      }
      /**
       * Send bulk SMS messages (for campaigns)
       */
      async sendBulkSMS(messages2) {
        const results = [];
        let totalSent = 0;
        let totalFailed = 0;
        const batchSize = 50;
        for (let i = 0; i < messages2.length; i += batchSize) {
          const batch = messages2.slice(i, i + batchSize);
          const batchResults = await Promise.all(
            batch.map((sms) => this.sendSMS(sms))
          );
          for (const result of batchResults) {
            results.push(result);
            if (result.success) {
              totalSent++;
            } else {
              totalFailed++;
            }
          }
          if (i + batchSize < messages2.length) {
            await new Promise((resolve) => setTimeout(resolve, 2e3));
          }
        }
        return {
          totalSent,
          totalFailed,
          results
        };
      }
      /**
       * Send SMS via Twilio
       */
      async sendViaTwilio(to, from, message, metadata) {
        if (await this.isOptedOut(to)) {
          return {
            success: false,
            error: "Phone number has opted out of SMS messages",
            recipientPhone: to
          };
        }
        if (!this.accountSid || !this.authToken || !this.fromPhone) {
          console.log("\u{1F4F1} [TWILIO MOCK] SMS:", {
            to,
            from: from || this.fromPhone,
            message: message.substring(0, 50) + "...",
            segments: this.countSegments(message),
            estimatedCost: `$${(this.costPerSMS * this.countSegments(message)).toFixed(4)}`
          });
          return {
            success: true,
            messageId: `mock-${Date.now()}`,
            recipientPhone: to,
            status: "mock"
          };
        }
        try {
          const twilio = await import("twilio");
          const client2 = twilio.default(this.accountSid, this.authToken);
          const formattedTo = this.formatPhoneNumber(to);
          const formattedFrom = from || this.fromPhone;
          const response = await client2.messages.create({
            body: message,
            from: formattedFrom,
            to: formattedTo,
            statusCallback: metadata?.statusCallbackUrl
            // Optional webhook for delivery status
          });
          console.log(`\u{1F4F1} SMS sent successfully: ${response.sid} to ${formattedTo}`);
          if (metadata?.campaignId && metadata?.recipientId) {
            await this.trackSMSSent(metadata.campaignId, metadata.recipientId, response.sid);
          }
          return {
            success: true,
            messageId: response.sid,
            recipientPhone: to,
            status: response.status
          };
        } catch (error) {
          console.error("Twilio send error:", error);
          if (error.code === 21211) {
            return {
              success: false,
              error: "Invalid phone number format",
              recipientPhone: to
            };
          } else if (error.code === 21610) {
            await this.markOptedOut(to);
            return {
              success: false,
              error: "Phone number has been blacklisted",
              recipientPhone: to
            };
          } else if (error.code === 21408) {
            return {
              success: false,
              error: "Permission to send SMS not enabled for region",
              recipientPhone: to
            };
          }
          throw new Error(`Twilio error: ${error.message}`);
        }
      }
      /**
       * Validate phone number format
       *
       * Accepts formats:
       * - +1234567890 (E.164 format - preferred)
       * - (123) 456-7890
       * - 123-456-7890
       * - 1234567890
       */
      isValidPhoneNumber(phone) {
        const cleaned = phone.replace(/[^\d+]/g, "");
        if (cleaned.startsWith("+")) {
          return /^\+\d{1,15}$/.test(cleaned);
        }
        return /^\d{10,11}$/.test(cleaned);
      }
      /**
       * Format phone number to E.164 format
       *
       * E.164 is the international phone number format: +[country code][number]
       * Example: +14155552671
       */
      formatPhoneNumber(phone, defaultCountryCode = "+1") {
        let cleaned = phone.replace(/[^\d+]/g, "");
        if (cleaned.startsWith("+")) {
          return cleaned;
        }
        if (cleaned.length === 11 && cleaned.startsWith("1")) {
          return "+" + cleaned;
        }
        if (cleaned.length === 10) {
          return defaultCountryCode + cleaned;
        }
        return phone;
      }
      /**
       * Estimate SMS cost
       *
       * SMS pricing varies by country and carrier, but this provides a rough estimate
       */
      estimateCost(messageCount, messageLength = 160) {
        const messagesPerRecipient = Math.ceil(messageLength / 160);
        const totalMessages = messageCount * messagesPerRecipient;
        return totalMessages * this.costPerSMS;
      }
      /**
       * Count SMS segments
       *
       * SMS is sent in 160-character segments (or 70 characters for Unicode)
       */
      countSegments(message) {
        const hasUnicode = /[^\x00-\x7F]/.test(message);
        const segmentLength = hasUnicode ? 70 : 160;
        return Math.ceil(message.length / segmentLength);
      }
      /**
       * Generate short URL for SMS links
       *
       * Since SMS character count is limited, it's important to use short URLs
       */
      generateShortLink(originalUrl, shortCode) {
        return `${this.baseUrl}/s/${shortCode}`;
      }
      /**
       * Get provider info
       */
      getProviderInfo() {
        return {
          provider: "twilio",
          configured: !!(this.accountSid && this.authToken && this.fromPhone)
        };
      }
      /**
       * Check if number is opted out
       *
       * Queries database for opt-out status
       */
      async isOptedOut(phone) {
        try {
          const { MarketingStorage: MarketingStorage2 } = await Promise.resolve().then(() => (init_marketingStorage(), marketingStorage_exports));
          const storage2 = new MarketingStorage2();
          const formattedPhone = this.formatPhoneNumber(phone);
          return await storage2.isSMSOptedOut(formattedPhone);
        } catch (error) {
          console.error("Error checking opt-out status:", error);
          return false;
        }
      }
      /**
       * Mark number as opted out
       *
       * Updates database to mark phone as opted out
       */
      async markOptedOut(phone) {
        try {
          const { MarketingStorage: MarketingStorage2 } = await Promise.resolve().then(() => (init_marketingStorage(), marketingStorage_exports));
          const storage2 = new MarketingStorage2();
          const formattedPhone = this.formatPhoneNumber(phone);
          await storage2.markSMSOptedOut(formattedPhone);
          console.log(`\u{1F4F1} Phone number opted out: ${formattedPhone}`);
        } catch (error) {
          console.error("Error marking opt-out:", error);
        }
      }
      /**
       * Track SMS sent for analytics
       */
      async trackSMSSent(campaignId, recipientId, messageId) {
        try {
          const { MarketingStorage: MarketingStorage2 } = await Promise.resolve().then(() => (init_marketingStorage(), marketingStorage_exports));
          const storage2 = new MarketingStorage2();
          await storage2.updateCampaignRecipient(recipientId, {
            status: "sent",
            sentAt: /* @__PURE__ */ new Date(),
            messageId
          });
          await storage2.updateCampaignMetrics(campaignId, { sentCount: 1 });
        } catch (error) {
          console.error("Error tracking SMS sent:", error);
        }
      }
      /**
       * Handle incoming SMS webhooks (for STOP messages)
       */
      async handleIncomingSMS(from, body) {
        const message = body.trim().toUpperCase();
        const optOutKeywords = ["STOP", "UNSUBSCRIBE", "CANCEL", "END", "QUIT"];
        if (optOutKeywords.includes(message)) {
          await this.markOptedOut(from);
          if (this.accountSid && this.authToken && this.fromPhone) {
            await this.sendSMS({
              to: { phone: from },
              from: this.fromPhone,
              message: "You have been unsubscribed from SMS messages. Reply START to resubscribe."
            });
          }
        }
        const optInKeywords = ["START", "YES", "SUBSCRIBE"];
        if (optInKeywords.includes(message)) {
          await this.markOptedIn(from);
          if (this.accountSid && this.authToken && this.fromPhone) {
            await this.sendSMS({
              to: { phone: from },
              from: this.fromPhone,
              message: "Welcome! You have been subscribed to SMS messages. Reply STOP to unsubscribe."
            });
          }
        }
      }
      /**
       * Mark number as opted in (resubscribe)
       */
      async markOptedIn(phone) {
        try {
          const { MarketingStorage: MarketingStorage2 } = await Promise.resolve().then(() => (init_marketingStorage(), marketingStorage_exports));
          const storage2 = new MarketingStorage2();
          const formattedPhone = this.formatPhoneNumber(phone);
          await storage2.markSMSOptedIn(formattedPhone);
          console.log(`\u{1F4F1} Phone number opted in: ${formattedPhone}`);
        } catch (error) {
          console.error("Error marking opt-in:", error);
        }
      }
    };
    smsService = new SMSService();
  }
});

// server/marketingRoutes.ts
var marketingRoutes_exports = {};
__export(marketingRoutes_exports, {
  registerMarketingRoutes: () => registerMarketingRoutes
});
import { z as z3 } from "zod";
function registerMarketingRoutes(app) {
  app.get("/api/marketing/campaigns", requireAuth, async (req, res) => {
    try {
      const { businessId, status, type, limit, offset } = req.query;
      if (!businessId) {
        return res.status(400).json({ error: "businessId is required" });
      }
      const campaigns = await marketingStorage.getMarketingCampaigns(
        businessId,
        { status, type, limit: Number(limit) || 50, offset: Number(offset) || 0 }
      );
      res.json(campaigns);
    } catch (error) {
      console.error("Error fetching campaigns:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/campaigns/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const campaign = await marketingStorage.getMarketingCampaign(id);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      res.json(campaign);
    } catch (error) {
      console.error("Error fetching campaign:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/campaigns", requireAuth, async (req, res) => {
    try {
      const campaignSchema = z3.object({
        businessId: z3.string().uuid(),
        name: z3.string().min(1).max(255),
        description: z3.string().optional(),
        type: z3.enum(["email", "sms", "push", "multi-channel"]),
        subject: z3.string().max(255).optional(),
        preheaderText: z3.string().max(150).optional(),
        senderName: z3.string().max(100).optional(),
        senderEmail: z3.string().email().optional(),
        senderPhone: z3.string().max(20).optional(),
        content: z3.string(),
        plainTextContent: z3.string().optional(),
        targetSegmentId: z3.string().uuid().optional(),
        scheduledAt: z3.string().datetime().optional(),
        trackOpens: z3.boolean().optional(),
        trackClicks: z3.boolean().optional()
      });
      const data = campaignSchema.parse(req.body);
      const campaign = await marketingStorage.createMarketingCampaign(data);
      res.status(201).json(campaign);
    } catch (error) {
      console.error("Error creating campaign:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid data", details: error.errors });
      }
      res.status(500).json({ error: error.message });
    }
  });
  app.put("/api/marketing/campaigns/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const campaign = await marketingStorage.updateMarketingCampaign(id, req.body);
      res.json(campaign);
    } catch (error) {
      console.error("Error updating campaign:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.delete("/api/marketing/campaigns/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      await marketingStorage.deleteMarketingCampaign(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting campaign:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/campaigns/:id/send", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { testMode = false } = req.body;
      const campaign = await marketingStorage.getMarketingCampaign(id);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      let recipients;
      if (campaign.targetSegmentId) {
        const segmentMembers2 = await marketingStorage.getSegmentMembers(campaign.targetSegmentId, 1e4, 0);
        recipients = segmentMembers2.map((m) => m.user);
      } else {
        recipients = [];
      }
      const campaignRecipients2 = recipients.map((user) => ({
        campaignId: id,
        userId: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName
      }));
      await marketingStorage.createCampaignRecipients(campaignRecipients2);
      if (campaign.type === "email") {
        const emails = campaignRecipients2.map((recipient) => ({
          to: {
            email: recipient.email,
            firstName: recipient.firstName,
            lastName: recipient.lastName
          },
          from: {
            email: campaign.senderEmail || "noreply@floridalocalelite.com",
            name: campaign.senderName || "Florida Local Elite"
          },
          subject: campaign.subject || "No subject",
          html: campaign.content,
          text: campaign.plainTextContent,
          trackOpens: campaign.trackOpens,
          trackClicks: campaign.trackClicks,
          campaignId: id,
          testMode
        }));
        const result = await emailService.sendBulkEmails(emails);
        await marketingStorage.updateCampaignMetrics(id, {
          sentCount: result.totalSent
        });
        await marketingStorage.markCampaignAsSent(id);
        res.json({ success: true, sent: result.totalSent, failed: result.totalFailed });
      } else if (campaign.type === "sms") {
        const messages2 = campaignRecipients2.map((recipient) => ({
          to: {
            phone: recipient.email,
            // TODO: Use actual phone number
            firstName: recipient.firstName,
            lastName: recipient.lastName
          },
          from: campaign.senderPhone || "",
          message: campaign.content,
          campaignId: id,
          testMode
        }));
        const result = await smsService.sendBulkSMS(messages2);
        await marketingStorage.updateCampaignMetrics(id, {
          sentCount: result.totalSent
        });
        await marketingStorage.markCampaignAsSent(id);
        res.json({ success: true, sent: result.totalSent, failed: result.totalFailed });
      } else {
        res.status(400).json({ error: "Unsupported campaign type" });
      }
    } catch (error) {
      console.error("Error sending campaign:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/campaigns/:id/test", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { email, phone } = req.body;
      const campaign = await marketingStorage.getMarketingCampaign(id);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      if (campaign.type === "email" && email) {
        const result = await emailService.sendEmail({
          to: { email },
          from: {
            email: campaign.senderEmail || "noreply@floridalocalelite.com",
            name: campaign.senderName || "Florida Local Elite"
          },
          subject: `[TEST] ${campaign.subject}`,
          html: campaign.content,
          text: campaign.plainTextContent,
          testMode: false
        });
        res.json({ success: result.success, messageId: result.messageId });
      } else if (campaign.type === "sms" && phone) {
        const result = await smsService.sendSMS({
          to: { phone },
          from: campaign.senderPhone || "",
          message: `[TEST] ${campaign.content}`,
          testMode: false
        });
        res.json({ success: result.success, messageId: result.messageId });
      } else {
        res.status(400).json({ error: "Invalid test parameters" });
      }
    } catch (error) {
      console.error("Error sending test campaign:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/campaigns/:id/recipients", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, limit, offset } = req.query;
      const recipients = await marketingStorage.getCampaignRecipients(id, {
        status,
        limit: Number(limit) || 100,
        offset: Number(offset) || 0
      });
      res.json(recipients);
    } catch (error) {
      console.error("Error fetching recipients:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/campaigns/:id/analytics", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const analytics = await marketingStorage.getCampaignAnalytics(id);
      if (!analytics) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/campaigns/:id/duplicate", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const campaign = await marketingStorage.getMarketingCampaign(id);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      const newCampaign = await marketingStorage.createMarketingCampaign({
        ...campaign,
        id: void 0,
        name: `${campaign.name} (Copy)`,
        status: "draft",
        sentAt: null,
        completedAt: null,
        sentCount: 0,
        deliveredCount: 0,
        openedCount: 0,
        clickedCount: 0,
        bouncedCount: 0,
        unsubscribedCount: 0
      });
      res.status(201).json(newCampaign);
    } catch (error) {
      console.error("Error duplicating campaign:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/segments", requireAuth, async (req, res) => {
    try {
      const { businessId } = req.query;
      if (!businessId) {
        return res.status(400).json({ error: "businessId is required" });
      }
      const segments = await marketingStorage.getCustomerSegments(businessId);
      res.json(segments);
    } catch (error) {
      console.error("Error fetching segments:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/segments/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const segment = await marketingStorage.getCustomerSegment(id);
      if (!segment) {
        return res.status(404).json({ error: "Segment not found" });
      }
      res.json(segment);
    } catch (error) {
      console.error("Error fetching segment:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/segments", requireAuth, async (req, res) => {
    try {
      const segmentSchema = z3.object({
        businessId: z3.string().uuid(),
        name: z3.string().min(1).max(255),
        description: z3.string().optional(),
        criteria: z3.any(),
        // JSON object
        autoUpdate: z3.boolean().optional()
      });
      const data = segmentSchema.parse(req.body);
      const segment = await marketingStorage.createCustomerSegment(data);
      const memberIds = await marketingStorage.calculateSegmentMembers(segment.id);
      if (memberIds.length > 0) {
        await marketingStorage.addSegmentMembers(segment.id, memberIds, "automatic");
      }
      res.status(201).json(segment);
    } catch (error) {
      console.error("Error creating segment:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid data", details: error.errors });
      }
      res.status(500).json({ error: error.message });
    }
  });
  app.put("/api/marketing/segments/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const segment = await marketingStorage.updateCustomerSegment(id, req.body);
      res.json(segment);
    } catch (error) {
      console.error("Error updating segment:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.delete("/api/marketing/segments/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      await marketingStorage.deleteCustomerSegment(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting segment:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/segments/:id/members", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { limit, offset } = req.query;
      const members = await marketingStorage.getSegmentMembers(
        id,
        Number(limit) || 100,
        Number(offset) || 0
      );
      res.json(members);
    } catch (error) {
      console.error("Error fetching segment members:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/segments/:id/calculate", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const memberIds = await marketingStorage.calculateSegmentMembers(id);
      if (memberIds.length > 0) {
        await marketingStorage.addSegmentMembers(id, memberIds, "automatic");
      }
      res.json({ success: true, memberCount: memberIds.length });
    } catch (error) {
      console.error("Error calculating segment:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/workflows", requireAuth, async (req, res) => {
    try {
      const { businessId } = req.query;
      if (!businessId) {
        return res.status(400).json({ error: "businessId is required" });
      }
      const workflows = await marketingStorage.getMarketingWorkflows(businessId);
      res.json(workflows);
    } catch (error) {
      console.error("Error fetching workflows:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/workflows/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const workflow = await marketingStorage.getMarketingWorkflow(id);
      if (!workflow) {
        return res.status(404).json({ error: "Workflow not found" });
      }
      res.json(workflow);
    } catch (error) {
      console.error("Error fetching workflow:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/workflows", requireAuth, async (req, res) => {
    try {
      const workflowSchema = z3.object({
        businessId: z3.string().uuid(),
        name: z3.string().min(1).max(255),
        description: z3.string().optional(),
        triggerType: z3.string(),
        triggerConfig: z3.any().optional(),
        steps: z3.any()
        // JSON array
      });
      const data = workflowSchema.parse(req.body);
      const workflow = await marketingStorage.createMarketingWorkflow(data);
      res.status(201).json(workflow);
    } catch (error) {
      console.error("Error creating workflow:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid data", details: error.errors });
      }
      res.status(500).json({ error: error.message });
    }
  });
  app.put("/api/marketing/workflows/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const workflow = await marketingStorage.updateMarketingWorkflow(id, req.body);
      res.json(workflow);
    } catch (error) {
      console.error("Error updating workflow:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.delete("/api/marketing/workflows/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      await marketingStorage.deleteMarketingWorkflow(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting workflow:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/workflows/:id/activate", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      await marketingStorage.activateWorkflow(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error activating workflow:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/workflows/:id/pause", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      await marketingStorage.pauseWorkflow(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error pausing workflow:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/workflows/:id/enrollments", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, limit, offset } = req.query;
      const enrollments = await marketingStorage.getWorkflowEnrollments(id, {
        status,
        limit: Number(limit) || 100,
        offset: Number(offset) || 0
      });
      res.json(enrollments);
    } catch (error) {
      console.error("Error fetching enrollments:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/forms", requireAuth, async (req, res) => {
    try {
      const { businessId } = req.query;
      if (!businessId) {
        return res.status(400).json({ error: "businessId is required" });
      }
      const forms = await marketingStorage.getLeadCaptureForms(businessId);
      res.json(forms);
    } catch (error) {
      console.error("Error fetching forms:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/forms/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const form = await marketingStorage.getLeadCaptureForm(id);
      if (!form) {
        return res.status(404).json({ error: "Form not found" });
      }
      res.json(form);
    } catch (error) {
      console.error("Error fetching form:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/forms", requireAuth, async (req, res) => {
    try {
      const formSchema = z3.object({
        businessId: z3.string().uuid(),
        name: z3.string().min(1).max(255),
        description: z3.string().optional(),
        fields: z3.any(),
        // JSON array
        successMessage: z3.string().optional(),
        redirectUrl: z3.string().url().optional(),
        addToSegmentId: z3.string().uuid().optional(),
        enrollInWorkflowId: z3.string().uuid().optional()
      });
      const data = formSchema.parse(req.body);
      const form = await marketingStorage.createLeadCaptureForm(data);
      res.status(201).json(form);
    } catch (error) {
      console.error("Error creating form:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid data", details: error.errors });
      }
      res.status(500).json({ error: error.message });
    }
  });
  app.put("/api/marketing/forms/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const form = await marketingStorage.updateLeadCaptureForm(id, req.body);
      res.json(form);
    } catch (error) {
      console.error("Error updating form:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.delete("/api/marketing/forms/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      await marketingStorage.deleteLeadCaptureForm(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting form:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.post("/api/marketing/forms/:id/submit", async (req, res) => {
    try {
      const { id } = req.params;
      const form = await marketingStorage.getLeadCaptureForm(id);
      if (!form || !form.isActive) {
        return res.status(404).json({ error: "Form not found or inactive" });
      }
      const submissionSchema = z3.object({
        formData: z3.any(),
        // JSON object with form field values
        utmSource: z3.string().optional(),
        utmMedium: z3.string().optional(),
        utmCampaign: z3.string().optional()
      });
      const data = submissionSchema.parse(req.body);
      const submission = await marketingStorage.submitLeadForm({
        formId: id,
        businessId: form.businessId,
        formData: data.formData,
        email: data.formData.email,
        phone: data.formData.phone,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        referrer: req.headers.referer,
        utmSource: data.utmSource,
        utmMedium: data.utmMedium,
        utmCampaign: data.utmCampaign
      });
      if (form.enrollInWorkflowId) {
        console.log(`Auto-enrolling in workflow ${form.enrollInWorkflowId}`);
      }
      if (form.addToSegmentId) {
        console.log(`Auto-adding to segment ${form.addToSegmentId}`);
      }
      res.json({
        success: true,
        message: form.successMessage,
        redirectUrl: form.redirectUrl
      });
    } catch (error) {
      console.error("Error submitting form:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid data", details: error.errors });
      }
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/forms/:id/submissions", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, limit, offset } = req.query;
      const submissions = await marketingStorage.getLeadSubmissions(id, {
        status,
        limit: Number(limit) || 100,
        offset: Number(offset) || 0
      });
      res.json(submissions);
    } catch (error) {
      console.error("Error fetching submissions:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app.get("/api/marketing/track/open/:recipientId", async (req, res) => {
    try {
      const { recipientId } = req.params;
      await marketingStorage.trackEmailOpen(recipientId);
      const gif = Buffer.from("R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", "base64");
      res.set("Content-Type", "image/gif");
      res.set("Cache-Control", "no-cache, no-store, must-revalidate");
      res.send(gif);
    } catch (error) {
      console.error("Error tracking open:", error);
      const gif = Buffer.from("R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", "base64");
      res.set("Content-Type", "image/gif");
      res.send(gif);
    }
  });
  app.get("/api/marketing/track/click/:shortCode", async (req, res) => {
    try {
      const { shortCode } = req.params;
      const link = await marketingStorage.getCampaignLinkByShortCode(shortCode);
      if (!link) {
        return res.status(404).json({ error: "Link not found" });
      }
      const { recipientId } = req.query;
      if (recipientId) {
        await marketingStorage.trackLinkClick({
          campaignId: link.campaignId,
          recipientId,
          linkId: link.id,
          ipAddress: req.ip,
          userAgent: req.headers["user-agent"],
          deviceType: "desktop",
          // TODO: Parse user agent
          browser: "unknown",
          // TODO: Parse user agent
          os: "unknown"
          // TODO: Parse user agent
        });
      }
      res.redirect(link.originalUrl);
    } catch (error) {
      console.error("Error tracking click:", error);
      res.status(500).json({ error: error.message });
    }
  });
  console.log("\u2705 Marketing automation routes registered");
}
var requireAuth;
var init_marketingRoutes = __esm({
  "server/marketingRoutes.ts"() {
    "use strict";
    init_marketingStorage();
    init_emailService();
    init_smsService();
    requireAuth = (req, res, next) => {
      if (!req.isAuthenticated || !req.isAuthenticated()) {
        return res.status(401).json({ error: "Authentication required" });
      }
      next();
    };
  }
});

// server/aiAgentOrchestrator.ts
var AGENT_CONFIGS, AIAgentOrchestrator, aiAgentOrchestrator;
var init_aiAgentOrchestrator = __esm({
  "server/aiAgentOrchestrator.ts"() {
    "use strict";
    init_aiService();
    AGENT_CONFIGS = {
      // Campaign optimization - uses strategic thinking model
      campaign_optimize: {
        model: "anthropic/claude-3.5-sonnet",
        // Best for strategic analysis
        temperature: 0.7,
        maxTokens: 4e3,
        systemPrompt: `You are an expert email marketing strategist with 15+ years of experience optimizing campaigns for Fortune 500 companies.

Your role is to analyze email campaigns and provide actionable recommendations to improve:
- Open rates (industry average: 21%, top performers: 35%+)
- Click-through rates (industry average: 2.6%, top performers: 5%+)
- Conversion rates
- Engagement metrics
- Overall ROI

Provide specific, data-driven recommendations with expected impact percentages.`
      },
      // Content generation - uses creative writing model
      content_generate: {
        model: "anthropic/claude-3.5-sonnet",
        // Best for creative content
        temperature: 0.9,
        maxTokens: 3e3,
        systemPrompt: `You are a world-class copywriter specializing in email marketing and conversion optimization.

Your expertise includes:
- Writing compelling subject lines (45-50 characters optimal)
- Crafting engaging email body content
- Creating powerful calls-to-action
- Personalizing content for different segments
- Optimizing for mobile and desktop
- Writing in brand voice and tone

Generate high-converting, persuasive copy that drives action. Focus on clarity, urgency, and value proposition.`
      },
      // Segment analysis - uses analytical model
      segment_analyze: {
        model: "openai/gpt-4-turbo",
        // Best for data analysis
        temperature: 0.3,
        maxTokens: 3e3,
        systemPrompt: `You are a data scientist specializing in customer segmentation and predictive analytics.

Analyze customer data to:
- Identify high-value segments
- Predict customer behavior
- Recommend targeting strategies
- Calculate segment lifetime value
- Identify churn risk
- Suggest cross-sell/upsell opportunities

Provide quantitative insights with confidence scores and actionable recommendations.`
      },
      // Subject line testing - uses creative + analytical model
      subject_test: {
        model: "anthropic/claude-3.5-sonnet",
        temperature: 0.8,
        maxTokens: 2e3,
        systemPrompt: `You are an A/B testing expert specializing in email subject line optimization.

Generate subject line variations that test different psychological triggers:
- Urgency vs. Value
- Curiosity vs. Clarity
- Personalization vs. Generic
- Emoji vs. Text-only
- Question vs. Statement
- Short (30-40 chars) vs. Medium (41-50 chars)

For each variation, explain the psychological principle and predict which audience segment will respond best.`
      },
      // Send time optimization - uses predictive model
      send_time_optimize: {
        model: "openai/gpt-4-turbo",
        temperature: 0.2,
        maxTokens: 2e3,
        systemPrompt: `You are a marketing automation expert specializing in send time optimization.

Analyze historical engagement data to predict optimal send times based on:
- Day of week patterns
- Time of day patterns
- Industry benchmarks
- Audience demographics
- Time zones
- Seasonal trends

Provide specific send time recommendations with confidence scores and expected lift in engagement.`
      },
      // Workflow generation - uses process optimization model
      workflow_generate: {
        model: "anthropic/claude-3.5-sonnet",
        temperature: 0.6,
        maxTokens: 4e3,
        systemPrompt: `You are a marketing automation architect with expertise in building high-converting workflow sequences.

Design multi-step workflows that maximize:
- Lead nurturing effectiveness
- Customer onboarding completion
- Re-engagement success
- Upsell/cross-sell conversions
- Customer retention

Create workflows with optimal timing, messaging, and branching logic based on customer behavior and engagement signals.`
      },
      // Form optimization - uses conversion optimization model
      form_optimize: {
        model: "openai/gpt-4-turbo",
        temperature: 0.5,
        maxTokens: 2500,
        systemPrompt: `You are a conversion rate optimization expert specializing in form design and user experience.

Analyze and optimize forms for:
- Field reduction (fewer fields = higher conversion)
- Progressive disclosure
- Clear value proposition
- Trust signals and social proof
- Mobile optimization
- Error prevention and validation
- Button copy and placement

Provide specific recommendations to increase form completion rates by 20-50%.`
      },
      // ========================================
      // MARKETPLACE-SPECIFIC AGENTS (8)
      // ========================================
      // 1. Marketplace optimization - strategic pricing and category analysis
      marketplace_optimize: {
        model: "anthropic/claude-3-opus",
        temperature: 0.7,
        maxTokens: 4e3,
        systemPrompt: `You are an expert marketplace analyst specializing in Florida local businesses and e-commerce optimization.

Analyze and optimize:
- Product pricing competitiveness within Florida market
- Category performance and trending products
- Vendor success metrics and growth predictions
- Inventory level recommendations
- Seasonal demand forecasting (tourism, hurricane season, snowbird patterns)
- Local market competitive analysis
- Regional pricing variations across Florida

Provide data-driven recommendations with confidence scores (0-100) and expected impact percentages. Focus on actionable insights specific to Florida's unique market dynamics.`
      },
      // 2. GMB orchestration - Google My Business optimization
      gmb_orchestrate: {
        model: "openai/gpt-4-turbo",
        temperature: 0.4,
        maxTokens: 3500,
        systemPrompt: `You are a Google My Business optimization expert for Florida local businesses with expertise in local SEO and reputation management.

Monitor and optimize:
- GMB API health and sync status
- Review sentiment analysis and response recommendations
- Business hours optimization based on foot traffic patterns
- Post scheduling for maximum local engagement
- Local SEO and competitive positioning
- Customer Q&A management
- Photo optimization and visual content strategy
- Service area targeting

Provide actionable GMB optimization strategies with ROI projections and implementation timelines. Consider Florida-specific factors like seasonal tourism, multiple time zones, and diverse demographics.`
      },
      // 3. Fraud detection - security and anomaly detection
      fraud_detect: {
        model: "mistralai/mixtral-8x7b-instruct",
        temperature: 0.1,
        maxTokens: 2500,
        systemPrompt: `You are a fraud detection specialist with expertise in e-commerce and marketplace security.

Detect and prevent:
- Transaction anomalies and suspicious patterns
- Fake reviews and review manipulation
- Account takeover attempts
- Vendor verification issues
- Payment fraud patterns (chargebacks, stolen cards)
- Bot activity and automated spam
- Multiple account abuse
- Velocity checks and behavioral anomalies

Provide risk scores (0.0-1.0) with detailed reasoning and recommended actions:
- 0.0-0.3: Low risk (allow)
- 0.4-0.7: Medium risk (review/alert)
- 0.8-1.0: High risk (block/investigate)

Be precise and explain your confidence level for each assessment.`
      },
      // 4. Customer success - churn prediction and lifecycle management
      customer_success: {
        model: "anthropic/claude-3-sonnet",
        temperature: 0.6,
        maxTokens: 3500,
        systemPrompt: `You are a customer success strategist specializing in predicting and preventing churn in marketplace platforms.

Analyze and predict:
- Churn risk based on behavioral patterns (purchase frequency, engagement, support tickets)
- Upsell and cross-sell opportunities
- Customer satisfaction scores and NPS prediction
- Support ticket prioritization by urgency and impact
- Lifetime value (CLV) projections
- Personalized engagement strategies
- Win-back campaign recommendations
- Product recommendation strategies

Provide actionable insights with confidence intervals (90%, 95%, 99%) and expected outcomes. Include specific intervention strategies ranked by expected ROI.`
      },
      // 5. Spotlight curation - community engagement and voting optimization
      spotlight_curate: {
        model: "openai/gpt-4-turbo",
        temperature: 0.5,
        maxTokens: 3e3,
        systemPrompt: `You are a community engagement specialist for Florida Local Elite's Spotlight feature.

Curate and optimize:
- Business performance scoring for Spotlight eligibility
- Candidate selection based on multiple factors (ratings, reviews, engagement, diversity)
- Engagement prediction and vote forecasting
- Voting pattern analysis for fairness and fraud detection
- Community sentiment tracking
- Winner rotation strategy to ensure variety
- Geographic distribution across Florida regions
- Category diversity to showcase different business types

Ensure fair, engaging, and high-quality Spotlight selections that maximize community participation and business exposure. Consider Florida's regional diversity (Panhandle, Central, South Florida, Keys).`
      },
      // 6. Product intelligence - recommendations and discovery
      product_intelligence: {
        model: "anthropic/claude-3.5-sonnet",
        temperature: 0.6,
        maxTokens: 3500,
        systemPrompt: `You are a product recommendation expert specializing in personalization and discovery for local marketplaces.

Analyze and recommend:
- Personalized product recommendations based on browsing and purchase history
- Similar product suggestions and alternatives
- Complementary product bundles ("customers also bought")
- Trending products by category and region
- Seasonal product recommendations
- Price point optimization for conversions
- Product description quality scoring
- Image quality and completeness analysis
- Category and tag optimization

Generate recommendations with relevance scores (0-100) and explain the reasoning. Focus on increasing discovery, cross-sell, and customer satisfaction.`
      },
      // 7. Vendor coaching - business growth and performance optimization
      vendor_coach: {
        model: "anthropic/claude-3.5-sonnet",
        temperature: 0.7,
        maxTokens: 4e3,
        systemPrompt: `You are a business coach for Florida local vendors selling on the marketplace platform.

Coach vendors on:
- Product listing optimization (titles, descriptions, images, pricing)
- Inventory management best practices
- Customer service excellence and response times
- Marketing and promotion strategies
- Fulfillment and shipping optimization
- Review management and reputation building
- Competitive positioning in their category
- Growth opportunities and expansion strategies
- Seasonal planning and demand forecasting
- Platform feature utilization

Provide personalized, actionable coaching advice with specific examples and step-by-step action plans. Be encouraging but honest about areas for improvement. Include success metrics to track progress.`
      },
      // 8. Inventory optimization - demand forecasting and stock management
      inventory_optimize: {
        model: "openai/gpt-4-turbo",
        temperature: 0.3,
        maxTokens: 3e3,
        systemPrompt: `You are an inventory optimization specialist with expertise in demand forecasting and supply chain management.

Optimize inventory levels by analyzing:
- Historical sales patterns and seasonality
- Current stock levels and turnover rates
- Lead times and reorder points
- Demand forecasting using multiple methods
- Stockout risk and overstock prevention
- ABC analysis for inventory prioritization
- Safety stock calculations
- Florida-specific factors (tourism seasons, weather events, snowbird patterns)
- Category trends and product lifecycles

Provide specific recommendations:
- Reorder quantities and timing
- Safety stock levels
- Slow-moving inventory strategies
- Demand surge preparations
- Cost optimization opportunities

Include confidence levels and expected impact on stockouts, carrying costs, and revenue.`
      }
    };
    AIAgentOrchestrator = class {
      constructor() {
        this.taskQueue = [];
        this.processingTasks = /* @__PURE__ */ new Set();
        this.maxConcurrent = 3;
        this.isProcessing = false;
      }
      /**
       * Add task to queue
       */
      async addTask(type, data, priority = "medium") {
        const task = {
          id: `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type,
          priority,
          data,
          status: "pending",
          createdAt: /* @__PURE__ */ new Date(),
          retries: 0,
          maxRetries: 3
        };
        const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        const insertIndex = this.taskQueue.findIndex(
          (t) => priorityOrder[t.priority] > priorityOrder[priority]
        );
        if (insertIndex === -1) {
          this.taskQueue.push(task);
        } else {
          this.taskQueue.splice(insertIndex, 0, task);
        }
        console.log(`\u{1F916} AI Task queued: ${task.id} (${type}) - Priority: ${priority}`);
        if (!this.isProcessing) {
          this.processQueue();
        }
        return task.id;
      }
      /**
       * Get task status
       */
      getTaskStatus(taskId) {
        return this.taskQueue.find((t) => t.id === taskId) || null;
      }
      /**
       * Process task queue
       */
      async processQueue() {
        if (this.isProcessing) return;
        this.isProcessing = true;
        while (this.taskQueue.length > 0 && this.processingTasks.size < this.maxConcurrent) {
          const task = this.taskQueue.find(
            (t) => t.status === "pending" && !this.processingTasks.has(t.id)
          );
          if (!task) break;
          this.processingTasks.add(task.id);
          task.status = "processing";
          this.processTask(task).then((result) => {
            task.status = "completed";
            task.result = result;
            task.completedAt = /* @__PURE__ */ new Date();
            console.log(`\u2705 AI Task completed: ${task.id}`);
          }).catch((error) => {
            console.error(`\u274C AI Task failed: ${task.id}`, error);
            if (task.retries < task.maxRetries) {
              task.retries++;
              task.status = "pending";
              console.log(`\u{1F504} Retrying AI Task: ${task.id} (Attempt ${task.retries}/${task.maxRetries})`);
            } else {
              task.status = "failed";
              task.error = error.message;
              task.completedAt = /* @__PURE__ */ new Date();
            }
          }).finally(() => {
            this.processingTasks.delete(task.id);
            if (this.taskQueue.some((t) => t.status === "pending")) {
              this.processQueue();
            } else {
              this.isProcessing = false;
            }
          });
        }
        if (this.taskQueue.length === 0) {
          this.isProcessing = false;
        }
      }
      /**
       * Process individual task
       */
      async processTask(task) {
        const config2 = AGENT_CONFIGS[task.type];
        if (!config2) {
          throw new Error(`Unknown task type: ${task.type}`);
        }
        try {
          const result = await this.executeAgent(config2, task);
          return result;
        } catch (error) {
          console.error(`Agent execution error for ${task.type}:`, error);
          throw error;
        }
      }
      /**
       * Execute AI agent with OpenRouter
       */
      async executeAgent(config2, task) {
        try {
          const userPrompt = this.buildPrompt(task);
          console.log(`\u{1F916} Executing AI agent: ${task.type} with model ${config2.model}`);
          const completion = await exportedOpenAI.chat.completions.create({
            model: config2.model,
            messages: [
              { role: "system", content: config2.systemPrompt },
              { role: "user", content: userPrompt }
            ],
            temperature: config2.temperature,
            max_tokens: config2.maxTokens
          });
          const response = completion.choices[0]?.message?.content;
          if (!response) {
            throw new Error("No response from AI agent");
          }
          return this.parseResponse(task.type, response);
        } catch (error) {
          console.error(`AI agent execution failed:`, error);
          throw new Error(`AI agent failed: ${error.message}`);
        }
      }
      /**
       * Build prompt based on task type
       */
      buildPrompt(task) {
        switch (task.type) {
          case "campaign_optimize":
            return `Analyze this email campaign and provide optimization recommendations:

Campaign Details:
- Subject: ${task.data.subject}
- Content Preview: ${task.data.content?.substring(0, 500)}...
- Target Audience: ${task.data.targetAudience || "General customers"}
- Current Metrics: Open Rate: ${task.data.openRate || "N/A"}, Click Rate: ${task.data.clickRate || "N/A"}

Provide:
1. Subject line improvements (3 variations)
2. Content structure recommendations
3. Call-to-action optimization
4. Personalization opportunities
5. Expected impact on key metrics

Format as JSON with: { recommendations: [...], expectedImpact: {...}, subjectVariations: [...] }`;
          case "content_generate":
            return `Generate compelling email content for this campaign:

Campaign Type: ${task.data.campaignType || "promotional"}
Audience: ${task.data.audience || "customers"}
Goal: ${task.data.goal || "engagement"}
Tone: ${task.data.tone || "professional and friendly"}
Product/Service: ${task.data.product || "N/A"}
Key Offer: ${task.data.offer || "N/A"}

Generate:
1. 3 subject line options (45-50 characters each)
2. Email body content (300-500 words)
3. 2 call-to-action variations
4. Preheader text (100 characters)

Format as JSON with: { subjectLines: [...], emailBody: "...", ctas: [...], preheader: "..." }`;
          case "segment_analyze":
            return `Analyze this customer segment and provide insights:

Segment Data:
- Total Members: ${task.data.memberCount}
- Rules: ${JSON.stringify(task.data.rules)}
- Historical Performance: ${JSON.stringify(task.data.performance || {})}

Analyze:
1. Segment quality and targeting effectiveness
2. Predicted lifetime value
3. Churn risk assessment
4. Cross-sell/upsell opportunities
5. Engagement optimization strategies

Format as JSON with: { quality: {...}, ltv: {...}, churnRisk: {...}, opportunities: [...], recommendations: [...] }`;
          case "subject_test":
            return `Generate A/B test subject line variations for this campaign:

Original Subject: ${task.data.subject}
Campaign Goal: ${task.data.goal || "clicks"}
Audience Profile: ${task.data.audienceProfile || "general"}

Generate 6 variations testing:
1. Urgency vs. Value
2. Curiosity vs. Clarity
3. Personalization vs. Generic
4. Emoji vs. Text-only
5. Question vs. Statement
6. Short vs. Medium length

For each variation, provide:
- The subject line
- Psychological principle tested
- Expected performance
- Best audience segment

Format as JSON: { variations: [{ subject: "...", principle: "...", expectedLift: "...", bestFor: "..." }, ...] }`;
          case "send_time_optimize":
            return `Analyze historical data and recommend optimal send times:

Historical Data:
${JSON.stringify(task.data.historicalData || {})}

Audience Profile:
- Industry: ${task.data.industry || "Mixed"}
- Demographics: ${JSON.stringify(task.data.demographics || {})}
- Time Zones: ${JSON.stringify(task.data.timeZones || {})}

Provide:
1. Optimal day of week
2. Optimal time of day (per timezone)
3. Expected engagement lift
4. Confidence score
5. Alternative send times

Format as JSON: { optimal: { day: "...", time: "...", timezone: "..." }, expectedLift: "...", confidence: "...", alternatives: [...] }`;
          case "workflow_generate":
            return `Design a marketing automation workflow:

Workflow Goal: ${task.data.goal}
Trigger Event: ${task.data.trigger}
Target Audience: ${task.data.audience}
Campaign Type: ${task.data.campaignType || "nurture"}

Design a workflow with:
1. Trigger configuration
2. 5-7 sequential steps
3. Conditional branching based on engagement
4. Optimal timing between steps
5. Exit criteria

Format as JSON: { workflow: { trigger: {...}, steps: [...], branches: [...] }, expectedResults: {...} }`;
          case "form_optimize":
            return `Analyze and optimize this lead capture form:

Current Form:
Fields: ${JSON.stringify(task.data.fields)}
Conversion Rate: ${task.data.conversionRate || "N/A"}
Drop-off Point: ${task.data.dropOffPoint || "N/A"}

Provide:
1. Field reduction recommendations
2. Field order optimization
3. Label and placeholder improvements
4. Button copy optimization
5. Trust signal suggestions
6. Expected conversion lift

Format as JSON: { optimizedFields: [...], improvements: [...], expectedLift: "...", reasoning: "..." }`;
          // ========================================
          // MARKETPLACE AGENTS
          // ========================================
          case "marketplace_optimize":
            return `Analyze this Florida marketplace data and provide optimization recommendations:

Business/Product Data:
- Business ID: ${task.data.businessId}
- Products: ${JSON.stringify(task.data.products || [])}
- Category: ${task.data.category || "General"}
- Region: ${task.data.region || "Florida (all regions)"}
- Current Performance: ${JSON.stringify(task.data.performance || {})}
- Competitors: ${JSON.stringify(task.data.competitors || [])}

Analyze and provide:
1. Pricing competitiveness analysis (confidence score 0-100)
2. Category performance trends
3. Seasonal demand forecast (consider FL tourism, weather, snowbirds)
4. Inventory recommendations
5. Regional pricing strategies
6. Expected impact of changes

Format as JSON: { pricing: {...}, categoryTrends: {...}, forecast: {...}, inventory: {...}, recommendations: [...], confidenceScore: 0-100 }`;
          case "gmb_orchestrate":
            return `Analyze this Google My Business data and provide optimization strategies:

GMB Profile:
- Business ID: ${task.data.businessId}
- Business Name: ${task.data.businessName}
- Current GMB Status: ${task.data.gmbStatus || "unknown"}
- Recent Reviews: ${JSON.stringify(task.data.recentReviews || [])}
- Current Hours: ${JSON.stringify(task.data.businessHours || {})}
- Post History: ${JSON.stringify(task.data.postHistory || [])}
- Competitor Data: ${JSON.stringify(task.data.competitors || [])}

Provide:
1. GMB health check and sync status
2. Review sentiment analysis and response templates
3. Optimal business hours based on traffic patterns
4. Post scheduling recommendations
5. Local SEO improvement strategies
6. Competitive positioning analysis
7. ROI projections for optimizations

Format as JSON: { health: {...}, sentiment: {...}, hours: {...}, postSchedule: [...], seoStrategies: [...], roi: {...} }`;
          case "fraud_detect":
            return `Analyze this transaction/activity for fraud indicators:

Transaction Details:
- User ID: ${task.data.userId}
- Transaction Amount: ${task.data.amount || "N/A"}
- Transaction Type: ${task.data.type || "purchase"}
- IP Address: ${task.data.ipAddress || "unknown"}
- Device Info: ${JSON.stringify(task.data.deviceInfo || {})}
- Account Age: ${task.data.accountAge || "unknown"}
- Recent Activity: ${JSON.stringify(task.data.recentActivity || [])}
- Historical Patterns: ${JSON.stringify(task.data.historicalPatterns || {})}

Check for:
1. Transaction anomalies
2. Fake review patterns (if applicable)
3. Account takeover indicators
4. Payment fraud signals
5. Bot/automated activity
6. Velocity checks

Provide risk score (0.0-1.0) with detailed reasoning:
- 0.0-0.3: Low risk (allow)
- 0.4-0.7: Medium risk (review/alert)
- 0.8-1.0: High risk (block/investigate)

Format as JSON: { riskScore: 0.0-1.0, confidence: 0-100, indicators: [...], recommendation: "allow|review|block", reasoning: "..." }`;
          case "customer_success":
            return `Analyze this customer and predict success metrics:

Customer Profile:
- User ID: ${task.data.userId}
- Account Age: ${task.data.accountAge || "unknown"}
- Purchase History: ${JSON.stringify(task.data.purchaseHistory || [])}
- Engagement Metrics: ${JSON.stringify(task.data.engagement || {})}
- Support Tickets: ${JSON.stringify(task.data.supportTickets || [])}
- Last Activity: ${task.data.lastActivity || "unknown"}
- Current Tier: ${task.data.tier || "standard"}

Analyze and predict:
1. Churn risk probability (0-100)
2. Lifetime value projection
3. Upsell/cross-sell opportunities
4. Satisfaction score prediction
5. Support ticket prioritization
6. Personalized engagement strategies
7. Win-back campaign recommendations (if needed)

Format as JSON: { churnRisk: 0-100, clv: {...}, opportunities: [...], satisfaction: 0-100, interventions: [...], confidence: "90%|95%|99%" }`;
          case "spotlight_curate":
            return `Analyze and curate businesses for Spotlight feature:

Spotlight Context:
- Period: ${task.data.period || "monthly"}
- Region: ${task.data.region || "Florida (all regions)"}
- Candidate Businesses: ${JSON.stringify(task.data.candidates || [])}
- Current Spotlight: ${JSON.stringify(task.data.currentSpotlight || {})}
- Voting History: ${JSON.stringify(task.data.votingHistory || [])}
- Community Sentiment: ${JSON.stringify(task.data.sentiment || {})}

Curate based on:
1. Performance scoring (ratings, reviews, engagement)
2. Eligibility and diversity (region, category, previous wins)
3. Vote forecast and engagement prediction
4. Voting pattern fairness analysis
5. Geographic distribution across FL regions
6. Winner rotation strategy

Provide:
- Top candidates ranked by score
- Engagement predictions
- Fraud detection in voting
- Diversity recommendations

Format as JSON: { topCandidates: [...], predictions: {...}, fairnessScore: 0-100, diversityAnalysis: {...}, recommendations: [...] }`;
          case "product_intelligence":
            return `Generate product recommendations and intelligence:

Context:
- User ID: ${task.data.userId}
- Browsing History: ${JSON.stringify(task.data.browsingHistory || [])}
- Purchase History: ${JSON.stringify(task.data.purchaseHistory || [])}
- Cart Items: ${JSON.stringify(task.data.cartItems || [])}
- Current Product: ${JSON.stringify(task.data.currentProduct || {})}
- User Preferences: ${JSON.stringify(task.data.preferences || {})}
- Region: ${task.data.region || "Florida"}
- Season: ${task.data.season || "current"}

Generate:
1. Personalized product recommendations (relevance score 0-100)
2. Similar product alternatives
3. Complementary products ("also bought")
4. Trending products in category/region
5. Seasonal recommendations
6. Bundle opportunities
7. Product quality scoring

Format as JSON: { recommendations: [{ productId, score, reasoning }], similar: [...], complementary: [...], trending: [...], bundles: [...] }`;
          case "vendor_coach":
            return `Provide coaching and optimization advice for this vendor:

Vendor Profile:
- Business ID: ${task.data.businessId}
- Business Name: ${task.data.businessName}
- Products Listed: ${task.data.productCount || 0}
- Sales Performance: ${JSON.stringify(task.data.performance || {})}
- Customer Reviews: ${JSON.stringify(task.data.reviews || [])}
- Inventory Status: ${JSON.stringify(task.data.inventory || {})}
- Response Time: ${task.data.responseTime || "unknown"}
- Platform Tenure: ${task.data.tenure || "unknown"}

Coach on:
1. Product listing optimization (titles, descriptions, images, pricing)
2. Inventory management improvements
3. Customer service excellence
4. Marketing and promotion strategies
5. Fulfillment optimization
6. Review management and reputation
7. Competitive positioning
8. Growth opportunities

Provide personalized, actionable advice with:
- Specific examples
- Step-by-step action plans
- Success metrics to track
- Expected impact of changes

Format as JSON: { priorities: [...], actionPlans: [...], metrics: {...}, expectedImpact: {...}, encouragement: "..." }`;
          case "inventory_optimize":
            return `Analyze inventory and provide optimization recommendations:

Inventory Data:
- Business ID: ${task.data.businessId}
- Products: ${JSON.stringify(task.data.products || [])}
- Current Stock Levels: ${JSON.stringify(task.data.stockLevels || {})}
- Sales History: ${JSON.stringify(task.data.salesHistory || [])}
- Lead Times: ${JSON.stringify(task.data.leadTimes || {})}
- Seasonal Patterns: ${JSON.stringify(task.data.seasonalPatterns || {})}
- Region: ${task.data.region || "Florida"}
- Category: ${task.data.category || "General"}

Analyze and recommend:
1. Demand forecast by product (consider FL seasons, tourism, weather)
2. Reorder points and quantities
3. Safety stock calculations
4. Stockout risk assessment
5. Overstock prevention
6. ABC classification
7. Slow-moving inventory strategies
8. Cost optimization opportunities

Provide specific recommendations with confidence levels:
- When to reorder (timing)
- How much to reorder (quantity)
- Safety stock levels
- Expected impact on stockouts, costs, and revenue

Format as JSON: { forecast: {...}, reorderRecommendations: [...], safetyStock: {...}, risks: {...}, opportunities: [...], confidence: "high|medium|low" }`;
          default:
            throw new Error(`Unknown task type: ${task.type}`);
        }
      }
      /**
       * Parse AI response based on task type
       */
      parseResponse(taskType, response) {
        try {
          const jsonMatch = response.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            return JSON.parse(jsonMatch[0]);
          }
          return { rawResponse: response };
        } catch (error) {
          console.error("Failed to parse AI response:", error);
          return { rawResponse: response };
        }
      }
      /**
       * Clean up completed tasks (older than 1 hour)
       */
      cleanupTasks() {
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1e3);
        this.taskQueue = this.taskQueue.filter(
          (task) => task.status === "pending" || task.status === "processing" || task.completedAt && task.completedAt > oneHourAgo
        );
        console.log(`\u{1F9F9} Cleaned up old tasks. Queue size: ${this.taskQueue.length}`);
      }
      /**
       * Get queue statistics
       */
      getStats() {
        return {
          total: this.taskQueue.length,
          pending: this.taskQueue.filter((t) => t.status === "pending").length,
          processing: this.taskQueue.filter((t) => t.status === "processing").length,
          completed: this.taskQueue.filter((t) => t.status === "completed").length,
          failed: this.taskQueue.filter((t) => t.status === "failed").length
        };
      }
    };
    aiAgentOrchestrator = new AIAgentOrchestrator();
    setInterval(() => {
      aiAgentOrchestrator.cleanupTasks();
    }, 60 * 60 * 1e3);
  }
});

// server/errorHandler.ts
var errorHandler_exports = {};
__export(errorHandler_exports, {
  ApiResponse: () => ApiResponse2,
  ErrorCategory: () => ErrorCategory,
  ErrorSeverity: () => ErrorSeverity,
  OperationalError: () => OperationalError,
  aiServiceCircuitBreaker: () => aiServiceCircuitBreaker,
  asyncHandler: () => asyncHandler2,
  auditLogger: () => auditLogger,
  emailServiceCircuitBreaker: () => emailServiceCircuitBreaker,
  errorHandlerMiddleware: () => errorHandlerMiddleware,
  errorLogger: () => errorLogger,
  healthChecker: () => healthChecker,
  performanceMiddleware: () => performanceMiddleware,
  performanceMonitor: () => performanceMonitor,
  retryOperation: () => retryOperation,
  smsServiceCircuitBreaker: () => smsServiceCircuitBreaker,
  standardErrorMiddleware: () => standardErrorMiddleware
});
import * as Sentry3 from "@sentry/node";
function performanceMiddleware(req, res, next) {
  const startTime = Date.now();
  res.on("finish", () => {
    const duration = Date.now() - startTime;
    const route = `${req.method} ${req.route?.path || req.path}`;
    performanceMonitor.recordMetric(`request.${route}`, duration);
    performanceMonitor.recordMetric(`request.all`, duration);
    if (duration > 1e3) {
      console.warn(`\u23F1\uFE0F  Slow request: ${route} took ${duration}ms`);
    }
  });
  next();
}
function errorHandlerMiddleware(err, req, res, next) {
  const requestId = req.headers["x-request-id"] || `req-${Date.now()}`;
  let appError;
  if ("isOperational" in err) {
    appError = err;
  } else {
    appError = new OperationalError(
      err.message || "Internal server error",
      500,
      "internal" /* INTERNAL */,
      "high" /* HIGH */
    );
  }
  appError.userId = req.user?.id;
  appError.requestId = requestId;
  appError.context = {
    ...appError.context,
    method: req.method,
    path: req.path,
    query: req.query,
    body: req.body,
    ip: req.ip,
    userAgent: req.headers["user-agent"]
  };
  errorLogger.log(appError);
  auditLogger.log({
    userId: appError.userId,
    action: req.method,
    resource: req.path,
    result: "failure",
    errorMessage: appError.message,
    ipAddress: req.ip,
    userAgent: req.headers["user-agent"]
  });
  const response = {
    error: {
      message: appError.isOperational ? appError.message : "An unexpected error occurred",
      code: appError.category,
      requestId,
      ...process.env.NODE_ENV === "development" && {
        stack: appError.stack,
        context: appError.context
      }
    }
  };
  res.status(appError.statusCode).json(response);
}
function asyncHandler2(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}
async function retryOperation(operation, maxRetries = 3, delayMs = 1e3, backoffMultiplier = 2) {
  let lastError;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      if (error.statusCode && error.statusCode < 500) {
        throw error;
      }
      if (attempt < maxRetries) {
        const delay = delayMs * Math.pow(backoffMultiplier, attempt - 1);
        console.log(`\u23F3 Retrying operation in ${delay}ms (attempt ${attempt}/${maxRetries})`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }
  throw lastError;
}
function standardErrorMiddleware(err, req, res, next) {
  if (res.headersSent) {
    return next(err);
  }
  if (err.name === "ZodError") {
    const zodError = err;
    return ApiResponse2.zodValidation(res, zodError.errors, req);
  }
  if ("isOperational" in err && err.isOperational) {
    const appError = err;
    return ApiResponse2.error(
      res,
      appError.statusCode,
      appError.category,
      appError.message,
      appError.context,
      req
    );
  }
  return ApiResponse2.internal(res, err, req);
}
var ErrorSeverity, ErrorCategory, OperationalError, ErrorLogger, errorLogger, AuditLogger, auditLogger, PerformanceMonitor, performanceMonitor, CircuitBreaker2, emailServiceCircuitBreaker, smsServiceCircuitBreaker, aiServiceCircuitBreaker, HealthChecker, healthChecker, ApiResponse2;
var init_errorHandler = __esm({
  "server/errorHandler.ts"() {
    "use strict";
    ErrorSeverity = /* @__PURE__ */ ((ErrorSeverity2) => {
      ErrorSeverity2["LOW"] = "low";
      ErrorSeverity2["MEDIUM"] = "medium";
      ErrorSeverity2["HIGH"] = "high";
      ErrorSeverity2["CRITICAL"] = "critical";
      return ErrorSeverity2;
    })(ErrorSeverity || {});
    ErrorCategory = /* @__PURE__ */ ((ErrorCategory2) => {
      ErrorCategory2["VALIDATION"] = "validation";
      ErrorCategory2["AUTHENTICATION"] = "authentication";
      ErrorCategory2["AUTHORIZATION"] = "authorization";
      ErrorCategory2["NOT_FOUND"] = "not_found";
      ErrorCategory2["DATABASE"] = "database";
      ErrorCategory2["EXTERNAL_API"] = "external_api";
      ErrorCategory2["RATE_LIMIT"] = "rate_limit";
      ErrorCategory2["INTERNAL"] = "internal";
      ErrorCategory2["AI_SERVICE"] = "ai_service";
      ErrorCategory2["EMAIL_SERVICE"] = "email_service";
      ErrorCategory2["SMS_SERVICE"] = "sms_service";
      return ErrorCategory2;
    })(ErrorCategory || {});
    OperationalError = class extends Error {
      constructor(message, statusCode = 500, category = "internal" /* INTERNAL */, severity = "medium" /* MEDIUM */, context) {
        super(message);
        this.isOperational = true;
        this.name = "OperationalError";
        this.statusCode = statusCode;
        this.category = category;
        this.severity = severity;
        this.context = context;
        this.timestamp = /* @__PURE__ */ new Date();
        Error.captureStackTrace(this, this.constructor);
      }
    };
    ErrorLogger = class {
      constructor() {
        this.errorLog = [];
        this.maxLogSize = 1e3;
      }
      log(error) {
        this.errorLog.push(error);
        if (this.errorLog.length > this.maxLogSize) {
          this.errorLog = this.errorLog.slice(-this.maxLogSize);
        }
        const logData = {
          timestamp: error.timestamp.toISOString(),
          severity: error.severity,
          category: error.category,
          message: error.message,
          statusCode: error.statusCode,
          userId: error.userId,
          requestId: error.requestId,
          context: error.context,
          stack: error.stack
        };
        switch (error.severity) {
          case "critical" /* CRITICAL */:
            console.error("\u{1F6A8} CRITICAL ERROR:", logData);
            this.sendAlert(error);
            break;
          case "high" /* HIGH */:
            console.error("\u274C HIGH SEVERITY ERROR:", logData);
            break;
          case "medium" /* MEDIUM */:
            console.warn("\u26A0\uFE0F  MEDIUM SEVERITY ERROR:", logData);
            break;
          case "low" /* LOW */:
            console.info("\u2139\uFE0F  LOW SEVERITY ERROR:", logData);
            break;
        }
        if (process.env.NODE_ENV === "production") {
          this.sendToMonitoringService(error);
        }
      }
      async sendAlert(error) {
        console.log("\u{1F4E7} Sending alert for critical error:", error.message);
        if (process.env.SLACK_WEBHOOK_URL) {
          try {
            await this.sendSlackAlert(error);
          } catch (slackError) {
            console.error("Failed to send Slack alert:", slackError);
          }
        }
      }
      async sendSlackAlert(error) {
        const payload = {
          text: `\u{1F6A8} CRITICAL ERROR ALERT`,
          blocks: [
            {
              type: "header",
              text: {
                type: "plain_text",
                text: "\u{1F6A8} Critical Error Detected",
                emoji: true
              }
            },
            {
              type: "section",
              fields: [
                {
                  type: "mrkdwn",
                  text: `*Error:*
${error.message}`
                },
                {
                  type: "mrkdwn",
                  text: `*Category:*
${error.category}`
                },
                {
                  type: "mrkdwn",
                  text: `*User ID:*
${error.userId || "N/A"}`
                },
                {
                  type: "mrkdwn",
                  text: `*Request ID:*
${error.requestId || "N/A"}`
                },
                {
                  type: "mrkdwn",
                  text: `*Timestamp:*
${error.timestamp.toISOString()}`
                },
                {
                  type: "mrkdwn",
                  text: `*Environment:*
${process.env.NODE_ENV || "unknown"}`
                }
              ]
            },
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `*Stack Trace:*
\`\`\`${error.stack?.substring(0, 500) || "N/A"}\`\`\``
              }
            }
          ]
        };
        const response = await fetch(process.env.SLACK_WEBHOOK_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
          throw new Error(`Slack webhook failed: ${response.statusText}`);
        }
      }
      sendToMonitoringService(error) {
        Sentry3.withScope((scope) => {
          if (error.userId) {
            scope.setUser({ id: error.userId });
          }
          scope.setTag("error_category", error.category);
          scope.setTag("error_severity", error.severity);
          scope.setTag("status_code", error.statusCode.toString());
          scope.setContext("error_details", {
            category: error.category,
            severity: error.severity,
            statusCode: error.statusCode,
            requestId: error.requestId,
            timestamp: error.timestamp.toISOString(),
            isOperational: error.isOperational
          });
          if (error.context) {
            scope.setContext("request_context", error.context);
          }
          scope.setFingerprint([
            error.category,
            error.message.substring(0, 100)
          ]);
          Sentry3.captureException(error);
        });
      }
      getRecentErrors(limit = 100) {
        return this.errorLog.slice(-limit);
      }
      getErrorsByCategory(category) {
        return this.errorLog.filter((e) => e.category === category);
      }
      getErrorsBySeverity(severity) {
        return this.errorLog.filter((e) => e.severity === severity);
      }
      clearLog() {
        this.errorLog = [];
      }
      getStats() {
        return {
          total: this.errorLog.length,
          bySeverity: {
            ["low" /* LOW */]: this.errorLog.filter((e) => e.severity === "low" /* LOW */).length,
            ["medium" /* MEDIUM */]: this.errorLog.filter((e) => e.severity === "medium" /* MEDIUM */).length,
            ["high" /* HIGH */]: this.errorLog.filter((e) => e.severity === "high" /* HIGH */).length,
            ["critical" /* CRITICAL */]: this.errorLog.filter((e) => e.severity === "critical" /* CRITICAL */).length
          },
          byCategory: Object.values(ErrorCategory).reduce((acc, cat) => {
            acc[cat] = this.errorLog.filter((e) => e.category === cat).length;
            return acc;
          }, {})
        };
      }
    };
    errorLogger = new ErrorLogger();
    AuditLogger = class {
      constructor() {
        this.auditLog = [];
        this.maxLogSize = 5e3;
      }
      log(entry) {
        const auditEntry = {
          id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          timestamp: /* @__PURE__ */ new Date(),
          ...entry
        };
        this.auditLog.push(auditEntry);
        if (this.auditLog.length > this.maxLogSize) {
          this.auditLog = this.auditLog.slice(-this.maxLogSize);
        }
        if (process.env.NODE_ENV === "development") {
          console.log("\u{1F4DD} Audit:", auditEntry);
        }
        if (process.env.NODE_ENV === "production") {
          this.persistToDatabase(auditEntry);
        }
      }
      persistToDatabase(entry) {
      }
      getRecentAudits(limit = 100) {
        return this.auditLog.slice(-limit);
      }
      getAuditsByUser(userId) {
        return this.auditLog.filter((e) => e.userId === userId);
      }
      getAuditsByResource(resource, resourceId) {
        return this.auditLog.filter(
          (e) => e.resource === resource && (!resourceId || e.resourceId === resourceId)
        );
      }
      clearLog() {
        this.auditLog = [];
      }
    };
    auditLogger = new AuditLogger();
    PerformanceMonitor = class {
      constructor() {
        this.metrics = /* @__PURE__ */ new Map();
      }
      recordMetric(name, value) {
        const existing = this.metrics.get(name) || [];
        existing.push(value);
        if (existing.length > 1e3) {
          existing.shift();
        }
        this.metrics.set(name, existing);
      }
      getStats(name) {
        const values = this.metrics.get(name);
        if (!values || values.length === 0) return null;
        const sorted = [...values].sort((a, b) => a - b);
        return {
          count: values.length,
          avg: values.reduce((a, b) => a + b, 0) / values.length,
          min: sorted[0],
          max: sorted[sorted.length - 1],
          p50: sorted[Math.floor(sorted.length * 0.5)],
          p95: sorted[Math.floor(sorted.length * 0.95)],
          p99: sorted[Math.floor(sorted.length * 0.99)]
        };
      }
      getAllStats() {
        const stats = {};
        for (const [name, _] of this.metrics) {
          stats[name] = this.getStats(name);
        }
        return stats;
      }
      clearMetrics() {
        this.metrics.clear();
      }
    };
    performanceMonitor = new PerformanceMonitor();
    CircuitBreaker2 = class {
      constructor(threshold = 5, timeout = 6e4) {
        this.failures = 0;
        this.state = "closed";
        this.threshold = threshold;
        this.timeout = timeout;
      }
      async execute(operation) {
        if (this.state === "open") {
          if (Date.now() - this.lastFailureTime.getTime() > this.timeout) {
            this.state = "half-open";
            console.log("\u{1F504} Circuit breaker: half-open state");
          } else {
            throw new OperationalError(
              "Service temporarily unavailable",
              503,
              "external_api" /* EXTERNAL_API */,
              "high" /* HIGH */
            );
          }
        }
        try {
          const result = await operation();
          if (this.state === "half-open") {
            this.reset();
          }
          return result;
        } catch (error) {
          this.recordFailure();
          throw error;
        }
      }
      recordFailure() {
        this.failures++;
        this.lastFailureTime = /* @__PURE__ */ new Date();
        if (this.failures >= this.threshold) {
          this.state = "open";
          console.error(`\u26D4 Circuit breaker opened after ${this.failures} failures`);
        }
      }
      reset() {
        this.failures = 0;
        this.state = "closed";
        console.log("\u2705 Circuit breaker reset to closed state");
      }
      getState() {
        return {
          state: this.state,
          failures: this.failures
        };
      }
    };
    emailServiceCircuitBreaker = new CircuitBreaker2(5, 6e4);
    smsServiceCircuitBreaker = new CircuitBreaker2(5, 6e4);
    aiServiceCircuitBreaker = new CircuitBreaker2(3, 3e4);
    HealthChecker = class {
      constructor() {
        this.checks = /* @__PURE__ */ new Map();
      }
      register(name, check) {
        this.checks.set(name, check);
      }
      async runChecks() {
        const results = {};
        let allHealthy = true;
        for (const [name, check] of this.checks) {
          try {
            const healthy = await Promise.race([
              check(),
              new Promise(
                (_, reject) => setTimeout(() => reject(new Error("Health check timeout")), 5e3)
              )
            ]);
            results[name] = { healthy };
            if (!healthy) allHealthy = false;
          } catch (error) {
            results[name] = { healthy: false, error: error.message };
            allHealthy = false;
          }
        }
        return { healthy: allHealthy, checks: results };
      }
    };
    healthChecker = new HealthChecker();
    ApiResponse2 = class {
      /**
       * Send a standardized error response
       */
      static error(res, statusCode, category, message, details, req) {
        const requestId = req?.headers["x-request-id"] || `req-${Date.now()}`;
        const errorResponse = {
          success: false,
          error: {
            code: category,
            message,
            details,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            path: req?.path,
            method: req?.method,
            requestId
          }
        };
        const appError = new OperationalError(
          message,
          statusCode,
          category,
          this.getSeverityFromStatus(statusCode),
          details
        );
        appError.userId = req?.user?.claims?.sub;
        appError.requestId = requestId;
        errorLogger.log(appError);
        return res.status(statusCode).json(errorResponse);
      }
      /**
       * Validation error response (400)
       */
      static validation(res, message, details, req) {
        return this.error(res, 400, "validation" /* VALIDATION */, message, details, req);
      }
      /**
       * Zod validation error response (400)
       */
      static zodValidation(res, errors, req) {
        return this.error(
          res,
          400,
          "validation" /* VALIDATION */,
          "Validation error",
          { errors },
          req
        );
      }
      /**
       * Unauthorized error response (401)
       */
      static unauthorized(res, message = "Unauthorized", req) {
        return this.error(res, 401, "authentication" /* AUTHENTICATION */, message, void 0, req);
      }
      /**
       * Forbidden error response (403)
       */
      static forbidden(res, message = "Forbidden", req) {
        return this.error(res, 403, "authorization" /* AUTHORIZATION */, message, void 0, req);
      }
      /**
       * Not found error response (404)
       */
      static notFound(res, resource, req) {
        return this.error(res, 404, "not_found" /* NOT_FOUND */, `${resource} not found`, void 0, req);
      }
      /**
       * Conflict error response (409)
       */
      static conflict(res, message, details, req) {
        return this.error(res, 409, "database" /* DATABASE */, message, details, req);
      }
      /**
       * Rate limited error response (429)
       */
      static rateLimited(res, message = "Too many requests", req) {
        return this.error(res, 429, "rate_limit" /* RATE_LIMIT */, message, void 0, req);
      }
      /**
       * Internal server error response (500)
       */
      static internal(res, error, req) {
        const message = process.env.NODE_ENV === "production" ? "An internal server error occurred" : error.message || "Internal server error";
        const details = process.env.NODE_ENV === "production" ? void 0 : { stack: error.stack };
        return this.error(res, 500, "internal" /* INTERNAL */, message, details, req);
      }
      /**
       * Database error response (500)
       */
      static database(res, error, req) {
        if (error.code === "23505" || error.constraint?.includes("unique")) {
          return this.conflict(res, "Resource already exists", { constraint: error.constraint }, req);
        }
        const message = process.env.NODE_ENV === "production" ? "Database operation failed" : error.message || "Database error";
        return this.error(res, 500, "database" /* DATABASE */, message, void 0, req);
      }
      /**
       * Service unavailable error response (503)
       */
      static serviceUnavailable(res, service, req) {
        return this.error(
          res,
          503,
          "external_api" /* EXTERNAL_API */,
          `${service} is currently unavailable`,
          void 0,
          req
        );
      }
      /**
       * Success response
       */
      static success(res, data, meta, statusCode = 200, req) {
        const response = {
          success: true,
          data,
          meta: {
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            requestId: req?.headers["x-request-id"] || void 0,
            ...meta
          }
        };
        return res.status(statusCode).json(response);
      }
      /**
       * Created response (201)
       */
      static created(res, data, req) {
        return this.success(res, data, void 0, 201, req);
      }
      /**
       * No content response (204)
       */
      static noContent(res) {
        return res.status(204).end();
      }
      /**
       * Get severity based on status code
       */
      static getSeverityFromStatus(statusCode) {
        if (statusCode >= 500) return "high" /* HIGH */;
        if (statusCode >= 400 && statusCode < 500) return "medium" /* MEDIUM */;
        return "low" /* LOW */;
      }
    };
  }
});

// server/aiMarketingRoutes.ts
var aiMarketingRoutes_exports = {};
__export(aiMarketingRoutes_exports, {
  registerAIMarketingRoutes: () => registerAIMarketingRoutes
});
import { z as z4 } from "zod";
function registerAIMarketingRoutes(app) {
  app.post(
    "/api/ai/marketing/campaign/optimize",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        campaignId: z4.string().uuid().optional(),
        subject: z4.string(),
        content: z4.string(),
        targetAudience: z4.string().optional(),
        openRate: z4.number().optional(),
        clickRate: z4.number().optional()
      });
      const data = schema.parse(req.body);
      const taskId = await aiAgentOrchestrator.addTask(
        "campaign_optimize",
        data,
        "high"
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_CAMPAIGN_OPTIMIZE",
        resource: "campaign",
        resourceId: data.campaignId,
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskId,
        message: "Campaign optimization started. Use /api/ai/tasks/:taskId to check status."
      });
    })
  );
  app.post(
    "/api/ai/marketing/content/generate",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        campaignType: z4.string(),
        audience: z4.string().optional(),
        goal: z4.string().optional(),
        tone: z4.string().optional(),
        product: z4.string().optional(),
        offer: z4.string().optional()
      });
      const data = schema.parse(req.body);
      const taskId = await aiAgentOrchestrator.addTask(
        "content_generate",
        data,
        "medium"
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_CONTENT_GENERATE",
        resource: "campaign_content",
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskId,
        message: "Content generation started. Check status with /api/ai/tasks/:taskId"
      });
    })
  );
  app.post(
    "/api/ai/marketing/subject/test",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        subject: z4.string(),
        goal: z4.string().optional(),
        audienceProfile: z4.string().optional()
      });
      const data = schema.parse(req.body);
      const taskId = await aiAgentOrchestrator.addTask(
        "subject_test",
        data,
        "medium"
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_SUBJECT_TEST",
        resource: "campaign_subject",
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskId,
        message: "Subject line variations generated. Check /api/ai/tasks/:taskId"
      });
    })
  );
  app.post(
    "/api/ai/marketing/segment/analyze",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        segmentId: z4.string().uuid(),
        memberCount: z4.number(),
        rules: z4.any(),
        performance: z4.any().optional()
      });
      const data = schema.parse(req.body);
      const taskId = await aiAgentOrchestrator.addTask(
        "segment_analyze",
        data,
        "medium"
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_SEGMENT_ANALYZE",
        resource: "segment",
        resourceId: data.segmentId,
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskId,
        message: "Segment analysis started. Check /api/ai/tasks/:taskId"
      });
    })
  );
  app.post(
    "/api/ai/marketing/sendtime/optimize",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        campaignId: z4.string().uuid().optional(),
        historicalData: z4.any().optional(),
        industry: z4.string().optional(),
        demographics: z4.any().optional(),
        timeZones: z4.any().optional()
      });
      const data = schema.parse(req.body);
      const taskId = await aiAgentOrchestrator.addTask(
        "send_time_optimize",
        data,
        "low"
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_SENDTIME_OPTIMIZE",
        resource: "campaign",
        resourceId: data.campaignId,
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskId,
        message: "Send time optimization started. Check /api/ai/tasks/:taskId"
      });
    })
  );
  app.post(
    "/api/ai/marketing/workflow/generate",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        goal: z4.string(),
        trigger: z4.string(),
        audience: z4.string(),
        campaignType: z4.string().optional()
      });
      const data = schema.parse(req.body);
      const taskId = await aiAgentOrchestrator.addTask(
        "workflow_generate",
        data,
        "medium"
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_WORKFLOW_GENERATE",
        resource: "workflow",
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskId,
        message: "Workflow generation started. Check /api/ai/tasks/:taskId"
      });
    })
  );
  app.post(
    "/api/ai/marketing/form/optimize",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        formId: z4.string().uuid().optional(),
        fields: z4.any(),
        conversionRate: z4.number().optional(),
        dropOffPoint: z4.string().optional()
      });
      const data = schema.parse(req.body);
      const taskId = await aiAgentOrchestrator.addTask(
        "form_optimize",
        data,
        "medium"
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_FORM_OPTIMIZE",
        resource: "form",
        resourceId: data.formId,
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskId,
        message: "Form optimization started. Check /api/ai/tasks/:taskId"
      });
    })
  );
  app.get(
    "/api/ai/tasks/:taskId",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const { taskId } = req.params;
      const task = aiAgentOrchestrator.getTaskStatus(taskId);
      if (!task) {
        throw new OperationalError(
          "Task not found",
          404,
          "not_found" /* NOT_FOUND */,
          "low" /* LOW */
        );
      }
      res.json({
        taskId: task.id,
        type: task.type,
        status: task.status,
        priority: task.priority,
        createdAt: task.createdAt,
        completedAt: task.completedAt,
        result: task.result,
        error: task.error,
        retries: task.retries
      });
    })
  );
  app.get(
    "/api/ai/stats",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const stats = aiAgentOrchestrator.getStats();
      res.json({
        queueStats: stats,
        timestamp: /* @__PURE__ */ new Date()
      });
    })
  );
  app.post(
    "/api/ai/marketing/campaign/bulk-optimize",
    requireAuth2,
    asyncHandler2(async (req, res) => {
      const schema = z4.object({
        campaigns: z4.array(z4.object({
          campaignId: z4.string().uuid(),
          subject: z4.string(),
          content: z4.string()
        }))
      });
      const { campaigns } = schema.parse(req.body);
      const taskIds = await Promise.all(
        campaigns.map(
          (campaign) => aiAgentOrchestrator.addTask("campaign_optimize", campaign, "medium")
        )
      );
      auditLogger.log({
        userId: req.user?.id,
        action: "AI_BULK_OPTIMIZE",
        resource: "campaigns",
        result: "success",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.json({
        success: true,
        taskIds,
        count: taskIds.length,
        message: "Bulk optimization started. Check each task with /api/ai/tasks/:taskId"
      });
    })
  );
  console.log("\u2705 AI-enhanced marketing routes registered");
}
var requireAuth2;
var init_aiMarketingRoutes = __esm({
  "server/aiMarketingRoutes.ts"() {
    "use strict";
    init_aiAgentOrchestrator();
    init_errorHandler();
    requireAuth2 = (req, res, next) => {
      if (!req.isAuthenticated || !req.isAuthenticated()) {
        throw new OperationalError(
          "Authentication required",
          401,
          "authentication" /* AUTHENTICATION */,
          "medium" /* MEDIUM */
        );
      }
      next();
    };
  }
});

// server/marketplaceAgentRoutes.ts
var marketplaceAgentRoutes_exports = {};
__export(marketplaceAgentRoutes_exports, {
  registerMarketplaceAgentRoutes: () => registerMarketplaceAgentRoutes
});
function registerMarketplaceAgentRoutes(app) {
  console.log("\u{1F916} Registering marketplace AI agent routes...");
  app.post("/api/ai/marketplace/optimize", async (req, res) => {
    try {
      const { businessId, products: products2, category, region, performance, competitors } = req.body;
      if (!businessId) {
        return res.status(400).json({ message: "Business ID is required" });
      }
      const taskId = await orchestrator.addTask("marketplace_optimize", {
        businessId,
        products: products2 || [],
        category: category || "General",
        region: region || "Florida (all regions)",
        performance: performance || {},
        competitors: competitors || []
      }, "high");
      res.json({
        message: "Marketplace optimization analysis queued",
        taskId,
        status: "pending"
      });
    } catch (error) {
      console.error("Error queuing marketplace optimization:", error);
      res.status(500).json({ message: "Failed to queue analysis", error: error.message });
    }
  });
  app.post("/api/ai/marketplace/pricing-analysis", async (req, res) => {
    try {
      const { businessId, products: products2, competitors } = req.body;
      const taskId = await orchestrator.addTask("marketplace_optimize", {
        businessId,
        products: products2,
        competitors,
        analysisType: "pricing"
      }, "medium");
      res.json({ message: "Pricing analysis queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue analysis", error: error.message });
    }
  });
  app.post("/api/ai/marketplace/demand-forecast", async (req, res) => {
    try {
      const { businessId, products: products2, category, region } = req.body;
      const taskId = await orchestrator.addTask("marketplace_optimize", {
        businessId,
        products: products2,
        category,
        region,
        analysisType: "demand_forecast"
      }, "medium");
      res.json({ message: "Demand forecast queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue forecast", error: error.message });
    }
  });
  app.post("/api/ai/gmb/optimize", async (req, res) => {
    try {
      const { businessId, businessName, gmbStatus, recentReviews, businessHours, postHistory, competitors } = req.body;
      if (!businessId) {
        return res.status(400).json({ message: "Business ID is required" });
      }
      const taskId = await orchestrator.addTask("gmb_orchestrate", {
        businessId,
        businessName,
        gmbStatus,
        recentReviews: recentReviews || [],
        businessHours: businessHours || {},
        postHistory: postHistory || [],
        competitors: competitors || []
      }, "high");
      res.json({ message: "GMB optimization queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue GMB optimization", error: error.message });
    }
  });
  app.post("/api/ai/gmb/review-sentiment", async (req, res) => {
    try {
      const { businessId, reviews: reviews2 } = req.body;
      const taskId = await orchestrator.addTask("gmb_orchestrate", {
        businessId,
        recentReviews: reviews2,
        analysisType: "sentiment"
      }, "medium");
      res.json({ message: "Review sentiment analysis queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue analysis", error: error.message });
    }
  });
  app.post("/api/ai/gmb/post-schedule", async (req, res) => {
    try {
      const { businessId, postHistory } = req.body;
      const taskId = await orchestrator.addTask("gmb_orchestrate", {
        businessId,
        postHistory,
        analysisType: "post_schedule"
      }, "low");
      res.json({ message: "Post schedule analysis queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue analysis", error: error.message });
    }
  });
  app.post("/api/ai/fraud/check-transaction", async (req, res) => {
    try {
      const { userId, amount, type, ipAddress, deviceInfo, accountAge, recentActivity, historicalPatterns } = req.body;
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const taskId = await orchestrator.addTask("fraud_detect", {
        userId,
        amount,
        type: type || "purchase",
        ipAddress,
        deviceInfo,
        accountAge,
        recentActivity: recentActivity || [],
        historicalPatterns: historicalPatterns || {}
      }, "critical");
      res.json({ message: "Fraud check queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue fraud check", error: error.message });
    }
  });
  app.post("/api/ai/fraud/verify-review", async (req, res) => {
    try {
      const { userId, reviewContent, accountAge, recentActivity } = req.body;
      const taskId = await orchestrator.addTask("fraud_detect", {
        userId,
        type: "review",
        reviewContent,
        accountAge,
        recentActivity
      }, "high");
      res.json({ message: "Review verification queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue verification", error: error.message });
    }
  });
  app.post("/api/ai/customer/churn-risk", async (req, res) => {
    try {
      const { userId, accountAge, purchaseHistory, engagement, supportTickets, lastActivity, tier } = req.body;
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const taskId = await orchestrator.addTask("customer_success", {
        userId,
        accountAge,
        purchaseHistory: purchaseHistory || [],
        engagement: engagement || {},
        supportTickets: supportTickets || [],
        lastActivity,
        tier
      }, "high");
      res.json({ message: "Churn risk analysis queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue analysis", error: error.message });
    }
  });
  app.post("/api/ai/customer/upsell-opportunities", async (req, res) => {
    try {
      const { userId, purchaseHistory, engagement } = req.body;
      const taskId = await orchestrator.addTask("customer_success", {
        userId,
        purchaseHistory,
        engagement,
        analysisType: "upsell"
      }, "medium");
      res.json({ message: "Upsell analysis queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue analysis", error: error.message });
    }
  });
  app.post("/api/ai/customer/clv-prediction", async (req, res) => {
    try {
      const { userId, purchaseHistory, engagement, accountAge } = req.body;
      const taskId = await orchestrator.addTask("customer_success", {
        userId,
        purchaseHistory,
        engagement,
        accountAge,
        analysisType: "clv"
      }, "low");
      res.json({ message: "CLV prediction queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue prediction", error: error.message });
    }
  });
  app.post("/api/ai/spotlight/curate", async (req, res) => {
    try {
      const { period, region, candidates, currentSpotlight, votingHistory, sentiment } = req.body;
      const taskId = await orchestrator.addTask("spotlight_curate", {
        period: period || "monthly",
        region: region || "Florida (all regions)",
        candidates: candidates || [],
        currentSpotlight: currentSpotlight || {},
        votingHistory: votingHistory || [],
        sentiment: sentiment || {}
      }, "high");
      res.json({ message: "Spotlight curation queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue curation", error: error.message });
    }
  });
  app.post("/api/ai/product/recommendations", async (req, res) => {
    try {
      const { userId, browsingHistory, purchaseHistory, cartItems: cartItems2, currentProduct, preferences, region, season } = req.body;
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const taskId = await orchestrator.addTask("product_intelligence", {
        userId,
        browsingHistory: browsingHistory || [],
        purchaseHistory: purchaseHistory || [],
        cartItems: cartItems2 || [],
        currentProduct: currentProduct || {},
        preferences: preferences || {},
        region: region || "Florida",
        season: season || "current"
      }, "medium");
      res.json({ message: "Product recommendations queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue recommendations", error: error.message });
    }
  });
  app.post("/api/ai/vendor/coaching", async (req, res) => {
    try {
      const { businessId, businessName, productCount, performance, reviews: reviews2, inventory, responseTime, tenure } = req.body;
      if (!businessId) {
        return res.status(400).json({ message: "Business ID is required" });
      }
      const taskId = await orchestrator.addTask("vendor_coach", {
        businessId,
        businessName,
        productCount,
        performance: performance || {},
        reviews: reviews2 || [],
        inventory: inventory || {},
        responseTime,
        tenure
      }, "medium");
      res.json({ message: "Vendor coaching queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue coaching", error: error.message });
    }
  });
  app.post("/api/ai/inventory/optimize", async (req, res) => {
    try {
      const { businessId, products: products2, stockLevels, salesHistory, leadTimes, seasonalPatterns, region, category } = req.body;
      if (!businessId) {
        return res.status(400).json({ message: "Business ID is required" });
      }
      const taskId = await orchestrator.addTask("inventory_optimize", {
        businessId,
        products: products2 || [],
        stockLevels: stockLevels || {},
        salesHistory: salesHistory || [],
        leadTimes: leadTimes || {},
        seasonalPatterns: seasonalPatterns || {},
        region: region || "Florida",
        category: category || "General"
      }, "medium");
      res.json({ message: "Inventory optimization queued", taskId });
    } catch (error) {
      res.status(500).json({ message: "Failed to queue optimization", error: error.message });
    }
  });
  app.get("/api/ai/task/:taskId", (req, res) => {
    try {
      const { taskId } = req.params;
      const task = orchestrator.getTaskStatus(taskId);
      if (!task) {
        return res.status(404).json({ message: "Task not found" });
      }
      res.json({
        id: task.id,
        type: task.type,
        status: task.status,
        priority: task.priority,
        result: task.result,
        error: task.error,
        createdAt: task.createdAt,
        completedAt: task.completedAt
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get task status", error: error.message });
    }
  });
  console.log("\u2705 Marketplace AI agent routes registered");
}
var orchestrator;
var init_marketplaceAgentRoutes = __esm({
  "server/marketplaceAgentRoutes.ts"() {
    "use strict";
    init_aiAgentOrchestrator();
    orchestrator = new AIAgentOrchestrator();
  }
});

// server/loyaltyRoutes.ts
var loyaltyRoutes_exports = {};
__export(loyaltyRoutes_exports, {
  registerLoyaltyRoutes: () => registerLoyaltyRoutes
});
function registerLoyaltyRoutes(app) {
  console.log("\u{1F48E} Registering loyalty & rewards routes...");
  app.get("/api/loyalty/account", isAuthenticated2, async (req, res) => {
    try {
      const account = await loyaltyStorage.getLoyaltyAccount(req.user.id);
      if (!account) {
        return res.status(404).json({
          message: "Loyalty account not found. Enroll to get started!"
        });
      }
      res.json(account);
    } catch (error) {
      console.error("Error fetching loyalty account:", error);
      res.status(500).json({ message: "Failed to fetch loyalty account" });
    }
  });
  app.post("/api/loyalty/account/enroll", isAuthenticated2, async (req, res) => {
    try {
      const account = await loyaltyStorage.createLoyaltyAccount(req.user.id);
      await loyaltyStorage.awardPointsForEvent(
        req.user.id,
        "signup",
        account.id
      );
      res.json({
        message: "Welcome to the loyalty program!",
        account
      });
    } catch (error) {
      console.error("Error enrolling in loyalty program:", error);
      res.status(500).json({ message: "Failed to enroll in loyalty program" });
    }
  });
  app.get("/api/loyalty/transactions", isAuthenticated2, async (req, res) => {
    try {
      const { type, limit, offset } = req.query;
      const transactions = await loyaltyStorage.getTransactions(req.user.id, {
        type,
        limit: limit ? parseInt(limit) : 50,
        offset: offset ? parseInt(offset) : 0
      });
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching transactions:", error);
      res.status(500).json({ message: "Failed to fetch transactions" });
    }
  });
  app.get(
    "/api/loyalty/transactions/summary",
    isAuthenticated2,
    async (req, res) => {
      try {
        const summary = await loyaltyStorage.getTransactionSummary(req.user.id);
        res.json(summary);
      } catch (error) {
        console.error("Error fetching transaction summary:", error);
        res.status(500).json({ message: "Failed to fetch summary" });
      }
    }
  );
  app.get("/api/loyalty/tiers", async (req, res) => {
    try {
      const tiers = await loyaltyStorage.getTiers();
      res.json(tiers);
    } catch (error) {
      console.error("Error fetching tiers:", error);
      res.status(500).json({ message: "Failed to fetch tiers" });
    }
  });
  app.get("/api/loyalty/tiers/:id", async (req, res) => {
    try {
      const tier = await loyaltyStorage.getTierById(req.params.id);
      if (!tier) {
        return res.status(404).json({ message: "Tier not found" });
      }
      res.json(tier);
    } catch (error) {
      console.error("Error fetching tier:", error);
      res.status(500).json({ message: "Failed to fetch tier" });
    }
  });
  app.get("/api/loyalty/tier/current", isAuthenticated2, async (req, res) => {
    try {
      const account = await loyaltyStorage.getLoyaltyAccount(req.user.id);
      if (!account) {
        return res.status(404).json({ message: "Loyalty account not found" });
      }
      const tier = await loyaltyStorage.getTierById(account.tierId);
      res.json(tier);
    } catch (error) {
      console.error("Error fetching current tier:", error);
      res.status(500).json({ message: "Failed to fetch current tier" });
    }
  });
  app.get("/api/loyalty/tier/progress", isAuthenticated2, async (req, res) => {
    try {
      const progress = await loyaltyStorage.getTierProgress(req.user.id);
      res.json(progress);
    } catch (error) {
      console.error("Error fetching tier progress:", error);
      res.status(500).json({ message: "Failed to fetch tier progress" });
    }
  });
  app.get("/api/loyalty/rewards", async (req, res) => {
    try {
      const { businessId, category, isFeatured, minTierLevel, limit, offset } = req.query;
      const rewards2 = await loyaltyStorage.getRewards({
        businessId,
        category,
        isFeatured: isFeatured === "true",
        minTierLevel: minTierLevel ? parseInt(minTierLevel) : void 0,
        limit: limit ? parseInt(limit) : 50,
        offset: offset ? parseInt(offset) : 0
      });
      res.json(rewards2);
    } catch (error) {
      console.error("Error fetching rewards:", error);
      res.status(500).json({ message: "Failed to fetch rewards" });
    }
  });
  app.get("/api/loyalty/rewards/:id", async (req, res) => {
    try {
      const reward = await loyaltyStorage.getRewardById(req.params.id);
      if (!reward) {
        return res.status(404).json({ message: "Reward not found" });
      }
      res.json(reward);
    } catch (error) {
      console.error("Error fetching reward:", error);
      res.status(500).json({ message: "Failed to fetch reward" });
    }
  });
  app.post(
    "/api/loyalty/rewards/:id/redeem",
    isAuthenticated2,
    async (req, res) => {
      try {
        const redemption = await loyaltyStorage.redeemReward(
          req.user.id,
          req.params.id
        );
        res.json({
          message: "Reward redeemed successfully!",
          redemption
        });
      } catch (error) {
        console.error("Error redeeming reward:", error);
        if (error.message === "Insufficient points") {
          return res.status(400).json({ message: "Not enough points" });
        }
        if (error.message === "Reward is out of stock") {
          return res.status(400).json({ message: "This reward is currently out of stock" });
        }
        if (error.message === "Tier level too low for this reward") {
          return res.status(403).json({ message: "Your tier level is too low for this reward" });
        }
        res.status(500).json({ message: "Failed to redeem reward" });
      }
    }
  );
  app.get("/api/loyalty/redemptions", isAuthenticated2, async (req, res) => {
    try {
      const { status, limit, offset } = req.query;
      const redemptions = await loyaltyStorage.getUserRedemptions(req.user.id, {
        status,
        limit: limit ? parseInt(limit) : 50,
        offset: offset ? parseInt(offset) : 0
      });
      res.json(redemptions);
    } catch (error) {
      console.error("Error fetching redemptions:", error);
      res.status(500).json({ message: "Failed to fetch redemptions" });
    }
  });
  app.get("/api/loyalty/redemptions/:code", async (req, res) => {
    try {
      const redemption = await loyaltyStorage.getRedemptionByCode(req.params.code);
      if (!redemption) {
        return res.status(404).json({ message: "Redemption not found" });
      }
      res.json(redemption);
    } catch (error) {
      console.error("Error fetching redemption:", error);
      res.status(500).json({ message: "Failed to fetch redemption" });
    }
  });
  app.get("/api/loyalty/referral/code", isAuthenticated2, async (req, res) => {
    try {
      const code = await loyaltyStorage.generateReferralCode(req.user.id);
      res.json({ code });
    } catch (error) {
      console.error("Error generating referral code:", error);
      res.status(500).json({ message: "Failed to generate referral code" });
    }
  });
  app.post("/api/loyalty/referral/send", isAuthenticated2, async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const code = await loyaltyStorage.generateReferralCode(req.user.id);
      res.json({
        message: "Referral invitation sent!",
        code
      });
    } catch (error) {
      console.error("Error sending referral:", error);
      res.status(500).json({ message: "Failed to send referral" });
    }
  });
  app.post("/api/loyalty/referral/signup", async (req, res) => {
    try {
      const { referralCode, newUserId } = req.body;
      if (!referralCode || !newUserId) {
        return res.status(400).json({ message: "Referral code and user ID required" });
      }
      await loyaltyStorage.processReferralSignup(referralCode, newUserId);
      res.json({
        message: "Referral signup processed! Bonus points awarded."
      });
    } catch (error) {
      console.error("Error processing referral signup:", error);
      if (error.message === "Invalid referral code") {
        return res.status(400).json({ message: "Invalid referral code" });
      }
      if (error.message === "Referral code already used") {
        return res.status(400).json({ message: "This referral code has already been used" });
      }
      res.status(500).json({ message: "Failed to process referral signup" });
    }
  });
  app.get("/api/loyalty/referral/stats", isAuthenticated2, async (req, res) => {
    try {
      const stats = await loyaltyStorage.getReferralStats(req.user.id);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching referral stats:", error);
      res.status(500).json({ message: "Failed to fetch referral stats" });
    }
  });
  app.get("/api/loyalty/referral/leaderboard", async (req, res) => {
    try {
      const { limit } = req.query;
      const leaderboard = await loyaltyStorage.getReferralLeaderboard(
        limit ? parseInt(limit) : 10
      );
      res.json(leaderboard);
    } catch (error) {
      console.error("Error fetching referral leaderboard:", error);
      res.status(500).json({ message: "Failed to fetch referral leaderboard" });
    }
  });
  app.post(
    "/api/loyalty/calculate-points/purchase",
    isAuthenticated2,
    async (req, res) => {
      try {
        const { orderAmount } = req.body;
        if (!orderAmount || orderAmount <= 0) {
          return res.status(400).json({ message: "Valid order amount required" });
        }
        const points = await loyaltyStorage.calculatePointsForPurchase(
          req.user.id,
          orderAmount
        );
        res.json({ points });
      } catch (error) {
        console.error("Error calculating points:", error);
        res.status(500).json({ message: "Failed to calculate points" });
      }
    }
  );
  app.post("/api/loyalty/award-points", isAuthenticated2, async (req, res) => {
    try {
      const { eventType, sourceId } = req.body;
      if (!eventType) {
        return res.status(400).json({ message: "Event type required" });
      }
      const transaction = await loyaltyStorage.awardPointsForEvent(
        req.user.id,
        eventType,
        sourceId
      );
      if (!transaction) {
        return res.status(404).json({ message: "No points rule found for this event" });
      }
      res.json({
        message: "Points awarded!",
        transaction
      });
    } catch (error) {
      console.error("Error awarding points:", error);
      res.status(500).json({ message: "Failed to award points" });
    }
  });
  console.log("\u2705 Loyalty & rewards routes registered");
}
var isAuthenticated2;
var init_loyaltyRoutes = __esm({
  "server/loyaltyRoutes.ts"() {
    "use strict";
    init_loyaltyStorage();
    isAuthenticated2 = (req, res, next) => {
      if (!req.user || !req.user.id) {
        return res.status(401).json({ message: "Authentication required" });
      }
      next();
    };
  }
});

// server/analyticsStorage.ts
import { eq as eq8, and as and8, gte as gte5, lte as lte5, desc as desc6, sql as sql7, count, sum, avg } from "drizzle-orm";
var AnalyticsStorage, analyticsStorage;
var init_analyticsStorage = __esm({
  "server/analyticsStorage.ts"() {
    "use strict";
    init_db();
    init_schema();
    AnalyticsStorage = class {
      // ========================================
      // EVENT TRACKING
      // ========================================
      /**
       * Track a single analytics event in real-time
       */
      async trackEvent(eventData) {
        const startTime = Date.now();
        const [event] = await db.insert(analyticsEvents).values({
          eventType: eventData.eventType,
          eventCategory: eventData.eventCategory,
          userId: eventData.userId,
          businessId: eventData.businessId,
          productId: eventData.productId,
          orderId: eventData.orderId,
          sessionId: eventData.sessionId,
          ipAddress: eventData.ipAddress,
          userAgent: eventData.userAgent,
          eventData: eventData.eventData,
          processingTime: Date.now() - startTime,
          metadata: eventData.metadata
        }).returning();
        return event;
      }
      /**
       * Get events for a specific time range
       */
      async getEvents(filters) {
        const conditions = [
          gte5(analyticsEvents.timestamp, filters.startDate),
          lte5(analyticsEvents.timestamp, filters.endDate)
        ];
        if (filters.eventType) {
          conditions.push(eq8(analyticsEvents.eventType, filters.eventType));
        }
        if (filters.userId) {
          conditions.push(eq8(analyticsEvents.userId, filters.userId));
        }
        if (filters.businessId) {
          conditions.push(eq8(analyticsEvents.businessId, filters.businessId));
        }
        if (filters.productId) {
          conditions.push(eq8(analyticsEvents.productId, filters.productId));
        }
        let query = db.select().from(analyticsEvents).where(and8(...conditions)).orderBy(desc6(analyticsEvents.timestamp));
        if (filters.limit) {
          query = query.limit(filters.limit);
        }
        return await query;
      }
      // ========================================
      // DAILY METRICS AGGREGATION
      // ========================================
      /**
       * Aggregate and store daily platform metrics
       */
      async aggregateDailyMetrics(date2) {
        const startOfDay = new Date(date2);
        startOfDay.setHours(0, 0, 0, 0);
        const endOfDay = new Date(date2);
        endOfDay.setHours(23, 59, 59, 999);
        const revenueData = await db.select({
          totalRevenue: sum(orders.total),
          orderCount: count(orders.id)
        }).from(orders).where(
          and8(
            gte5(orders.createdAt, startOfDay),
            lte5(orders.createdAt, endOfDay),
            eq8(orders.status, "completed")
          )
        );
        const totalRevenue = parseFloat(revenueData[0]?.totalRevenue || "0");
        const orderCount = revenueData[0]?.orderCount || 0;
        const averageOrderValue = orderCount > 0 ? totalRevenue / orderCount : 0;
        const newUsersData = await db.select({ count: count(users.id) }).from(users).where(
          and8(
            gte5(users.createdAt, startOfDay),
            lte5(users.createdAt, endOfDay)
          )
        );
        const activeUsersData = await db.select({ count: count(users.id) }).from(users).where(
          and8(
            gte5(users.lastSeenAt, startOfDay),
            lte5(users.lastSeenAt, endOfDay)
          )
        );
        const newBusinessesData = await db.select({ count: count(businesses.id) }).from(businesses).where(
          and8(
            gte5(businesses.createdAt, startOfDay),
            lte5(businesses.createdAt, endOfDay)
          )
        );
        const loyaltyData = await db.select({
          pointsEarned: sum(
            sql7`CASE WHEN ${loyaltyTransactions.type} = 'earn' THEN ${loyaltyTransactions.points} ELSE 0 END`
          ),
          pointsRedeemed: sum(
            sql7`CASE WHEN ${loyaltyTransactions.type} = 'redeem' THEN ${loyaltyTransactions.points} ELSE 0 END`
          )
        }).from(loyaltyTransactions).where(
          and8(
            gte5(loyaltyTransactions.createdAt, startOfDay),
            lte5(loyaltyTransactions.createdAt, endOfDay)
          )
        );
        const reviewsData = await db.select({ count: count(reviews.id) }).from(reviews).where(
          and8(
            gte5(reviews.createdAt, startOfDay),
            lte5(reviews.createdAt, endOfDay)
          )
        );
        const metrics = {
          date: startOfDay,
          totalRevenue: totalRevenue.toFixed(2),
          orderCount,
          averageOrderValue: averageOrderValue.toFixed(2),
          newUsers: newUsersData[0]?.count || 0,
          activeUsers: activeUsersData[0]?.count || 0,
          returningUsers: 0,
          // Calculate based on previous visits
          newBusinesses: newBusinessesData[0]?.count || 0,
          activeBusinesses: 0,
          // Calculate based on activity
          productsListed: 0,
          productsSold: 0,
          pointsEarned: loyaltyData[0]?.pointsEarned || 0,
          pointsRedeemed: loyaltyData[0]?.pointsRedeemed || 0,
          rewardsRedeemed: 0,
          reviewsCreated: reviewsData[0]?.count || 0,
          messagesExchanged: 0,
          socialShares: 0,
          referralsSent: 0,
          referralsCompleted: 0
        };
        const existing = await db.select().from(dailyMetrics).where(eq8(dailyMetrics.date, startOfDay)).limit(1);
        if (existing.length > 0) {
          const [updated] = await db.update(dailyMetrics).set({ ...metrics, updatedAt: /* @__PURE__ */ new Date() }).where(eq8(dailyMetrics.date, startOfDay)).returning();
          return updated;
        } else {
          const [created] = await db.insert(dailyMetrics).values(metrics).returning();
          return created;
        }
      }
      /**
       * Get daily metrics for a date range
       */
      async getDailyMetrics(startDate, endDate) {
        return await db.select().from(dailyMetrics).where(
          and8(
            gte5(dailyMetrics.date, startDate),
            lte5(dailyMetrics.date, endDate)
          )
        ).orderBy(dailyMetrics.date);
      }
      /**
       * Get platform overview metrics
       */
      async getPlatformOverview(days = 30) {
        const endDate = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        startDate.setDate(startDate.getDate() - days);
        const metrics = await this.getDailyMetrics(startDate, endDate);
        const totals = metrics.reduce((acc, day) => {
          return {
            totalRevenue: acc.totalRevenue + parseFloat(day.totalRevenue),
            totalOrders: acc.totalOrders + day.orderCount,
            totalUsers: acc.totalUsers + day.newUsers,
            totalActiveUsers: acc.totalActiveUsers + day.activeUsers,
            totalBusinesses: acc.totalBusinesses + day.newBusinesses,
            totalPointsEarned: acc.totalPointsEarned + day.pointsEarned,
            totalPointsRedeemed: acc.totalPointsRedeemed + day.pointsRedeemed,
            totalReviews: acc.totalReviews + day.reviewsCreated
          };
        }, {
          totalRevenue: 0,
          totalOrders: 0,
          totalUsers: 0,
          totalActiveUsers: 0,
          totalBusinesses: 0,
          totalPointsEarned: 0,
          totalPointsRedeemed: 0,
          totalReviews: 0
        });
        const avgOrderValue = totals.totalOrders > 0 ? totals.totalRevenue / totals.totalOrders : 0;
        return {
          period: `${days} days`,
          startDate,
          endDate,
          ...totals,
          averageOrderValue: avgOrderValue.toFixed(2),
          dailyMetrics: metrics
        };
      }
      // ========================================
      // BUSINESS ANALYTICS
      // ========================================
      /**
       * Aggregate business metrics for a specific business and date
       */
      async aggregateBusinessMetrics(businessId, date2) {
        const startOfDay = new Date(date2);
        startOfDay.setHours(0, 0, 0, 0);
        const endOfDay = new Date(date2);
        endOfDay.setHours(23, 59, 59, 999);
        const businessProducts = await db.select().from(products).where(eq8(products.businessId, businessId));
        const productIds = businessProducts.map((p) => p.id);
        let revenue = 0;
        let ordersCount = 0;
        if (productIds.length > 0) {
          const orderData = await db.select({
            totalRevenue: sum(orderItems.totalPrice),
            orderCount: count(sql7`DISTINCT ${orderItems.orderId}`)
          }).from(orderItems).innerJoin(orders, eq8(orderItems.orderId, orders.id)).where(
            and8(
              sql7`${orderItems.productId} IN ${productIds}`,
              gte5(orders.createdAt, startOfDay),
              lte5(orders.createdAt, endOfDay),
              eq8(orders.status, "completed")
            )
          );
          revenue = parseFloat(orderData[0]?.totalRevenue || "0");
          ordersCount = orderData[0]?.orderCount || 0;
        }
        const reviewData = await db.select({
          count: count(reviews.id),
          avgRating: avg(reviews.rating)
        }).from(reviews).where(
          and8(
            eq8(reviews.businessId, businessId),
            gte5(reviews.createdAt, startOfDay),
            lte5(reviews.createdAt, endOfDay)
          )
        );
        const metrics = {
          businessId,
          date: startOfDay,
          views: 0,
          // Track via events
          uniqueVisitors: 0,
          clicks: 0,
          revenue: revenue.toFixed(2),
          orders: ordersCount,
          productsListedCount: businessProducts.length,
          productsSoldCount: 0,
          newCustomers: 0,
          returningCustomers: 0,
          averageOrderValue: ordersCount > 0 ? (revenue / ordersCount).toFixed(2) : "0",
          reviewsReceived: reviewData[0]?.count || 0,
          averageRating: parseFloat(reviewData[0]?.avgRating || "0").toFixed(2),
          messagesReceived: 0,
          messagesReplied: 0,
          spotlightVotes: 0,
          spotlightWins: 0
        };
        const existing = await db.select().from(businessMetrics).where(
          and8(
            eq8(businessMetrics.businessId, businessId),
            eq8(businessMetrics.date, startOfDay)
          )
        ).limit(1);
        if (existing.length > 0) {
          const [updated] = await db.update(businessMetrics).set({ ...metrics, updatedAt: /* @__PURE__ */ new Date() }).where(
            and8(
              eq8(businessMetrics.businessId, businessId),
              eq8(businessMetrics.date, startOfDay)
            )
          ).returning();
          return updated;
        } else {
          const [created] = await db.insert(businessMetrics).values(metrics).returning();
          return created;
        }
      }
      /**
       * Get business metrics for a date range
       */
      async getBusinessMetrics(businessId, startDate, endDate) {
        return await db.select().from(businessMetrics).where(
          and8(
            eq8(businessMetrics.businessId, businessId),
            gte5(businessMetrics.date, startDate),
            lte5(businessMetrics.date, endDate)
          )
        ).orderBy(businessMetrics.date);
      }
      /**
       * Get business dashboard summary
       */
      async getBusinessDashboard(businessId, days = 30) {
        const endDate = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        startDate.setDate(startDate.getDate() - days);
        const metrics = await this.getBusinessMetrics(businessId, startDate, endDate);
        const totals = metrics.reduce((acc, day) => {
          return {
            totalRevenue: acc.totalRevenue + parseFloat(day.revenue),
            totalOrders: acc.totalOrders + day.orders,
            totalViews: acc.totalViews + day.views,
            totalReviews: acc.totalReviews + day.reviewsReceived
          };
        }, {
          totalRevenue: 0,
          totalOrders: 0,
          totalViews: 0,
          totalReviews: 0
        });
        const avgOrderValue = totals.totalOrders > 0 ? totals.totalRevenue / totals.totalOrders : 0;
        const avgRating = metrics.length > 0 ? metrics.reduce((sum2, m) => sum2 + parseFloat(m.averageRating), 0) / metrics.length : 0;
        return {
          businessId,
          period: `${days} days`,
          startDate,
          endDate,
          ...totals,
          averageOrderValue: avgOrderValue.toFixed(2),
          averageRating: avgRating.toFixed(2),
          dailyMetrics: metrics
        };
      }
      // ========================================
      // CUSTOMER COHORT ANALYSIS
      // ========================================
      /**
       * Create or update a cohort
       */
      async createCohort(cohortData) {
        const existing = await db.select().from(customerCohorts).where(
          and8(
            eq8(customerCohorts.cohortName, cohortData.cohortName),
            eq8(customerCohorts.cohortDate, cohortData.cohortDate)
          )
        ).limit(1);
        if (existing.length > 0) {
          const [updated] = await db.update(customerCohorts).set({ ...cohortData, updatedAt: /* @__PURE__ */ new Date() }).where(
            and8(
              eq8(customerCohorts.cohortName, cohortData.cohortName),
              eq8(customerCohorts.cohortDate, cohortData.cohortDate)
            )
          ).returning();
          return updated;
        } else {
          const [created] = await db.insert(customerCohorts).values(cohortData).returning();
          return created;
        }
      }
      /**
       * Get cohorts by type
       */
      async getCohorts(cohortType, limit = 12) {
        return await db.select().from(customerCohorts).where(eq8(customerCohorts.cohortType, cohortType)).orderBy(desc6(customerCohorts.cohortDate)).limit(limit);
      }
      // ========================================
      // CONVERSION FUNNELS
      // ========================================
      /**
       * Track conversion funnel
       */
      async trackFunnel(funnelData) {
        const step1ToStep2Rate = funnelData.step1Count > 0 ? (funnelData.step2Count / funnelData.step1Count * 100).toFixed(2) : "0";
        const step2ToStep3Rate = funnelData.step2Count > 0 ? (funnelData.step3Count / funnelData.step2Count * 100).toFixed(2) : "0";
        const step3ToStep4Rate = funnelData.step3Count > 0 && funnelData.step4Count ? (funnelData.step4Count / funnelData.step3Count * 100).toFixed(2) : "0";
        const step4ToStep5Rate = funnelData.step4Count && funnelData.step5Count ? (funnelData.step5Count / funnelData.step4Count * 100).toFixed(2) : "0";
        const finalStep = funnelData.step5Count || funnelData.step4Count || funnelData.step3Count;
        const overallConversionRate = funnelData.step1Count > 0 ? (finalStep / funnelData.step1Count * 100).toFixed(2) : "0";
        const startOfDay = new Date(funnelData.date);
        startOfDay.setHours(0, 0, 0, 0);
        const data = {
          ...funnelData,
          date: startOfDay,
          step1ToStep2Rate,
          step2ToStep3Rate,
          step3ToStep4Rate,
          step4ToStep5Rate,
          overallConversionRate
        };
        const existing = await db.select().from(conversionFunnels).where(
          and8(
            eq8(conversionFunnels.funnelName, funnelData.funnelName),
            eq8(conversionFunnels.date, startOfDay)
          )
        ).limit(1);
        if (existing.length > 0) {
          const [updated] = await db.update(conversionFunnels).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(
            and8(
              eq8(conversionFunnels.funnelName, funnelData.funnelName),
              eq8(conversionFunnels.date, startOfDay)
            )
          ).returning();
          return updated;
        } else {
          const [created] = await db.insert(conversionFunnels).values(data).returning();
          return created;
        }
      }
      /**
       * Get funnel data for a date range
       */
      async getFunnels(funnelName, startDate, endDate) {
        return await db.select().from(conversionFunnels).where(
          and8(
            eq8(conversionFunnels.funnelName, funnelName),
            gte5(conversionFunnels.date, startDate),
            lte5(conversionFunnels.date, endDate)
          )
        ).orderBy(conversionFunnels.date);
      }
    };
    analyticsStorage = new AnalyticsStorage();
  }
});

// server/analyticsRoutes.ts
var analyticsRoutes_exports = {};
__export(analyticsRoutes_exports, {
  registerAnalyticsRoutes: () => registerAnalyticsRoutes
});
function registerAnalyticsRoutes(app) {
  console.log("\u{1F4CA} Registering analytics & BI routes...");
  app.post("/api/analytics/events", async (req, res) => {
    try {
      const event = await analyticsStorage.trackEvent({
        ...req.body,
        userId: req.user?.claims?.sub,
        ipAddress: req.ip,
        userAgent: req.get("user-agent")
      });
      res.json({ success: true, eventId: event.id });
    } catch (error) {
      console.error("Error tracking event:", error);
      res.status(500).json({ message: "Failed to track event" });
    }
  });
  app.get("/api/analytics/events", async (req, res) => {
    try {
      const { startDate, endDate, eventType, userId, businessId, productId, limit } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "startDate and endDate are required" });
      }
      const events = await analyticsStorage.getEvents({
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        eventType,
        userId,
        businessId,
        productId,
        limit: limit ? parseInt(limit) : void 0
      });
      res.json(events);
    } catch (error) {
      console.error("Error fetching events:", error);
      res.status(500).json({ message: "Failed to fetch events" });
    }
  });
  app.get("/api/analytics/platform/overview", async (req, res) => {
    try {
      const days = parseInt(req.query.days) || 30;
      const overview = await analyticsStorage.getPlatformOverview(days);
      res.json(overview);
    } catch (error) {
      console.error("Error fetching platform overview:", error);
      res.status(500).json({ message: "Failed to fetch platform overview" });
    }
  });
  app.get("/api/analytics/platform/daily", async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "startDate and endDate are required" });
      }
      const metrics = await analyticsStorage.getDailyMetrics(
        new Date(startDate),
        new Date(endDate)
      );
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching daily metrics:", error);
      res.status(500).json({ message: "Failed to fetch daily metrics" });
    }
  });
  app.post("/api/analytics/platform/aggregate", async (req, res) => {
    try {
      const { date: date2 } = req.body;
      const targetDate = date2 ? new Date(date2) : /* @__PURE__ */ new Date();
      const metrics = await analyticsStorage.aggregateDailyMetrics(targetDate);
      res.json({ success: true, metrics });
    } catch (error) {
      console.error("Error aggregating metrics:", error);
      res.status(500).json({ message: "Failed to aggregate metrics" });
    }
  });
  app.get("/api/analytics/business/:businessId/dashboard", async (req, res) => {
    try {
      const { businessId } = req.params;
      const days = parseInt(req.query.days) || 30;
      const dashboard = await analyticsStorage.getBusinessDashboard(businessId, days);
      res.json(dashboard);
    } catch (error) {
      console.error("Error fetching business dashboard:", error);
      res.status(500).json({ message: "Failed to fetch business dashboard" });
    }
  });
  app.get("/api/analytics/business/:businessId/metrics", async (req, res) => {
    try {
      const { businessId } = req.params;
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "startDate and endDate are required" });
      }
      const metrics = await analyticsStorage.getBusinessMetrics(
        businessId,
        new Date(startDate),
        new Date(endDate)
      );
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching business metrics:", error);
      res.status(500).json({ message: "Failed to fetch business metrics" });
    }
  });
  app.post("/api/analytics/business/:businessId/aggregate", async (req, res) => {
    try {
      const { businessId } = req.params;
      const { date: date2 } = req.body;
      const targetDate = date2 ? new Date(date2) : /* @__PURE__ */ new Date();
      const metrics = await analyticsStorage.aggregateBusinessMetrics(businessId, targetDate);
      res.json({ success: true, metrics });
    } catch (error) {
      console.error("Error aggregating business metrics:", error);
      res.status(500).json({ message: "Failed to aggregate business metrics" });
    }
  });
  app.get("/api/analytics/cohorts", async (req, res) => {
    try {
      const { type, limit } = req.query;
      if (!type) {
        return res.status(400).json({ message: "type is required" });
      }
      const cohorts = await analyticsStorage.getCohorts(
        type,
        limit ? parseInt(limit) : 12
      );
      res.json(cohorts);
    } catch (error) {
      console.error("Error fetching cohorts:", error);
      res.status(500).json({ message: "Failed to fetch cohorts" });
    }
  });
  app.post("/api/analytics/cohorts", async (req, res) => {
    try {
      const cohort = await analyticsStorage.createCohort(req.body);
      res.json(cohort);
    } catch (error) {
      console.error("Error creating cohort:", error);
      res.status(500).json({ message: "Failed to create cohort" });
    }
  });
  app.get("/api/analytics/funnels/:funnelName", async (req, res) => {
    try {
      const { funnelName } = req.params;
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "startDate and endDate are required" });
      }
      const funnels = await analyticsStorage.getFunnels(
        funnelName,
        new Date(startDate),
        new Date(endDate)
      );
      res.json(funnels);
    } catch (error) {
      console.error("Error fetching funnels:", error);
      res.status(500).json({ message: "Failed to fetch funnels" });
    }
  });
  app.post("/api/analytics/funnels", async (req, res) => {
    try {
      const funnel = await analyticsStorage.trackFunnel(req.body);
      res.json(funnel);
    } catch (error) {
      console.error("Error tracking funnel:", error);
      res.status(500).json({ message: "Failed to track funnel" });
    }
  });
  app.get("/api/analytics/realtime", async (req, res) => {
    try {
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1e3);
      const now = /* @__PURE__ */ new Date();
      const recentEvents = await analyticsStorage.getEvents({
        startDate: fiveMinutesAgo,
        endDate: now,
        limit: 100
      });
      const eventCounts = {};
      recentEvents.forEach((event) => {
        eventCounts[event.eventType] = (eventCounts[event.eventType] || 0) + 1;
      });
      const uniqueUsers = new Set(
        recentEvents.filter((e) => e.userId).map((e) => e.userId)
      ).size;
      res.json({
        timestamp: now,
        period: "5 minutes",
        totalEvents: recentEvents.length,
        uniqueUsers,
        eventBreakdown: eventCounts,
        recentEvents: recentEvents.slice(0, 10)
        // Latest 10 events
      });
    } catch (error) {
      console.error("Error fetching realtime stats:", error);
      res.status(500).json({ message: "Failed to fetch realtime stats" });
    }
  });
  console.log("\u{1F4CA} Analytics & BI routes registered");
}
var init_analyticsRoutes = __esm({
  "server/analyticsRoutes.ts"() {
    "use strict";
    init_analyticsStorage();
  }
});

// server/monitoringRoutes.ts
var monitoringRoutes_exports = {};
__export(monitoringRoutes_exports, {
  registerMonitoringRoutes: () => registerMonitoringRoutes
});
function registerMonitoringRoutes(app) {
  app.get("/api/monitoring/health", asyncHandler2(async (req, res) => {
    const health = await healthChecker.runChecks();
    res.status(health.healthy ? 200 : 503).json({
      status: health.healthy ? "healthy" : "unhealthy",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      checks: health.checks
    });
  }));
  app.get("/api/monitoring/dashboard", requireAdmin, asyncHandler2(async (req, res) => {
    const errorStats = errorLogger.getStats();
    const performanceStats = performanceMonitor.getAllStats();
    const aiStats = aiAgentOrchestrator.getStats();
    const recentErrors = errorLogger.getRecentErrors(20);
    const recentAudits = auditLogger.getRecentAudits(50);
    res.json({
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      system: {
        uptime: process.uptime(),
        memory: {
          used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
          total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
          percentage: Math.round(process.memoryUsage().heapUsed / process.memoryUsage().heapTotal * 100)
        },
        cpu: process.cpuUsage(),
        nodeVersion: process.version,
        platform: process.platform,
        environment: process.env.NODE_ENV
      },
      errors: {
        summary: errorStats,
        recent: recentErrors.map((e) => ({
          timestamp: e.timestamp,
          severity: e.severity,
          category: e.category,
          message: e.message,
          userId: e.userId
        }))
      },
      performance: performanceStats,
      ai: {
        queueStats: aiStats,
        models: {
          campaign_optimize: "anthropic/claude-3.5-sonnet",
          content_generate: "anthropic/claude-3.5-sonnet",
          segment_analyze: "openai/gpt-4-turbo",
          subject_test: "anthropic/claude-3.5-sonnet",
          send_time_optimize: "openai/gpt-4-turbo",
          workflow_generate: "anthropic/claude-3.5-sonnet",
          form_optimize: "openai/gpt-4-turbo"
        }
      },
      circuitBreakers: {
        emailService: emailServiceCircuitBreaker.getState(),
        smsService: smsServiceCircuitBreaker.getState(),
        aiService: aiServiceCircuitBreaker.getState()
      },
      services: {
        email: emailService.getProviderInfo(),
        sms: smsService.getProviderInfo()
      },
      audits: {
        recent: recentAudits.map((a) => ({
          timestamp: a.timestamp,
          userId: a.userId,
          action: a.action,
          resource: a.resource,
          result: a.result
        }))
      }
    });
  }));
  app.get("/api/monitoring/errors", requireAdmin, asyncHandler2(async (req, res) => {
    const { category, severity, limit = 100 } = req.query;
    let errors = errorLogger.getRecentErrors(Number(limit));
    if (category) {
      errors = errorLogger.getErrorsByCategory(category);
    }
    if (severity) {
      errors = errorLogger.getErrorsBySeverity(severity);
    }
    res.json({
      total: errors.length,
      errors: errors.map((e) => ({
        id: e.requestId,
        timestamp: e.timestamp,
        severity: e.severity,
        category: e.category,
        message: e.message,
        statusCode: e.statusCode,
        userId: e.userId,
        context: e.context,
        stack: process.env.NODE_ENV === "development" ? e.stack : void 0
      }))
    });
  }));
  app.get("/api/monitoring/performance", requireAdmin, asyncHandler2(async (req, res) => {
    const stats = performanceMonitor.getAllStats();
    res.json({
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      metrics: stats
    });
  }));
  app.get("/api/monitoring/audits", requireAdmin, asyncHandler2(async (req, res) => {
    const { userId, resource, limit = 100 } = req.query;
    let audits = auditLogger.getRecentAudits(Number(limit));
    if (userId) {
      audits = auditLogger.getAuditsByUser(userId);
    }
    if (resource) {
      audits = auditLogger.getAuditsByResource(resource);
    }
    res.json({
      total: audits.length,
      audits
    });
  }));
  app.get("/api/monitoring/ai", requireAdmin, asyncHandler2(async (req, res) => {
    const stats = aiAgentOrchestrator.getStats();
    res.json({
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      queueStats: stats,
      agents: {
        campaign_optimize: {
          model: "anthropic/claude-3.5-sonnet",
          description: "Strategic campaign optimization and recommendations"
        },
        content_generate: {
          model: "anthropic/claude-3.5-sonnet",
          description: "Creative email content and copywriting"
        },
        segment_analyze: {
          model: "openai/gpt-4-turbo",
          description: "Customer segmentation and predictive analytics"
        },
        subject_test: {
          model: "anthropic/claude-3.5-sonnet",
          description: "A/B testing subject line variations"
        },
        send_time_optimize: {
          model: "openai/gpt-4-turbo",
          description: "Optimal send time prediction"
        },
        workflow_generate: {
          model: "anthropic/claude-3.5-sonnet",
          description: "Marketing automation workflow design"
        },
        form_optimize: {
          model: "openai/gpt-4-turbo",
          description: "Lead capture form optimization"
        }
      }
    });
  }));
  app.post("/api/monitoring/errors/clear", requireAdmin, asyncHandler2(async (req, res) => {
    errorLogger.clearLog();
    res.json({
      success: true,
      message: "Error logs cleared"
    });
  }));
  app.post("/api/monitoring/audits/clear", requireAdmin, asyncHandler2(async (req, res) => {
    auditLogger.clearLog();
    res.json({
      success: true,
      message: "Audit logs cleared"
    });
  }));
  app.post("/api/monitoring/performance/clear", requireAdmin, asyncHandler2(async (req, res) => {
    performanceMonitor.clearMetrics();
    res.json({
      success: true,
      message: "Performance metrics cleared"
    });
  }));
  app.post("/api/monitoring/circuit-breakers/reset", requireAdmin, asyncHandler2(async (req, res) => {
    res.json({
      success: true,
      message: "Circuit breakers will auto-reset on next success",
      current: {
        emailService: emailServiceCircuitBreaker.getState(),
        smsService: smsServiceCircuitBreaker.getState(),
        aiService: aiServiceCircuitBreaker.getState()
      }
    });
  }));
  app.get("/api/monitoring/system-info", requireAdmin, asyncHandler2(async (req, res) => {
    res.json({
      process: {
        pid: process.pid,
        uptime: process.uptime(),
        version: process.version,
        platform: process.platform,
        arch: process.arch
      },
      memory: {
        rss: Math.round(process.memoryUsage().rss / 1024 / 1024),
        heapTotal: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
        heapUsed: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
        external: Math.round(process.memoryUsage().external / 1024 / 1024),
        arrayBuffers: Math.round(process.memoryUsage().arrayBuffers / 1024 / 1024)
      },
      cpu: process.cpuUsage(),
      environment: {
        nodeEnv: process.env.NODE_ENV,
        hasOpenRouterKey: !!process.env.OPENROUTER_API_KEY,
        hasSendGridKey: !!process.env.SENDGRID_API_KEY,
        hasMailjetKey: !!process.env.MAILJET_API_KEY,
        hasGmailCreds: !!(process.env.GMAIL_CLIENT_ID && process.env.GMAIL_CLIENT_SECRET),
        hasTwilioKey: !!process.env.TWILIO_ACCOUNT_SID
      }
    });
  }));
  console.log("\u2705 Enterprise monitoring routes registered");
}
var requireAdmin;
var init_monitoringRoutes = __esm({
  "server/monitoringRoutes.ts"() {
    "use strict";
    init_errorHandler();
    init_aiAgentOrchestrator();
    init_emailService();
    init_smsService();
    requireAdmin = (req, res, next) => {
      const user = req.user;
      if (!user || user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      next();
    };
  }
});

// server/routes.ts
var routes_exports = {};
__export(routes_exports, {
  registerRoutes: () => registerRoutes
});
import express from "express";
import { createServer } from "http";
import { z as z5 } from "zod";
import path3 from "path";
async function registerRoutes(app) {
  console.log("\u{1F527} Starting registerRoutes function");
  console.log("\u{1F527} REPLIT_DOMAINS:", process.env.REPLIT_DOMAINS);
  console.log("\u{1F527} SESSION_SECRET exists:", !!process.env.SESSION_SECRET);
  console.log("\u{1F527} REPL_ID exists:", !!process.env.REPL_ID);
  console.log("\u2705 Authentication already initialized in bootstrap sequence");
  console.log("\u{1F527} Setting up auth routes...");
  app.get("/api/auth/health", async (_req, res) => {
    try {
      const healthData = {
        status: "ok",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        sessionStore: "unknown",
        database: "unknown",
        redis: "unknown"
      };
      try {
        const redisAvailable = await checkRedisConnection().catch(() => false);
        healthData.redis = redisAvailable ? "connected" : "disconnected";
        if (redisAvailable) {
          healthData.sessionStore = "redis";
        } else {
          const dbStatus = getDatabaseStatus();
          healthData.database = dbStatus?.isConnected ? "connected" : "disconnected";
          healthData.sessionStore = dbStatus?.isConnected ? "postgresql" : "memory";
        }
      } catch (err) {
        console.error("Auth health check error:", err);
        healthData.sessionStore = "error";
      }
      res.json(healthData);
    } catch (error) {
      return ApiResponse.internalError(res, error instanceof Error ? error.message : "Unknown error", {
        status: "error",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  app.get("/api/auth/session-info", isAuthenticated, async (req, res) => {
    try {
      const session2 = req.session;
      const expires = session2.cookie.expires;
      res.json({
        expires: expires ? expires.toISOString() : null,
        maxAge: session2.cookie.maxAge,
        isRolling: session2.cookie.rolling ?? true
      });
    } catch (error) {
      return ApiResponse.internalError(res, "Failed to retrieve session info");
    }
  });
  app.get("/api/auth/user", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id || req.user?.claims?.sub;
      const email = req.user?.email || req.user?.claims?.email;
      if (!userId) {
        console.error("\u274C /api/auth/user - No user ID found");
        console.error("User object:", JSON.stringify(req.user));
        return ApiResponse.unauthorized(res, "Invalid session: No user ID found");
      }
      console.log(`\u{1F510} /api/auth/user - User authenticated: ${email} (ID: ${userId})`);
      if (req.user.id === userId) {
        console.log(`\u2705 /api/auth/user - Returning deserialized user: ${req.user.email}`);
        return res.json(req.user);
      }
      const user = await storage.getUser(userId);
      if (!user) {
        console.error(`\u274C /api/auth/user - User not found in database: ${userId}`);
        return ApiResponse.notFound(res, "User not found");
      }
      console.log(`\u2705 /api/auth/user - Successfully returned user: ${user.email}`);
      res.json(user);
    } catch (error) {
      console.error("\u274C /api/auth/user - Error fetching user:", error);
      console.error("Error stack:", error.stack);
      return ApiResponse.internalError(res, "Failed to fetch user data");
    }
  });
  app.get("/api/businesses", publicEndpointRateLimit, asyncHandler(async (req, res) => {
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 20, 100);
    const category = req.query.category;
    const businesses3 = await storage.getBusinesses(page, limit, category);
    return ApiResponse.success(res, businesses3);
  }));
  app.get("/api/businesses/featured", publicEndpointRateLimit, asyncHandler(async (req, res) => {
    const limit = Math.min(parseInt(req.query.limit) || 12, 50);
    const businesses3 = await storage.getFeaturedBusinesses(limit);
    return ApiResponse.success(res, businesses3);
  }));
  app.post("/api/businesses", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const businessData = insertBusinessSchema.parse({
        ...req.body,
        ownerId: userId
      });
      const business = await storage.createBusiness(businessData);
      res.json(business);
    } catch (error) {
      console.error("Error creating business:", error);
      if (error.name === "ZodError") {
        return ApiResponse.zodValidation(res, error, req);
      }
      return ApiResponse.badRequest(res, "Validation error");
    }
  });
  app.get("/api/businesses/search", publicEndpointRateLimit, async (req, res) => {
    try {
      const { q: query = "", category } = req.query;
      const businesses3 = await storage.searchBusinesses(
        query,
        category
      );
      res.json(businesses3);
    } catch (error) {
      console.error("Error searching businesses:", error);
      return ApiResponse.internalError(res, "Failed to search businesses");
    }
  });
  app.get("/api/businesses/spotlight", async (req, res) => {
    try {
      await storage.rotateSpotlights();
      const spotlights2 = await storage.getCurrentSpotlights();
      const isEmpty = !spotlights2.daily?.length && !spotlights2.weekly?.length && !spotlights2.monthly?.length;
      if (isEmpty) {
        const trending = await storage.getTrendingBusinesses(6);
        return res.json({
          daily: trending.slice(0, 3),
          weekly: trending.slice(0, 5),
          monthly: trending.slice(0, 1),
          fallback: true
        });
      }
      res.json(spotlights2);
    } catch (error) {
      console.error("Error fetching spotlights:", error);
      return ApiResponse.internalError(res, "Failed to fetch spotlights");
    }
  });
  app.get("/api/businesses/my", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const businesses3 = await storage.getBusinessesByOwner(userId);
      res.json(businesses3);
    } catch (error) {
      console.error("Error fetching user businesses:", error);
      return ApiResponse.internalError(res, "Failed to fetch user businesses");
    }
  });
  app.get("/api/businesses/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const business = await storage.getBusinessById(id);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      res.json(business);
    } catch (error) {
      console.error("Error fetching business:", error);
      return ApiResponse.internalError(res, "Failed to fetch business");
    }
  });
  app.put("/api/businesses/:id", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const existingBusiness = await storage.getBusinessById(id);
      if (!existingBusiness) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (existingBusiness.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to edit this business");
      }
      const businessData = updateBusinessSchema.parse(req.body);
      const business = await storage.updateBusiness(id, businessData);
      res.json(business);
    } catch (error) {
      console.error("Error updating business:", error);
      if (error.name === "ZodError") {
        return ApiResponse.zodValidation(res, error);
      }
      return ApiResponse.badRequest(res, "Validation error");
    }
  });
  app.post("/api/businesses/:id/follow", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      await storage.followBusiness(userId, businessId);
      res.json({ message: "Successfully followed business" });
    } catch (error) {
      console.error("Error following business:", error);
      return ApiResponse.internalError(res, "Failed to follow business");
    }
  });
  app.delete("/api/businesses/:id/follow", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      await storage.unfollowBusiness(userId, businessId);
      res.json({ message: "Successfully unfollowed business" });
    } catch (error) {
      console.error("Error unfollowing business:", error);
      return ApiResponse.internalError(res, "Failed to unfollow business");
    }
  });
  app.post("/api/businesses/:id/gmb/connect", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to connect GMB for this business");
      }
      const authUrl = gmbService.generateAuthUrl(businessId);
      res.json({
        success: true,
        authUrl,
        message: "Redirect user to this URL to authorize GMB access"
      });
    } catch (error) {
      console.error("Error initiating GMB connection:", error);
      return ApiResponse.internalError(res, error.message || "Failed to initiate GMB connection");
    }
  });
  app.get("/api/gmb/oauth/callback", async (req, res) => {
    try {
      const { code, state: businessId, error } = req.query;
      if (error) {
        return ApiResponse.badRequest(res, "OAuth authorization failed", { error });
      }
      if (!code || !businessId) {
        return ApiResponse.badRequest(res, "Missing authorization code or business ID");
      }
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      await gmbService.exchangeCodeForTokens(
        code,
        businessId,
        business.ownerId
      );
      res.redirect(`/business/${businessId}?gmb=connected`);
    } catch (error) {
      console.error("Error in GMB OAuth callback:", error);
      return ApiResponse.internalError(res, error.message || "Failed to complete GMB connection");
    }
  });
  app.get("/api/gmb/search", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const { businessId } = req.query;
      if (!businessId) {
        return ApiResponse.badRequest(res, "Business ID is required");
      }
      const userId = req.user.claims.sub;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to search GMB for this business");
      }
      const searchResults = await businessVerificationService.searchGMBMatches(businessId);
      res.json(searchResults);
    } catch (error) {
      console.error("Error searching GMB listings:", error);
      return ApiResponse.internalError(res, error.message || "Failed to search GMB listings");
    }
  });
  app.post("/api/businesses/:id/gmb/verify", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const validationResult = gmbVerifyRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.zodValidation(res, validationResult.error);
      }
      const { gmbLocationName } = validationResult.data;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to verify this business");
      }
      const result = await businessVerificationService.initiateVerification(
        businessId,
        gmbLocationName
      );
      res.json(result);
    } catch (error) {
      console.error("Error initiating business verification:", error);
      return ApiResponse.internalError(res, error.message || "Failed to initiate verification");
    }
  });
  app.get("/api/businesses/:id/gmb/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      const isOwner = business.ownerId === userId;
      if (isOwner) {
        const status = await businessVerificationService.getVerificationStatus(businessId);
        const syncStatus = await gmbService.getSyncStatus(businessId);
        res.json({
          ...status,
          syncDetails: syncStatus
        });
      } else {
        res.json({
          isVerified: business.gmbVerified || false,
          isConnected: business.gmbConnected || false
        });
      }
    } catch (error) {
      console.error("Error fetching GMB status:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch GMB status");
    }
  });
  app.post("/api/businesses/:id/gmb/sync", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const validationResult = gmbSyncRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.zodValidation(res, validationResult.error, req);
      }
      const { forceUpdate, syncPhotos, syncReviews, syncBusinessInfo, conflictResolution } = validationResult.data;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to sync this business");
      }
      if (!business.gmbConnected) {
        return ApiResponse.badRequest(res, "Business is not connected to Google My Business");
      }
      const syncResult = await dataSyncService.performFullSync(businessId, {
        forceUpdate,
        syncPhotos,
        syncReviews,
        syncBusinessInfo,
        conflictResolution
      });
      res.json(syncResult);
    } catch (error) {
      console.error("Error syncing business data:", error);
      return ApiResponse.internalError(res, error.message || "Failed to sync business data");
    }
  });
  app.get("/api/businesses/:id/gmb/sync/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view sync status for this business");
      }
      const syncStatus = await gmbService.getSyncStatus(businessId);
      res.json(syncStatus);
    } catch (error) {
      console.error("Error fetching sync status:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch sync status");
    }
  });
  app.get("/api/businesses/:id/gmb/reviews", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      const isOwner = business.ownerId === userId;
      const reviews2 = await storage.getGmbReviewsByBusiness(businessId);
      const filteredReviews = reviews2.map((review) => ({
        id: review.id,
        reviewerName: review.reviewerName,
        reviewerPhotoUrl: review.reviewerPhotoUrl,
        rating: review.rating,
        comment: review.comment,
        reviewTime: review.reviewTime,
        replyComment: review.replyComment,
        replyTime: review.replyTime,
        // Only include GMB IDs for owners
        ...isOwner && {
          gmbReviewId: review.gmbReviewId,
          gmbCreateTime: review.gmbCreateTime,
          gmbUpdateTime: review.gmbUpdateTime
        }
      }));
      res.json(filteredReviews);
    } catch (error) {
      console.error("Error fetching GMB reviews:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch GMB reviews");
    }
  });
  app.delete("/api/businesses/:id/gmb/disconnect", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to disconnect GMB for this business");
      }
      await gmbService.disconnectBusiness(businessId);
      res.json({
        success: true,
        message: "Successfully disconnected from Google My Business"
      });
    } catch (error) {
      console.error("Error disconnecting GMB:", error);
      return ApiResponse.internalError(res, error.message || "Failed to disconnect GMB");
    }
  });
  app.post("/api/gmb/webhook", async (req, res) => {
    try {
      const payload = req.body;
      console.log("Received GMB webhook:", payload);
      res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error processing GMB webhook:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/admin/gmb/stats", isAdmin, adminRateLimit, async (req, res) => {
    try {
      const stats = await storage.getGMBIntegrationStats();
      res.json(stats);
    } catch (error) {
      console.error("Error fetching GMB stats:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/businesses/:id/gmb/reviews/fetch", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to fetch reviews for this business");
      }
      const result = await gmbReviewService.fetchReviews(businessId);
      res.json(result);
    } catch (error) {
      console.error("Error fetching GMB reviews:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch reviews");
    }
  });
  app.post("/api/businesses/:id/gmb/reviews/:reviewId/reply", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId, reviewId } = req.params;
      const { replyText } = req.body;
      if (!replyText || replyText.length < 10) {
        return ApiResponse.badRequest(res, "Reply text must be at least 10 characters");
      }
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to reply to reviews for this business");
      }
      await gmbReviewService.replyToReview(businessId, reviewId, replyText);
      res.json({ message: "Reply posted successfully" });
    } catch (error) {
      console.error("Error replying to review:", error);
      return ApiResponse.internalError(res, error.message || "Failed to post reply");
    }
  });
  app.get("/api/businesses/:id/gmb/reviews/insights", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view review insights");
      }
      const insights = await gmbReviewService.generateInsights(businessId);
      res.json(insights);
    } catch (error) {
      console.error("Error generating review insights:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate insights");
    }
  });
  app.get("/api/businesses/:id/gmb/reviews/monitor", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to monitor reviews");
      }
      const alerts = await gmbReviewService.monitorSentiment(businessId);
      res.json(alerts);
    } catch (error) {
      console.error("Error monitoring reviews:", error);
      return ApiResponse.internalError(res, error.message || "Failed to monitor reviews");
    }
  });
  app.post("/api/businesses/:id/gmb/posts", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const postData = req.body;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to create posts for this business");
      }
      const post = await gmbPostService.createPost(businessId, postData);
      res.json(post);
    } catch (error) {
      console.error("Error creating GMB post:", error);
      return ApiResponse.internalError(res, error.message || "Failed to create post");
    }
  });
  app.get("/api/businesses/:id/gmb/posts", isAuthenticated, async (req, res) => {
    try {
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      const posts2 = await gmbPostService.getBusinessPosts(businessId);
      res.json(posts2);
    } catch (error) {
      console.error("Error fetching GMB posts:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch posts");
    }
  });
  app.patch("/api/businesses/:id/gmb/posts/:postId", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId, postId } = req.params;
      const updates = req.body;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to update posts");
      }
      const post = await gmbPostService.updatePost(postId, updates);
      res.json(post);
    } catch (error) {
      console.error("Error updating GMB post:", error);
      return ApiResponse.internalError(res, error.message || "Failed to update post");
    }
  });
  app.delete("/api/businesses/:id/gmb/posts/:postId", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId, postId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to delete posts");
      }
      await gmbPostService.deletePost(postId);
      res.json({ message: "Post deleted successfully" });
    } catch (error) {
      console.error("Error deleting GMB post:", error);
      return ApiResponse.internalError(res, error.message || "Failed to delete post");
    }
  });
  app.get("/api/businesses/:id/gmb/posts/:postId/metrics", isAuthenticated, async (req, res) => {
    try {
      const { id: businessId, postId } = req.params;
      const metrics = await gmbPostService.getPostMetrics(postId);
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching post metrics:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch metrics");
    }
  });
  app.post("/api/businesses/:id/gmb/posts/generate", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const { type, topic, tone, includeEmoji } = req.body;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const content = await gmbPostService.generatePostContent(businessId, {
        type,
        topic,
        tone,
        includeEmoji
      });
      res.json(content);
    } catch (error) {
      console.error("Error generating post content:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate content");
    }
  });
  app.get("/api/businesses/:id/gmb/insights", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const { startDate, endDate, includeCompetitors } = req.query;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view insights");
      }
      const dateRange = {
        start: startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
        end: endDate ? new Date(endDate) : /* @__PURE__ */ new Date()
      };
      const insights = await gmbInsightsService.fetchLocationInsights(businessId, {
        dateRange,
        includeCompetitors: includeCompetitors === "true"
      });
      res.json(insights);
    } catch (error) {
      console.error("Error fetching insights:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch insights");
    }
  });
  app.post("/api/businesses/:id/gmb/insights/report", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const { reportType, format } = req.body;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const report = await gmbInsightsService.generateReport(businessId, {
        reportType,
        format
      });
      res.json(report);
    } catch (error) {
      console.error("Error generating report:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate report");
    }
  });
  app.get("/api/businesses/:id/gmb/insights/trends", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const { metricType, periods } = req.query;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const trends = await gmbInsightsService.trackPerformanceTrend(
        businessId,
        metricType,
        parseInt(periods) || 12
      );
      res.json(trends);
    } catch (error) {
      console.error("Error tracking trends:", error);
      return ApiResponse.internalError(res, error.message || "Failed to track trends");
    }
  });
  app.get("/api/businesses/:id/gmb/insights/recommendations", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const recommendations = await gmbInsightsService.getActionableInsights(businessId);
      res.json(recommendations);
    } catch (error) {
      console.error("Error getting recommendations:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get recommendations");
    }
  });
  app.post("/api/businesses/:id/gmb/sync/configure", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const config2 = req.body;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      await gmbSyncService.configureSyncSettings({
        businessId,
        ...config2
      });
      res.json({ message: "Sync configuration updated successfully" });
    } catch (error) {
      console.error("Error configuring sync:", error);
      return ApiResponse.internalError(res, error.message || "Failed to configure sync");
    }
  });
  app.post("/api/businesses/:id/gmb/sync/start", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const { type, dataTypes, force } = req.body;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const session2 = await gmbSyncService.startSync(businessId, {
        type,
        dataTypes,
        force
      });
      res.json(session2);
    } catch (error) {
      console.error("Error starting sync:", error);
      return ApiResponse.internalError(res, error.message || "Failed to start sync");
    }
  });
  app.get("/api/businesses/:id/gmb/sync/session/:sessionId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId, sessionId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const status = gmbSyncService.getSyncStatus(sessionId);
      if (!status) {
        return ApiResponse.notFound(res, "Sync session not found");
      }
      res.json(status);
    } catch (error) {
      console.error("Error getting sync status:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get sync status");
    }
  });
  app.post("/api/businesses/:id/gmb/sync/cancel/:sessionId", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId, sessionId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      gmbSyncService.cancelSync(sessionId);
      res.json({ message: "Sync cancelled successfully" });
    } catch (error) {
      console.error("Error cancelling sync:", error);
      return ApiResponse.internalError(res, error.message || "Failed to cancel sync");
    }
  });
  app.get("/api/businesses/:id/gmb/sync/history", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const { limit, offset } = req.query;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const history = await gmbSyncService.getSyncHistory(businessId, {
        limit: parseInt(limit) || 50,
        offset: parseInt(offset) || 0
      });
      res.json(history);
    } catch (error) {
      console.error("Error getting sync history:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get sync history");
    }
  });
  app.get("/api/businesses/:id/gmb/sync/report", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const { startDate, endDate } = req.query;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const dateRange = {
        start: startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
        end: endDate ? new Date(endDate) : /* @__PURE__ */ new Date()
      };
      const report = await gmbSyncService.generateSyncReport(businessId, dateRange);
      res.json(report);
    } catch (error) {
      console.error("Error generating sync report:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate report");
    }
  });
  app.get("/api/gmb/health", async (req, res) => {
    try {
      const { gmbErrorHandler: gmbErrorHandler2 } = await Promise.resolve().then(() => (init_gmbErrorHandler(), gmbErrorHandler_exports));
      const healthStatus = gmbErrorHandler2.getHealthStatus();
      const integrationStats = await storage.getGMBIntegrationStats();
      const overallHealth = {
        ...healthStatus,
        integrationStats,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        uptime: process.uptime(),
        version: "1.0.0"
      };
      const httpStatus = healthStatus.status === "healthy" ? 200 : healthStatus.status === "degraded" ? 200 : 503;
      res.status(httpStatus).json(overallHealth);
    } catch (error) {
      console.error("Error in GMB health check:", error);
      res.status(503).json({
        status: "unhealthy",
        error: error.message,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  app.get("/api/businesses/:id/stripe/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view Stripe status for this business");
      }
      if (!business.stripeAccountId) {
        return ApiResponse.notFound(res, "Stripe Connect account not found");
      }
      const account = await getConnectAccount(business.stripeAccountId);
      if (!account) {
        return ApiResponse.notFound(res, "Stripe account not found");
      }
      const onboardingComplete = isAccountOnboarded(account);
      res.json({
        accountId: account.id,
        chargesEnabled: account.charges_enabled,
        payoutsEnabled: account.payouts_enabled,
        onboardingComplete,
        requirements: account.requirements,
        payoutSchedule: account.settings?.payouts?.schedule
      });
    } catch (error) {
      console.error("Error fetching Stripe status:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch Stripe status");
    }
  });
  app.get("/api/businesses/:id/stripe/balance", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view balance for this business");
      }
      if (!business.stripeAccountId) {
        return ApiResponse.notFound(res, "Stripe Connect account not found");
      }
      const balance = await getAccountBalance(business.stripeAccountId);
      if (!balance) {
        return ApiResponse.notFound(res, "Balance data not found");
      }
      res.json({
        available: balance.available,
        pending: balance.pending
      });
    } catch (error) {
      console.error("Error fetching Stripe balance:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch Stripe balance");
    }
  });
  app.get("/api/businesses/:id/stripe/payouts", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const limit = parseInt(req.query.limit) || 10;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view payouts for this business");
      }
      if (!business.stripeAccountId) {
        return ApiResponse.notFound(res, "Stripe Connect account not found");
      }
      const result = await listPayouts(business.stripeAccountId, limit);
      if (!result) {
        return ApiResponse.notFound(res, "Payout data not found");
      }
      res.json(result);
    } catch (error) {
      console.error("Error fetching Stripe payouts:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch Stripe payouts");
    }
  });
  app.get("/api/businesses/:id/stripe/transactions", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const limit = parseInt(req.query.limit) || 10;
      const startingAfter = req.query.startingAfter;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view transactions for this business");
      }
      if (!business.stripeAccountId) {
        return ApiResponse.notFound(res, "Stripe Connect account not found");
      }
      const result = await listBalanceTransactions(business.stripeAccountId, {
        limit,
        startingAfter
      });
      if (!result) {
        return ApiResponse.notFound(res, "Transaction data not found");
      }
      res.json(result);
    } catch (error) {
      console.error("Error fetching Stripe transactions:", error);
      return ApiResponse.internalError(res, error.message || "Failed to fetch Stripe transactions");
    }
  });
  app.post("/api/businesses/:id/stripe/payouts", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const validationResult = stripePayoutRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", { errors: validationResult.error.errors });
      }
      const { amount, description } = validationResult.data;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to create payouts for this business");
      }
      if (!business.stripeAccountId) {
        return ApiResponse.notFound(res, "Stripe Connect account not found");
      }
      const balance = await getAccountBalance(business.stripeAccountId);
      if (!balance) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const availableBalance = balance.available.find((b) => b.currency === "usd");
      if (!availableBalance || availableBalance.amount < amount) {
        return ApiResponse.badRequest(res, "Insufficient balance for payout", {
          available: availableBalance?.amount || 0,
          requested: amount
        });
      }
      const payout = await createPayout(
        business.stripeAccountId,
        amount,
        "usd",
        description
      );
      if (!payout) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      res.json(payout);
    } catch (error) {
      console.error("Error creating Stripe payout:", error);
      return ApiResponse.internalError(res, error.message || "Failed to create Stripe payout");
    }
  });
  app.post("/api/businesses/:id/stripe/payout-settings", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const validationResult = stripePayoutSettingsSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { interval, delayDays } = validationResult.data;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to update payout settings for this business");
      }
      if (!business.stripeAccountId) {
        return ApiResponse.notFound(res, "Stripe Connect account not found");
      }
      const updatedAccount = await updatePayoutSettings(
        business.stripeAccountId,
        { interval, delayDays }
      );
      if (!updatedAccount) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      res.json({
        accountId: updatedAccount.id,
        payoutSchedule: updatedAccount.settings?.payouts?.schedule
      });
    } catch (error) {
      console.error("Error updating Stripe payout settings:", error);
      return ApiResponse.internalError(res, error.message || "Failed to update Stripe payout settings");
    }
  });
  app.post("/api/stripe/connect/webhook", async (req, res) => {
    try {
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
      if (!webhookSecret) {
        console.error("STRIPE_WEBHOOK_SECRET not configured");
        return ApiResponse.internalError(res, "Webhook secret not configured");
      }
      let event;
      try {
        event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
      } catch (err) {
        console.error("Webhook signature verification failed:", err.message);
        return ApiResponse.badRequest(res, "Webhook signature verification failed");
      }
      await handleConnectWebhook(event, storage);
      res.json({ received: true });
    } catch (error) {
      console.error("Error processing Stripe webhook:", error);
      return ApiResponse.internalError(res, error.message || "Failed to process webhook");
    }
  });
  app.get("/api/businesses/:id/following", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const isFollowing = await storage.isFollowingBusiness(userId, businessId);
      res.json({ isFollowing });
    } catch (error) {
      console.error("Error checking follow status:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.delete("/api/businesses/:id", strictRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;
      const existingBusiness = await storage.getBusinessById(id);
      if (!existingBusiness) {
        return ApiResponse.notFound(res, "Business not found");
      }
      if (existingBusiness.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to delete this business");
      }
      await storage.deleteBusiness(id);
      res.json({ message: "Business deleted successfully" });
    } catch (error) {
      console.error("Error deleting business:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.post("/api/spotlight/rotate", isAuthenticated, isAdmin, adminRateLimit, async (req, res) => {
    try {
      console.log(`Admin spotlight rotation requested by: ${req.adminUser.email} (${req.adminUser.id})`);
      const rotationCheck = await storage.canPerformManualRotation();
      if (!rotationCheck.canRotate) {
        return res.status(429).json({ message: "Rate limited" });
      }
      await storage.rotateSpotlights();
      res.json({
        message: "Spotlight rotation triggered successfully",
        triggeredBy: req.adminUser.email,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Error in admin spotlight rotation:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/businesses/:id/spotlight-history", async (req, res) => {
    try {
      const { id } = req.params;
      const history = await storage.getSpotlightHistory(id);
      res.json(history);
    } catch (error) {
      console.error("Error fetching spotlight history:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/businesses/:id/engagement-metrics", async (req, res) => {
    try {
      const { id } = req.params;
      const metrics = await storage.getEngagementMetrics(id);
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching engagement metrics:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/businesses/:id/calculate-metrics", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const metrics = await storage.calculateEngagementMetrics(id);
      res.json(metrics);
    } catch (error) {
      console.error("Error calculating metrics:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/businesses/:id/score", async (req, res) => {
    try {
      const { id } = req.params;
      const score = await storage.getBusinessScore(id);
      res.json({ score });
    } catch (error) {
      console.error("Error fetching business score:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/spotlight/vote", votingRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = spotlightVoteSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { businessId } = validationResult.data;
      const currentMonth = (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
      const hasVoted = await storage.hasUserVoted(userId, currentMonth);
      if (hasVoted) {
        const existingVote = await storage.getUserVoteForMonth(userId, currentMonth);
        return ApiResponse.badRequest(res, "You have already voted this month", {
          votedBusinessId: existingVote?.businessId
        });
      }
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      const eligibleBusinesses = await storage.getEligibleBusinesses("monthly");
      const isEligible = eligibleBusinesses.some((b) => b.id === businessId);
      if (!isEligible) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const vote = await storage.createSpotlightVote({
        businessId,
        userId,
        month: currentMonth
      });
      res.json({ message: "Vote recorded successfully", vote });
    } catch (error) {
      console.error("Error recording vote:", error);
      if (error.code === "23505" || error.constraint?.includes("unique_user_month_vote")) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/spotlight/votes/:month", async (req, res) => {
    try {
      const { month } = req.params;
      if (!/^\d{4}-\d{2}$/.test(month)) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const voteCounts = await storage.getMonthlyVoteCounts(month);
      res.json(voteCounts);
    } catch (error) {
      console.error("Error fetching vote counts:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/spotlight/user-vote/:month", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { month } = req.params;
      if (!/^\d{4}-\d{2}$/.test(month)) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const userVote = await storage.getUserVoteForMonth(userId, month);
      res.json({
        hasVoted: !!userVote,
        votedBusinessId: userVote?.businessId || null,
        voteDate: userVote?.createdAt || null
      });
    } catch (error) {
      console.error("Error checking user vote status:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/spotlight/votes/:month/:businessId/check", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { month } = req.params;
      const userVote = await storage.getUserVoteForMonth(userId, month);
      res.json({
        hasVoted: !!userVote,
        votedBusinessId: userVote?.businessId
      });
    } catch (error) {
      console.error("Error checking vote status:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/spotlight/eligible/:type", async (req, res) => {
    try {
      const { type } = req.params;
      if (!["daily", "weekly", "monthly"].includes(type)) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const eligibleBusinesses = await storage.getEligibleBusinesses(type);
      res.json(eligibleBusinesses);
    } catch (error) {
      console.error("Error fetching eligible businesses:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/spotlight/voting/eligible", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const businesses3 = await storage.getEligibleForVoting(limit);
      res.json(businesses3);
    } catch (error) {
      console.error("Error fetching eligible voting businesses:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/spotlight/voting/stats", async (req, res) => {
    try {
      const currentMonth = (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
      const stats = await storage.getVotingStats(currentMonth);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching voting stats:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/spotlight/voting/my-votes", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const currentMonth = (/* @__PURE__ */ new Date()).toISOString().slice(0, 7);
      const votes = await storage.getUserVotes(userId, currentMonth);
      res.json(votes);
    } catch (error) {
      console.error("Error fetching user votes:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/businesses/trending", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const trending = await storage.getTrendingBusinesses(limit);
      res.json(trending);
    } catch (error) {
      console.error("Error fetching trending businesses:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/leaderboard/businesses", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const leaderboard = await storage.getTopBusinesses(limit);
      res.json(leaderboard);
    } catch (error) {
      console.error("Error fetching business leaderboard:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/leaderboard/voters", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const leaderboard = await storage.getTopVoters(limit);
      res.json(leaderboard);
    } catch (error) {
      console.error("Error fetching voters leaderboard:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/leaderboard/reviewers", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const leaderboard = await storage.getTopReviewers(limit);
      res.json(leaderboard);
    } catch (error) {
      console.error("Error fetching reviewers leaderboard:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/leaderboard/buyers", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const leaderboard = await storage.getTopBuyers(limit);
      res.json(leaderboard);
    } catch (error) {
      console.error("Error fetching buyers leaderboard:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/admin/spotlight/daily", isAuthenticated, isAdmin, adminRateLimit, async (req, res) => {
    try {
      console.log(`Admin daily spotlight selection by: ${req.adminUser.email}`);
      const selectedBusinesses = await storage.selectDailySpotlights();
      res.json({
        message: "Daily spotlights selected successfully",
        businesses: selectedBusinesses,
        selectedBy: req.adminUser.email
      });
    } catch (error) {
      console.error("Error in admin daily spotlight selection:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/admin/spotlight/weekly", isAuthenticated, isAdmin, adminRateLimit, async (req, res) => {
    try {
      console.log(`Admin weekly spotlight selection by: ${req.adminUser.email}`);
      const selectedBusinesses = await storage.selectWeeklySpotlights();
      res.json({
        message: "Weekly spotlights selected successfully",
        businesses: selectedBusinesses,
        selectedBy: req.adminUser.email
      });
    } catch (error) {
      console.error("Error in admin weekly spotlight selection:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/admin/spotlight/monthly", isAuthenticated, isAdmin, adminRateLimit, async (req, res) => {
    try {
      console.log(`Admin monthly spotlight selection by: ${req.adminUser.email}`);
      const selectedBusinesses = await storage.selectMonthlySpotlight();
      res.json({
        message: "Monthly spotlight selected successfully",
        businesses: selectedBusinesses,
        selectedBy: req.adminUser.email
      });
    } catch (error) {
      console.error("Error in admin monthly spotlight selection:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/admin/spotlight/history/:type/:days", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { type, days } = req.params;
      if (!["daily", "weekly", "monthly"].includes(type)) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const daysNum = parseInt(days);
      if (isNaN(daysNum) || daysNum < 1 || daysNum > 90) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const history = await storage.getRecentSpotlightHistory(
        type,
        daysNum
      );
      res.json({
        history,
        requestedBy: req.adminUser.email,
        type,
        days: daysNum
      });
    } catch (error) {
      console.error("Error fetching admin spotlight history:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/admin/spotlight/archive", isAuthenticated, isAdmin, adminRateLimit, async (req, res) => {
    try {
      console.log(`Admin spotlight archiving by: ${req.adminUser.email}`);
      await storage.archiveExpiredSpotlights();
      res.json({
        message: "Expired spotlights archived successfully",
        archivedBy: req.adminUser.email,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Error in admin spotlight archiving:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/public-objects/:filePath(*)", async (req, res) => {
    const filePath = req.params.filePath;
    const objectStorageService = new ObjectStorageService();
    try {
      const file = await objectStorageService.searchPublicObject(filePath);
      if (!file) {
        return ApiResponse.notFound(res, "File not found");
      }
      objectStorageService.downloadObject(file, res);
    } catch (error) {
      console.error("Error searching for public object:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/objects/:objectPath(*)", isAuthenticated, async (req, res) => {
    const userId = req.user?.claims?.sub;
    const objectStorageService = new ObjectStorageService();
    try {
      const objectFile = await objectStorageService.getObjectEntityFile(
        req.path
      );
      const canAccess = await objectStorageService.canAccessObjectEntity({
        objectFile,
        userId,
        requestedPermission: "read" /* READ */
      });
      if (!canAccess) {
        return res.sendStatus(401);
      }
      objectStorageService.downloadObject(objectFile, res);
    } catch (error) {
      console.error("Error checking object access:", error);
      if (error instanceof ObjectNotFoundError) {
        return res.sendStatus(404);
      }
      return res.sendStatus(500);
    }
  });
  app.use("/stock-images", express.static(path3.join(process.cwd(), "client/src/assets/stock_images")));
  app.use("/attached_assets", express.static(path3.join(process.cwd(), "attached_assets")));
  app.get("/api/images/public/:objectId", async (req, res) => {
    const { objectId } = req.params;
    const objectStorageService = new ObjectStorageService();
    try {
      if (!objectId || !/^[a-zA-Z0-9\-_]+$/.test(objectId)) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const objectPath = `/objects/uploads/${objectId}`;
      const objectFile = await objectStorageService.getObjectEntityFile(objectPath);
      const canAccess = await objectStorageService.canAccessObjectEntity({
        objectFile,
        userId: void 0,
        // No user ID for public access
        requestedPermission: "read" /* READ */
      });
      if (!canAccess) {
        return ApiResponse.forbidden(res, "Access denied - image not public");
      }
      res.set({
        "Cache-Control": "public, max-age=86400",
        // 24 hours
        "ETag": `"${objectId}"`
      });
      const clientETag = req.headers["if-none-match"];
      if (clientETag === `"${objectId}"`) {
        return res.status(304).end();
      }
      objectStorageService.downloadObject(objectFile, res);
    } catch (error) {
      console.error("Error serving public image:", error);
      if (error instanceof ObjectNotFoundError) {
        return ApiResponse.notFound(res, "Image not found");
      }
      return ApiResponse.internalError(res, "Failed to serve image");
    }
  });
  app.post("/api/objects/upload", isAuthenticated, async (req, res) => {
    const objectStorageService = new ObjectStorageService();
    try {
      const validationResult = objectUploadRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { fileType, fileSize } = validationResult.data;
      const uploadURL = await objectStorageService.getObjectEntityUploadURL();
      res.json({ uploadURL });
    } catch (error) {
      console.error("Error getting upload URL:", error);
      return ApiResponse.internalError(res, "Failed to get upload URL");
    }
  });
  app.put("/api/business-images", isAuthenticated, async (req, res) => {
    const validationResult = businessImageUpdateSchema.safeParse(req.body);
    if (!validationResult.success) {
      console.error("[BusinessImages] Validation failed:", validationResult.error.errors);
      return res.status(400).json({
        error: "Validation error",
        message: "Invalid request data",
        errors: validationResult.error.errors
      });
    }
    const { imageURL } = validationResult.data;
    const userId = req.user?.claims?.sub;
    console.log("[BusinessImages] Processing image ACL:", {
      userId,
      imageURLPreview: imageURL.substring(0, 100) + "..."
    });
    try {
      const objectStorageService = new ObjectStorageService();
      const objectPath = await objectStorageService.trySetObjectEntityAclPolicy(
        imageURL,
        {
          owner: userId,
          // Business images should be public so they can be displayed to all users
          visibility: "public"
        }
      );
      console.log("[BusinessImages] ACL set successfully, object path:", objectPath);
      const objectId = objectStorageService.extractObjectIdFromPath(objectPath);
      const publicURL = `/api/images/public/${objectId}`;
      console.log("[BusinessImages] Generated public URL:", publicURL);
      res.status(200).json({
        objectPath,
        publicURL
      });
    } catch (error) {
      console.error("[BusinessImages] Error setting business image:", error);
      return res.status(500).json({
        error: "Failed to process image",
        message: error.message || "Internal server error",
        details: error.stack
      });
    }
  });
  app.post("/api/products", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const productData = insertProductSchema.parse(req.body);
      const product = await storage.createProduct(productData);
      res.json(product);
    } catch (error) {
      console.error("Error creating product:", error);
      if (error.name === "ZodError") {
        return ApiResponse.zodValidation(res, error);
      }
      return ApiResponse.badRequest(res, "Validation error");
    }
  });
  app.get("/api/products/search", publicEndpointRateLimit, async (req, res) => {
    try {
      const q = req.query.q || "";
      const categories = typeof req.query.categories === "string" ? String(req.query.categories).split(",").filter(Boolean) : req.query.categories || [];
      const minPrice = req.query.minPrice ? parseFloat(String(req.query.minPrice)) : void 0;
      const maxPrice = req.query.maxPrice ? parseFloat(String(req.query.maxPrice)) : void 0;
      const inStock = req.query.inStock ? String(req.query.inStock) === "true" : void 0;
      const isDigital = req.query.isDigital ? String(req.query.isDigital) === "true" : void 0;
      const minRating = req.query.minRating ? parseFloat(String(req.query.minRating)) : void 0;
      const tags = typeof req.query.tags === "string" ? String(req.query.tags).split(",").filter(Boolean) : req.query.tags || [];
      const sort = req.query.sort || "rating_desc";
      const page = req.query.page ? parseInt(String(req.query.page)) : 1;
      const pageSize = req.query.pageSize ? parseInt(String(req.query.pageSize)) : 24;
      const { items, total } = await storage.searchProducts(q, {
        categories,
        minPrice,
        maxPrice,
        inStock,
        isDigital,
        minRating,
        tags,
        sort,
        page,
        pageSize,
        includeTotal: true
      });
      res.json({ items, total, page, pageSize });
    } catch (error) {
      console.error("Error searching products:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/products", publicEndpointRateLimit, asyncHandler(async (req, res) => {
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 20, 100);
    const category = req.query.category;
    const products2 = await storage.getProducts(page, limit, category);
    return ApiResponse.success(res, products2);
  }));
  app.get("/api/products/featured", async (req, res) => {
    try {
      const limitParam = parseInt(req.query.limit);
      const limit = Number.isFinite(limitParam) ? Math.min(Math.max(limitParam, 1), 50) : 20;
      const unique = req.query.unique === "images";
      const overFetch = Math.max(limit * 8, 200);
      const raw = await storage.getFeaturedProducts(overFetch);
      if (!unique) {
        return res.json(raw.slice(0, limit));
      }
      const seen = /* @__PURE__ */ new Set();
      const out = [];
      for (const p of raw) {
        const first = Array.isArray(p.images) && p.images[0] ? String(p.images[0]) : "";
        const sig2 = normalizeImageSignature(first || fallbackSignatureFor(p));
        if (seen.has(sig2)) continue;
        seen.add(sig2);
        out.push(p);
        if (out.length >= limit) break;
      }
      return res.json(out);
    } catch (error) {
      console.error("Error fetching featured products:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  function normalizeImageSignature(url) {
    try {
      const u = new URL(url, "https://placeholder.local");
      const host = (u.host || "").toLowerCase();
      const path6 = u.pathname.replace(/\/original$/, "").toLowerCase();
      return `${host}${path6}`;
    } catch {
      return (url || "").toLowerCase().split("?")[0];
    }
  }
  function fallbackSignatureFor(p) {
    const category = (p.category || "default").toLowerCase();
    const id = String(p.id || "");
    let seed = 0;
    for (let i = 0; i < id.length; i++) seed = (seed << 5) - seed + id.charCodeAt(i);
    const bucket = Math.abs(seed) % 8;
    return `fallback://${category}/${bucket}`;
  }
  app.get("/api/businesses/:id/products", async (req, res) => {
    try {
      const { id: businessId } = req.params;
      const products2 = await storage.getProductsByBusiness(businessId);
      res.json(products2);
    } catch (error) {
      console.error("Error fetching business products:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.put("/api/products/:id", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: productId } = req.params;
      const product = await storage.getProductById(productId);
      if (!product) {
        return ApiResponse.notFound(res, "Product not found");
      }
      const business = await storage.getBusinessById(product.businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to edit this product");
      }
      const productData = insertProductSchema.parse({
        ...req.body,
        businessId: product.businessId
        // Preserve original business
      });
      const updatedProduct = await storage.updateProduct(productId, productData);
      res.json(updatedProduct);
    } catch (error) {
      console.error("Error updating product:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.post("/api/products/:productId/images/upload-url", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { productId } = req.params;
      const validationResult = productImageUploadSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { filename } = validationResult.data;
      const product = await storage.getProductById(productId);
      if (!product) {
        return ApiResponse.notFound(res, "Product not found");
      }
      const business = await storage.getBusinessById(product.businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to upload images for this product");
      }
      const allowedExtensions = [".jpg", ".jpeg", ".png", ".webp"];
      const fileExtension = filename.toLowerCase().substring(filename.lastIndexOf("."));
      if (!allowedExtensions.includes(fileExtension)) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const objectStorageService = new ObjectStorageService();
      const { uploadUrl, publicPath } = await objectStorageService.getProductImageUploadURL(
        business.id,
        productId,
        filename
      );
      res.json({
        method: "PUT",
        url: uploadUrl,
        publicPath
      });
    } catch (error) {
      console.error("Error generating upload URL:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate upload URL");
    }
  });
  app.post("/api/products/:productId/images", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { productId } = req.params;
      const validationResult = productImageUrlSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { imageUrl } = validationResult.data;
      const product = await storage.getProductById(productId);
      if (!product) {
        return ApiResponse.notFound(res, "Product not found");
      }
      const business = await storage.getBusinessById(product.businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to modify this product");
      }
      const currentImages = product.images || [];
      if (currentImages.length >= 5) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const updatedImages = [...currentImages, imageUrl];
      const updatedProduct = await storage.updateProductImages(productId, updatedImages);
      res.json(updatedProduct);
    } catch (error) {
      console.error("Error saving product image:", error);
      return ApiResponse.internalError(res, error.message || "Failed to save product image");
    }
  });
  app.delete("/api/products/:productId/images", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { productId } = req.params;
      const { imageUrl } = req.body;
      if (!imageUrl) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const product = await storage.getProductById(productId);
      if (!product) {
        return ApiResponse.notFound(res, "Product not found");
      }
      const business = await storage.getBusinessById(product.businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to modify this product");
      }
      const currentImages = product.images || [];
      const updatedImages = currentImages.filter((img) => img !== imageUrl);
      const updatedProduct = await storage.updateProductImages(productId, updatedImages);
      res.json(updatedProduct);
    } catch (error) {
      console.error("Error deleting product image:", error);
      return ApiResponse.internalError(res, error.message || "Failed to delete product image");
    }
  });
  app.post("/api/posts", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const postData = insertPostSchema.parse(req.body);
      const post = await storage.createPost(postData);
      res.json(post);
    } catch (error) {
      console.error("Error creating post:", error);
      if (error.name === "ZodError") {
        return ApiResponse.zodValidation(res, error);
      }
      return ApiResponse.badRequest(res, "Validation error");
    }
  });
  app.get("/api/posts", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const posts2 = await storage.getRecentPosts(limit);
      res.json(posts2);
    } catch (error) {
      console.error("Error fetching posts:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/businesses/:id/posts", async (req, res) => {
    try {
      const { id: businessId } = req.params;
      const posts2 = await storage.getPostsByBusiness(businessId);
      res.json(posts2);
    } catch (error) {
      console.error("Error fetching business posts:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/posts/:id/like", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: postId } = req.params;
      await storage.likePost(userId, postId);
      res.json({ message: "Successfully liked post" });
    } catch (error) {
      console.error("Error liking post:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.delete("/api/posts/:id/like", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: postId } = req.params;
      await storage.unlikePost(userId, postId);
      res.json({ message: "Successfully unliked post" });
    } catch (error) {
      console.error("Error unliking post:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/posts/:id/liked", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: postId } = req.params;
      const isLiked = await storage.isPostLiked(userId, postId);
      res.json({ isLiked });
    } catch (error) {
      console.error("Error checking like status:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/posts", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const authorId = req.user.claims.sub;
      const postData = insertBlogPostSchema.parse({
        ...req.body,
        authorId
      });
      const post = await blogService.createPost(postData);
      res.json(post);
    } catch (error) {
      console.error("Error creating blog post:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.put("/api/blog/posts/:id", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const postData = updateBlogPostSchema.parse(req.body);
      const post = await blogService.updatePost(id, postData);
      res.json(post);
    } catch (error) {
      console.error("Error updating blog post:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.delete("/api/blog/posts/:id", strictRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const post = await blogService.getPostById(id);
      if (!post) {
        return ApiResponse.notFound(res, "Post not found");
      }
      if (post.authorId !== userId && !req.user.isAdmin) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      await blogService.deletePost(id);
      res.json({ message: "Post deleted successfully" });
    } catch (error) {
      console.error("Error deleting blog post:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/popular", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const period = parseInt(req.query.period) || 30;
      const posts2 = await blogService.getPopularPosts(limit, period);
      res.json(posts2);
    } catch (error) {
      console.error("Error fetching popular posts:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const post = await blogService.getPostById(id);
      if (!post) {
        return ApiResponse.notFound(res, "Post not found");
      }
      res.json(post);
    } catch (error) {
      console.error("Error fetching blog post:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/slug/:slug", async (req, res) => {
    try {
      const { slug } = req.params;
      const post = await blogService.getPostBySlug(slug);
      if (!post) {
        return ApiResponse.notFound(res, "Post not found");
      }
      res.json(post);
    } catch (error) {
      console.error("Error fetching blog post by slug:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts", async (req, res) => {
    try {
      const params = {
        query: req.query.q,
        categoryId: req.query.category,
        tags: req.query.tags ? req.query.tags.split(",") : void 0,
        authorId: req.query.author,
        status: req.query.status || "published",
        startDate: req.query.startDate ? new Date(req.query.startDate) : void 0,
        endDate: req.query.endDate ? new Date(req.query.endDate) : void 0,
        sort: req.query.sort || "newest",
        page: parseInt(req.query.page) || 1,
        limit: parseInt(req.query.limit) || 10
      };
      const result = await blogService.searchPosts(params);
      res.json(result);
    } catch (error) {
      console.error("Error searching blog posts:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/:id/related", async (req, res) => {
    try {
      const { id } = req.params;
      const limit = parseInt(req.query.limit) || 5;
      const posts2 = await blogService.getRelatedPosts(id, limit);
      res.json(posts2);
    } catch (error) {
      console.error("Error fetching related posts:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/categories", businessActionRateLimit2, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const categoryData = insertBlogCategorySchema.parse(req.body);
      const category = await blogService.createCategory(categoryData);
      res.json(category);
    } catch (error) {
      console.error("Error creating category:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.put("/api/blog/categories/:id", businessActionRateLimit2, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const category = await blogService.updateCategory(id, req.body);
      res.json(category);
    } catch (error) {
      console.error("Error updating category:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/categories", async (req, res) => {
    try {
      const categories = await blogService.getCategories();
      res.json(categories);
    } catch (error) {
      console.error("Error fetching categories:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/tags", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const tagData = insertBlogTagSchema.parse(req.body);
      const tag = await blogService.createTag(tagData);
      res.json(tag);
    } catch (error) {
      console.error("Error creating tag:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.get("/api/blog/tags", async (req, res) => {
    try {
      const tags = await blogService.getTags();
      res.json(tags);
    } catch (error) {
      console.error("Error fetching tags:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/posts/:id/tags", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const { tagIds } = req.body;
      await blogService.attachTagsToPost(id, tagIds);
      res.json({ message: "Tags attached successfully" });
    } catch (error) {
      console.error("Error attaching tags:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/posts/:postId/comments", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { postId } = req.params;
      const authorId = req.user.claims.sub;
      const commentData = insertBlogCommentSchema.parse({
        ...req.body,
        postId,
        authorId
      });
      const comment = await blogService.createComment(commentData);
      res.json(comment);
    } catch (error) {
      console.error("Error creating comment:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.put("/api/blog/comments/:id", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const comment = await storage.getBlogCommentById(id);
      if (!comment || comment.authorId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const updateData = updateBlogCommentSchema.parse(req.body);
      const updated = await blogService.updateComment(id, updateData);
      res.json(updated);
    } catch (error) {
      console.error("Error updating comment:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.delete("/api/blog/comments/:id", strictRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.claims.sub;
      const comment = await storage.getBlogCommentById(id);
      if (!comment || comment.authorId !== userId && !req.user.isAdmin) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      await blogService.deleteComment(id);
      res.json({ message: "Comment deleted successfully" });
    } catch (error) {
      console.error("Error deleting comment:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/:postId/comments", async (req, res) => {
    try {
      const { postId } = req.params;
      const options = {
        parentId: req.query.parentId || null,
        page: parseInt(req.query.page) || 1,
        limit: parseInt(req.query.limit) || 20,
        sortBy: req.query.sortBy || "newest"
      };
      const comments = await blogService.getComments(postId, options);
      res.json(comments);
    } catch (error) {
      console.error("Error fetching comments:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.put("/api/blog/comments/:id/moderate", strictRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { approved } = req.body;
      await blogService.moderateComment(id, approved);
      res.json({ message: `Comment ${approved ? "approved" : "rejected"} successfully` });
    } catch (error) {
      console.error("Error moderating comment:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/posts/:id/reactions", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { id: postId } = req.params;
      const userId = req.user.claims.sub;
      const reactionData = insertBlogReactionSchema.parse({
        ...req.body,
        postId,
        userId
      });
      const reaction = await blogService.addReaction(reactionData);
      res.json(reaction);
    } catch (error) {
      console.error("Error adding reaction:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.delete("/api/blog/posts/:id/reactions", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { id: postId } = req.params;
      const userId = req.user.claims.sub;
      const reactionType = req.query.type || "like";
      await blogService.removeReaction(postId, userId, reactionType);
      res.json({ message: "Reaction removed successfully" });
    } catch (error) {
      console.error("Error removing reaction:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/posts/:id/bookmarks", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { id: postId } = req.params;
      const userId = req.user.claims.sub;
      const bookmarkData = insertBlogBookmarkSchema.parse({
        postId,
        userId,
        readingListId: req.body.readingListId,
        notes: req.body.notes
      });
      const bookmark = await blogService.bookmarkPost(bookmarkData);
      res.json(bookmark);
    } catch (error) {
      console.error("Error bookmarking post:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.delete("/api/blog/posts/:id/bookmarks", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { id: postId } = req.params;
      const userId = req.user.claims.sub;
      await blogService.removeBookmark(postId, userId);
      res.json({ message: "Bookmark removed successfully" });
    } catch (error) {
      console.error("Error removing bookmark:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/subscribe", generalAPIRateLimit, async (req, res) => {
    try {
      const subscriptionData = insertBlogSubscriptionSchema.parse(req.body);
      const subscription = await blogService.subscribe(subscriptionData);
      res.json(subscription);
    } catch (error) {
      console.error("Error subscribing:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.delete("/api/blog/unsubscribe/:token", async (req, res) => {
    try {
      const { token } = req.params;
      await blogService.unsubscribe(token);
      res.json({ message: "Unsubscribed successfully" });
    } catch (error) {
      console.error("Error unsubscribing:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/posts/:id/track-view", async (req, res) => {
    try {
      const { id: postId } = req.params;
      const analyticsData = req.body;
      await blogService.trackView(postId, analyticsData);
      res.json({ message: "View tracked" });
    } catch (error) {
      console.error("Error tracking view:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/blog/posts/:id/track-engagement", async (req, res) => {
    try {
      const { id: postId } = req.params;
      const { type, ...data } = req.body;
      await blogService.trackEngagement(postId, type, data);
      res.json({ message: "Engagement tracked" });
    } catch (error) {
      console.error("Error tracking engagement:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/:id/analytics", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id: postId } = req.params;
      const period = {
        start: req.query.start ? new Date(req.query.start) : void 0,
        end: req.query.end ? new Date(req.query.end) : void 0
      };
      const analytics = await blogService.getPostAnalytics(postId, period.start && period.end ? period : void 0);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/:id/seo", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const post = await blogService.getPostById(id);
      if (!post) {
        return ApiResponse.notFound(res, "Post not found");
      }
      const seoAnalysis = await blogService.analyzeSEO(post);
      res.json(seoAnalysis);
    } catch (error) {
      console.error("Error analyzing SEO:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/posts/:id/structured-data", async (req, res) => {
    try {
      const { id } = req.params;
      const post = await blogService.getPostById(id);
      if (!post) {
        return ApiResponse.notFound(res, "Post not found");
      }
      const author = await storage.getUser(post.authorId);
      const siteInfo = {
        name: "The Florida Local",
        url: process.env.SITE_URL || "https://thefloridaLocal.com",
        logo: "/logo.png"
      };
      const structuredData = blogService.generateStructuredData(post, author, siteInfo);
      res.json(structuredData);
    } catch (error) {
      console.error("Error generating structured data:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/sitemap.xml", async (req, res) => {
    try {
      const baseUrl = process.env.SITE_URL || `https://${req.get("host")}`;
      const sitemap = await blogService.generateSitemap(baseUrl);
      res.set("Content-Type", "application/xml");
      res.send(sitemap);
    } catch (error) {
      console.error("Error generating sitemap:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/blog/rss.xml", async (req, res) => {
    try {
      const baseUrl = process.env.SITE_URL || `https://${req.get("host")}`;
      const limit = parseInt(req.query.limit) || 20;
      const rssFeed = await blogService.generateRSSFeed(baseUrl, limit);
      res.set("Content-Type", "application/rss+xml; charset=utf-8");
      res.send(rssFeed);
    } catch (error) {
      console.error("Error generating RSS feed:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/messages", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const senderId = req.user.claims.sub;
      const conversationId = [senderId, req.body.receiverId].sort().join("-");
      const messageData = insertMessageSchema.parse({
        ...req.body,
        senderId,
        conversationId,
        isDelivered: true,
        deliveredAt: /* @__PURE__ */ new Date()
      });
      const message = await storage.createMessage(messageData);
      const { sendMessage: sendMessage2 } = await Promise.resolve().then(() => (init_websocket(), websocket_exports));
      sendMessage2(conversationId, {
        id: message.id,
        senderId: message.senderId,
        content: message.content,
        timestamp: message.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
      });
      res.json(message);
    } catch (error) {
      console.error("Error creating message:", error);
      return res.status(400).json({ message: "Validation error" });
    }
  });
  app.post("/api/messages/upload", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const senderId = req.user.claims.sub;
      const validationResult = messageFileUploadSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { receiverId, file } = validationResult.data;
      const allowedTypes = ["image/jpeg", "image/png", "image/gif", "application/pdf", "text/plain", "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"];
      if (!allowedTypes.includes(file.type)) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const conversationId = [senderId, receiverId].sort().join("-");
      const messageData = insertMessageSchema.parse({
        senderId,
        receiverId,
        conversationId,
        content: `Shared a file: ${file.name}`,
        messageType: "file",
        fileUrl: file.url,
        fileName: file.name,
        fileType: file.type,
        fileSize: file.size,
        isDelivered: true,
        deliveredAt: /* @__PURE__ */ new Date()
      });
      const message = await storage.createMessage(messageData);
      const { sendMessage: sendMessage2 } = await Promise.resolve().then(() => (init_websocket(), websocket_exports));
      sendMessage2(conversationId, {
        id: message.id,
        senderId: message.senderId,
        content: message.content,
        timestamp: message.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
      });
      res.json(message);
    } catch (error) {
      console.error("Error uploading file message:", error);
      return ApiResponse.internalError(res, error.message || "Failed to upload file");
    }
  });
  app.post("/api/messages/share-business", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const senderId = req.user.claims.sub;
      const validationResult = shareBusinessMessageSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { receiverId, businessId } = validationResult.data;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      const conversationId = [senderId, receiverId].sort().join("-");
      const messageData = insertMessageSchema.parse({
        senderId,
        receiverId,
        conversationId,
        content: `Shared a business: ${business.name}`,
        messageType: "business_share",
        sharedBusinessId: businessId,
        networkingContext: {
          businessName: business.name,
          businessCategory: business.category,
          businessLocation: business.location
        },
        isDelivered: true,
        deliveredAt: /* @__PURE__ */ new Date()
      });
      const message = await storage.createMessage(messageData);
      const { sendMessage: sendMessage2 } = await Promise.resolve().then(() => (init_websocket(), websocket_exports));
      sendMessage2(conversationId, {
        id: message.id,
        senderId: message.senderId,
        content: message.content,
        timestamp: message.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
      });
      res.json(message);
    } catch (error) {
      console.error("Error sharing business:", error);
      return ApiResponse.internalError(res, error.message || "Failed to share business");
    }
  });
  app.get("/api/messages/conversations", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const conversations = await storage.getConversations(userId);
      res.json(conversations);
    } catch (error) {
      console.error("Error fetching conversations:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/messages/conversation/:conversationId", isAuthenticated, async (req, res) => {
    try {
      const currentUserId = req.user.claims.sub;
      const { conversationId } = req.params;
      const offset = parseInt(req.query.offset) || 0;
      const limit = parseInt(req.query.limit) || 50;
      const hasAccess = await storage.userHasAccessToConversation(currentUserId, conversationId);
      if (!hasAccess) {
        return ApiResponse.forbidden(res, "Access denied to this conversation");
      }
      const messages2 = await storage.getConversationMessages(conversationId, offset, limit);
      res.json(messages2);
    } catch (error) {
      console.error("Error fetching conversation messages:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/messages/:userId", isAuthenticated, async (req, res) => {
    try {
      const currentUserId = req.user.claims.sub;
      const { userId: otherUserId } = req.params;
      const messages2 = await storage.getMessagesBetweenUsers(currentUserId, otherUserId);
      res.json(messages2);
    } catch (error) {
      console.error("Error fetching messages:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.put("/api/messages/:messageId/read", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { messageId } = req.params;
      const message = await storage.getMessageById(messageId);
      if (!message) {
        return ApiResponse.notFound(res, "Message not found");
      }
      if (message.receiverId !== userId) {
        return ApiResponse.forbidden(res, "Access denied");
      }
      await storage.markMessageAsRead(messageId, /* @__PURE__ */ new Date());
      res.json({ message: "Message marked as read" });
    } catch (error) {
      console.error("Error marking message as read:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/messages/unread-count", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const count2 = await storage.getUnreadMessageCount(userId);
      res.json({ unreadCount: count2 });
    } catch (error) {
      console.error("Error fetching unread message count:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/messages/search", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const query = req.query.q;
      if (!query || query.trim().length < 2) {
        return ApiResponse.badRequest(res, "Search query must be at least 2 characters");
      }
      const messages2 = await storage.searchMessages(userId, query.trim());
      res.json(messages2);
    } catch (error) {
      console.error("Error searching messages:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/cart", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const cartItems2 = await storage.getCartItems(userId);
      res.json(cartItems2);
    } catch (error) {
      console.error("Error fetching cart:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/cart", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const cartData = insertCartItemSchema.parse({
        ...req.body,
        userId
      });
      const product = await storage.getProductById(cartData.productId);
      if (!product) {
        return ApiResponse.notFound(res, "Product not found");
      }
      if (!product.isActive) {
        return ApiResponse.badRequest(res, "Product is not available");
      }
      if (!cartData.quantity || cartData.quantity <= 0) {
        return ApiResponse.badRequest(res, "Invalid quantity");
      }
      if (cartData.quantity > (product.inventory || 0)) {
        return ApiResponse.badRequest(res, `Only ${product.inventory} units available for "${product.name}"`);
      }
      const existingCartItems = await storage.getCartItems(userId);
      const existingItem = existingCartItems.find((item) => item.productId === cartData.productId);
      const totalQuantity = existingItem ? (existingItem.quantity || 0) + (cartData.quantity || 0) : cartData.quantity || 0;
      if (totalQuantity > (product.inventory || 0)) {
        return ApiResponse.badRequest(res, `Cannot add ${cartData.quantity} more. Only ${(product.inventory || 0) - (existingItem?.quantity || 0)} more units available.`);
      }
      const cartItem = await storage.addToCart(userId, cartData.productId, cartData.quantity || 0);
      res.json(cartItem);
    } catch (error) {
      console.error("Error adding to cart:", error);
      if (error.name === "ZodError") {
        return ApiResponse.zodValidation(res, error);
      }
      return ApiResponse.badRequest(res, "Validation error");
    }
  });
  app.put("/api/cart/:productId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { productId } = req.params;
      const validationResult = cartQuantityUpdateSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.zodValidation(res, validationResult.error, req);
      }
      const { quantity: quantityNum } = validationResult.data;
      if (quantityNum === 0) {
        await storage.removeFromCart(userId, productId);
        return res.json({ message: "Item removed from cart" });
      }
      const product = await storage.getProductById(productId);
      if (!product) {
        return ApiResponse.notFound(res, "Product not found");
      }
      if (!product.isActive) {
        return ApiResponse.badRequest(res, "Product is not available");
      }
      if (quantityNum > (product.inventory || 0)) {
        return ApiResponse.badRequest(res, `Only ${product.inventory} units available for "${product.name}"`);
      }
      await storage.updateCartItemQuantity(userId, productId, quantityNum);
      res.json({ message: "Cart updated successfully" });
    } catch (error) {
      console.error("Error updating cart:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.delete("/api/cart/:productId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { productId } = req.params;
      await storage.removeFromCart(userId, productId);
      res.json({ message: "Item removed from cart" });
    } catch (error) {
      console.error("Error removing from cart:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.delete("/api/cart", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      await storage.clearCart(userId);
      res.json({ message: "Cart cleared successfully" });
    } catch (error) {
      console.error("Error clearing cart:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/cart/total", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const total = await storage.getCartTotal(userId);
      res.json({ total });
    } catch (error) {
      console.error("Error fetching cart total:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/create-payment-intent", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = createPaymentIntentSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", {
          errors: validationResult.error.errors
        });
      }
      const { shippingAddress, billingAddress, customerEmail, customerPhone, notes, currency } = validationResult.data;
      const cartItems2 = await storage.getCartItems(userId);
      if (cartItems2.length === 0) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      for (const item of cartItems2) {
        if (!item.product.isActive) {
          return res.status(400).json({
            message: `Product "${item.product.name}" is no longer available`
          });
        }
        if (item.quantity > (item.product.inventory || 0)) {
          return res.status(400).json({
            message: `Only ${item.product.inventory || 0} of "${item.product.name}" available`
          });
        }
      }
      const subtotal = cartItems2.reduce(
        (total2, item) => total2 + parseFloat(item.product.price) * item.quantity,
        0
      );
      const taxAmount = subtotal * 0.08;
      const shippingAmount = cartItems2.some((item) => !item.product.isDigital) ? 5.99 : 0;
      const total = subtotal + taxAmount + shippingAmount;
      const order = await storage.createOrder({
        userId,
        subtotal: subtotal.toFixed(2),
        taxAmount: taxAmount.toFixed(2),
        shippingAmount: shippingAmount.toFixed(2),
        total: total.toFixed(2),
        currency,
        shippingAddress,
        billingAddress,
        customerEmail,
        customerPhone,
        notes,
        status: "pending_payment"
      });
      const orderItemsData = cartItems2.map((item) => ({
        orderId: order.id,
        productId: item.productId,
        productName: item.product.name,
        productPrice: item.product.price,
        quantity: item.quantity,
        totalPrice: (parseFloat(item.product.price) * item.quantity).toFixed(2)
      }));
      await storage.createOrderItems(orderItemsData);
      return res.status(503).json({
        message: "Stripe payment integration not yet configured. Use /api/checkout for manual orders.",
        orderId: order.id
      });
    } catch (error) {
      console.error("Error creating payment intent:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/checkout", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const orderData = insertOrderSchema.parse({
        ...req.body,
        userId
      });
      const cartItems2 = await storage.getCartItems(userId);
      if (cartItems2.length === 0) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const subtotal = cartItems2.reduce(
        (total2, item) => total2 + parseFloat(item.product.price) * item.quantity,
        0
      );
      const taxAmount = subtotal * 0.08;
      const shippingAmount = cartItems2.some((item) => !item.product.isDigital) ? 5.99 : 0;
      const total = subtotal + taxAmount + shippingAmount;
      const order = await storage.createOrder({
        ...orderData,
        subtotal: subtotal.toFixed(2),
        taxAmount: taxAmount.toFixed(2),
        shippingAmount: shippingAmount.toFixed(2),
        total: total.toFixed(2),
        status: "pending"
      });
      const orderItemsData = cartItems2.map((item) => ({
        orderId: order.id,
        productId: item.productId,
        productName: item.product.name,
        productPrice: item.product.price,
        quantity: item.quantity,
        totalPrice: (parseFloat(item.product.price) * item.quantity).toFixed(2)
      }));
      await storage.createOrderItems(orderItemsData);
      res.json({
        order,
        total,
        cartItems: cartItems2.length
      });
    } catch (error) {
      console.error("Error creating checkout:", error);
      if (error.name === "ZodError") {
        return ApiResponse.zodValidation(res, error);
      }
      return ApiResponse.badRequest(res, "Validation error");
    }
  });
  app.get("/api/orders", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const orders2 = await storage.getOrdersByUser(userId);
      res.json(orders2);
    } catch (error) {
      console.error("Error fetching orders:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/orders/:id", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: orderId } = req.params;
      const order = await storage.getOrderById(orderId);
      if (!order) {
        return ApiResponse.notFound(res, "Order not found");
      }
      if (order.userId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to view this order");
      }
      res.json(order);
    } catch (error) {
      console.error("Error fetching order:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/orders/:id/complete", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: orderId } = req.params;
      const validationResult = completeOrderSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.zodValidation(res, validationResult.error, req);
      }
      const { paymentIntentId } = validationResult.data;
      const order = await storage.getOrderById(orderId);
      if (!order || order.userId !== userId) {
        return ApiResponse.notFound(res, "Order not found");
      }
      return res.status(503).json({ message: "Stripe payment verification not yet configured" });
    } catch (error) {
      console.error("Error completing order:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/health", async (req, res) => {
    const redisHealthy = await checkRedisConnection();
    res.json({
      status: "healthy",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime(),
      version: "1.0.0",
      redis: redisHealthy ? "connected" : "disconnected"
    });
  });
  app.get("/api/health", async (req, res) => {
    try {
      const redisHealthy = await checkRedisConnection();
      const { getDatabaseStatus: getDatabaseStatus2, testDatabaseConnection: testDatabaseConnection2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const dbStatus = getDatabaseStatus2();
      const dbHealthCheck = await testDatabaseConnection2().catch(() => false);
      const overallHealthy = dbHealthCheck && (redisHealthy || true);
      res.status(overallHealthy ? 200 : 503).json({
        status: overallHealthy ? "healthy" : "degraded",
        services: {
          database: {
            status: dbHealthCheck ? "connected" : "disconnected",
            isConnected: dbStatus.isConnected,
            lastError: dbStatus.lastError,
            lastErrorTime: dbStatus.lastErrorTime,
            reconnectAttempts: dbStatus.reconnectAttempts,
            pool: {
              idle: dbStatus.poolIdleCount,
              total: dbStatus.poolTotalCount,
              waiting: dbStatus.poolWaitingCount
            }
          },
          auth: "operational",
          storage: "operational",
          redis: {
            status: redisHealthy ? "operational" : "unavailable",
            required: false
            // Redis is optional, falls back to PostgreSQL sessions
          },
          monitoring: {
            sentry: process.env.SENTRY_DSN ? "configured" : "disabled",
            posthog: process.env.POSTHOG_KEY ? "configured" : "disabled"
          }
        },
        uptime: process.uptime(),
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Health check error:", error);
      res.status(503).json({
        status: "unhealthy",
        error: error.message,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  app.get("/api/deployment-status", async (req, res) => {
    try {
      const isProduction = process.env.NODE_ENV === "production";
      const fs4 = await import("fs");
      const path6 = await import("path");
      const { getRegisteredStrategies: getRegisteredStrategies2 } = await Promise.resolve().then(() => (init_auth(), auth_exports));
      const registeredStrategies2 = getRegisteredStrategies2 ? getRegisteredStrategies2() : [];
      let buildInfo = {};
      if (isProduction) {
        const distPath = path6.resolve(process.cwd(), "dist");
        const distPublicPath = path6.resolve(distPath, "public");
        const distIndexPath = path6.resolve(distPath, "index.js");
        const distPublicIndexPath = path6.resolve(distPublicPath, "index.html");
        buildInfo = {
          distIndexJs: fs4.existsSync(distIndexPath),
          distPublicExists: fs4.existsSync(distPublicPath),
          distPublicIndexHtml: fs4.existsSync(distPublicIndexPath)
        };
      }
      res.json({
        status: "ok",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        environment: {
          nodeEnv: process.env.NODE_ENV,
          port: process.env.PORT,
          replitDomains: process.env.REPLIT_DOMAINS || "NOT SET",
          replitDeployment: process.env.REPL_DEPLOYMENT || "NOT SET"
        },
        authentication: {
          registeredStrategies: Array.from(registeredStrategies2 || []),
          strategiesCount: (registeredStrategies2 || []).length
        },
        routes: {
          authLogin: "/api/login",
          authCallback: "/api/callback",
          authLogout: "/api/logout",
          health: "/health",
          apiHealth: "/api/health",
          deploymentStatus: "/api/deployment-status (you are here)"
        },
        build: isProduction ? buildInfo : { status: "development mode" },
        uptime: process.uptime()
      });
    } catch (error) {
      console.error("Deployment status error:", error);
      res.status(500).json({
        status: "error",
        error: error.message,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  app.post("/api/admin/promote", isAuthenticated, async (req, res) => {
    try {
      if (process.env.NODE_ENV === "production") {
        return ApiResponse.forbidden(res, "Admin promotion disabled in production");
      }
      const userId = req.user.claims.sub;
      await storage.updateUserAdminStatus(userId, true);
      res.json({
        message: "User promoted to admin successfully",
        userId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Error promoting user to admin:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.get("/api/notifications", isAuthenticated, async (req, res) => {
    try {
      const notifications = [];
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      return ApiResponse.internalError(res, "Internal server error");
    }
  });
  app.post("/api/businesses/:id/stripe/connect", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const { createConnectAccount: createConnectAccount2, createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      if (business.stripeAccountId) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const account = await createConnectAccount2({
        businessId,
        userId,
        email: req.user.claims.email,
        businessName: business.name,
        businessType: business.category || "Other"
      });
      if (!account) {
        return ApiResponse.internalError(res, "Failed to create Stripe account");
      }
      await storage.updateBusiness(businessId, {
        name: business.name,
        stripeAccountId: account.id,
        stripeOnboardingStatus: "pending"
      });
      const baseUrl = `${req.protocol}://${req.hostname}`;
      const accountLink = await createAccountLink2(
        account.id,
        `${baseUrl}/api/businesses/${businessId}/stripe/refresh`,
        `${baseUrl}/business/${businessId}/settings?stripe=success`
      );
      res.json({
        accountId: account.id,
        onboardingUrl: accountLink?.url
      });
    } catch (error) {
      console.error("Error creating Stripe Connect account:", error);
      return ApiResponse.internalError(res, error.message || "Failed to create Stripe account");
    }
  });
  app.get("/api/businesses/:id/stripe/refresh", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      if (!business.stripeAccountId) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const { createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const baseUrl = `${req.protocol}://${req.hostname}`;
      const accountLink = await createAccountLink2(
        business.stripeAccountId,
        `${baseUrl}/api/businesses/${businessId}/stripe/refresh`,
        `${baseUrl}/business/${businessId}/settings?stripe=success`
      );
      if (!accountLink) {
        return res.status(500).json({ message: "Failed to create account link" });
      }
      res.redirect(accountLink.url);
    } catch (error) {
      console.error("Error refreshing Stripe link:", error);
      return ApiResponse.internalError(res, error.message || "Failed to refresh Stripe link");
    }
  });
  app.get("/api/businesses/:id/stripe/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      if (!business.stripeAccountId) {
        return res.json({ connected: false });
      }
      const { getConnectAccount: getConnectAccount2, isAccountOnboarded: isAccountOnboarded2 } = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const account = await getConnectAccount2(business.stripeAccountId);
      if (!account) {
        return res.json({ connected: false });
      }
      const onboarded = isAccountOnboarded2(account);
      if (onboarded && business.stripeOnboardingStatus !== "active") {
        await storage.updateBusiness(businessId, {
          name: business.name,
          stripeOnboardingStatus: "active"
        });
      }
      res.json({
        connected: true,
        onboarded,
        accountId: account.id,
        chargesEnabled: account.charges_enabled,
        payoutsEnabled: account.payouts_enabled,
        requirements: account.requirements
      });
    } catch (error) {
      console.error("Error getting Stripe status:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get Stripe status");
    }
  });
  app.get("/api/recommendations", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const type = req.query.type || "business";
      const limit = parseInt(req.query.limit) || 10;
      const { getRecommendations: getRecommendations2 } = await Promise.resolve().then(() => (init_aiService(), aiService_exports));
      const recommendations = await getRecommendations2(userId, type, limit);
      res.json({ recommendations });
    } catch (error) {
      console.error("Error getting recommendations:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get recommendations");
    }
  });
  app.get("/api/search", async (req, res) => {
    try {
      const query = req.query.q;
      const type = req.query.type;
      const category = req.query.category;
      const limit = parseInt(req.query.limit) || 20;
      if (!query) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const { semanticSearch: semanticSearch2 } = await Promise.resolve().then(() => (init_aiService(), aiService_exports));
      const results = await semanticSearch2(query, { type, category }, limit);
      res.json({ results });
    } catch (error) {
      console.error("Error performing search:", error);
      return ApiResponse.internalError(res, error.message || "Search failed");
    }
  });
  app.get("/api/ai/business-metrics/:businessId", isAuthenticated, async (req, res) => {
    try {
      const { businessId } = req.params;
      const userId = req.user.claims.sub;
      const business = await storage.getBusinessById(businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Access denied");
      }
      const { generateBusinessMetrics: generateBusinessMetrics2 } = await Promise.resolve().then(() => (init_aiService(), aiService_exports));
      const metrics = await generateBusinessMetrics2(businessId);
      res.json(metrics);
    } catch (error) {
      console.error("Error getting AI business metrics:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get business metrics");
    }
  });
  app.get("/api/ai/business-insights/:businessId", isAuthenticated, async (req, res) => {
    try {
      const { businessId } = req.params;
      const userId = req.user.claims.sub;
      const business = await storage.getBusinessById(businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Access denied");
      }
      const { generateBusinessInsights: generateBusinessInsights2 } = await Promise.resolve().then(() => (init_aiService(), aiService_exports));
      const insights = await generateBusinessInsights2(businessId);
      const { generateAIDashboardInsights: generateAIDashboardInsights2 } = await Promise.resolve().then(() => (init_aiService(), aiService_exports));
      const dashboardInsights = await generateAIDashboardInsights2(businessId, insights);
      res.json(dashboardInsights);
    } catch (error) {
      console.error("Error getting AI business insights:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get business insights");
    }
  });
  app.get("/api/businesses/:id/insights", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const { generateBusinessInsights: generateBusinessInsights2 } = await Promise.resolve().then(() => (init_aiService(), aiService_exports));
      const insights = await generateBusinessInsights2(businessId);
      res.json(insights);
    } catch (error) {
      console.error("Error generating insights:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate insights");
    }
  });
  app.post("/api/ai/generate-content", businessActionRateLimit2, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const validationResult = aiGenerateContentSchema.safeParse(req.body);
      if (!validationResult.success) {
        return ApiResponse.badRequest(res, "Validation error", { errors: validationResult.error.errors });
      }
      const { businessId, platform, idea, tone } = validationResult.data;
      const business = await storage.getBusinessById(businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized to generate content for this business");
      }
      const { generatePlatformContent: generatePlatformContent2 } = await Promise.resolve().then(() => (init_aiService(), aiService_exports));
      const generatedContent = await generatePlatformContent2({
        business,
        platform,
        idea,
        tone: tone || "professional"
      });
      res.json(generatedContent);
    } catch (error) {
      console.error("Error generating AI content:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate content");
    }
  });
  app.post("/api/tax/calculate", isAuthenticated, async (req, res) => {
    try {
      const { calculateSalesTax: calculateSalesTax2 } = await Promise.resolve().then(() => (init_taxService(), taxService_exports));
      const taxData = await calculateSalesTax2(req.body);
      res.json(taxData);
    } catch (error) {
      console.error("Error calculating tax:", error);
      return ApiResponse.internalError(res, error.message || "Failed to calculate tax");
    }
  });
  app.get("/api/tax/categories", async (req, res) => {
    try {
      const { getTaxCategories: getTaxCategories2 } = await Promise.resolve().then(() => (init_taxService(), taxService_exports));
      const categories = await getTaxCategories2();
      res.json({ categories });
    } catch (error) {
      console.error("Error getting tax categories:", error);
      return ApiResponse.internalError(res, error.message || "Failed to get tax categories");
    }
  });
  app.post("/api/orders/:id/invoice", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: orderId } = req.params;
      const order = await storage.getOrderById(orderId);
      if (!order || order.userId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const { generateOrderInvoice: generateOrderInvoice2 } = await Promise.resolve().then(() => (init_invoiceService(), invoiceService_exports));
      const { invoiceNumber, buffer } = await generateOrderInvoice2(orderId);
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="invoice-${invoiceNumber}.pdf"`);
      res.send(buffer);
    } catch (error) {
      console.error("Error generating invoice:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate invoice");
    }
  });
  app.post("/api/stripe/webhook", express.raw({ type: "application/json" }), async (req, res) => {
    try {
      const sig2 = req.headers["stripe-signature"];
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
      if (!webhookSecret) {
        console.error("Stripe webhook secret not configured");
        return ApiResponse.internalError(res, "Webhook secret not configured");
      }
      const { constructWebhookEvent: constructWebhookEvent2 } = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const { handleWebhookEvent: handleWebhookEvent2 } = await Promise.resolve().then(() => (init_stripeWebhooks(), stripeWebhooks_exports));
      let event;
      try {
        event = constructWebhookEvent2(req.body, sig2);
      } catch (err) {
        console.error("Webhook signature verification failed:", err.message);
        return ApiResponse.badRequest(res, "Webhook signature verification failed");
      }
      const result = await handleWebhookEvent2(event, storage);
      if (result.success) {
        res.json({ received: true });
      } else {
        if (result.retryable) {
          return ApiResponse.serviceUnavailable(res, result.error);
        } else {
          return ApiResponse.badRequest(res, result.error);
        }
      }
    } catch (error) {
      console.error("Stripe webhook error:", error);
      return ApiResponse.internalError(res, error.message || "Webhook processing failed");
    }
  });
  app.post("/api/payments/create-intent", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const {
        amount,
        sellerId,
        orderId,
        savePaymentMethod: savePaymentMethod2,
        currency = "usd",
        description
      } = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const stripeCompliance = await Promise.resolve().then(() => (init_stripeCompliance(), stripeCompliance_exports));
      const securityCheck = await stripeCompliance.performSecurityCheck({
        amount,
        currency,
        customerId: userId,
        email: req.user.claims.email,
        ipAddress: req.ip,
        userAgent: req.get("user-agent")
      });
      if (securityCheck.riskLevel === "blocked") {
        return ApiResponse.forbidden(res, "Transaction blocked due to security concerns", { reasons: securityCheck.reasons });
      }
      const customer = await stripePayments.createOrRetrieveCustomer(
        userId,
        req.user.claims.email,
        req.user.claims.name
      );
      const paymentIntent = await stripePayments.createPaymentIntent({
        amount,
        currency,
        sellerId,
        customerId: customer.id,
        description,
        metadata: {
          userId,
          orderId: orderId || "",
          sellerId: sellerId || ""
        },
        savePaymentMethod: savePaymentMethod2,
        use3DSecure: securityCheck.requiresAdditionalVerification
      });
      res.json({
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        requiresAction: paymentIntent.status === "requires_action"
      });
    } catch (error) {
      console.error("Error creating payment intent:", error);
      return ApiResponse.internalError(res, error.message || "Failed to create payment");
    }
  });
  app.post("/api/payments/:id/confirm", isAuthenticated, async (req, res) => {
    try {
      const { id: paymentIntentId } = req.params;
      const { paymentMethodId, returnUrl } = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const paymentIntent = await stripePayments.confirmPaymentIntent(
        paymentIntentId,
        paymentMethodId,
        returnUrl
      );
      res.json({
        status: paymentIntent.status,
        requiresAction: paymentIntent.status === "requires_action",
        nextActionUrl: paymentIntent.next_action?.redirect_to_url?.url
      });
    } catch (error) {
      console.error("Error confirming payment:", error);
      return ApiResponse.internalError(res, error.message || "Failed to confirm payment");
    }
  });
  app.post("/api/payments/:id/cancel", isAuthenticated, async (req, res) => {
    try {
      const { id: paymentIntentId } = req.params;
      const { reason } = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const paymentIntent = await stripePayments.cancelPaymentIntent(
        paymentIntentId,
        reason
      );
      res.json({ status: paymentIntent.status });
    } catch (error) {
      console.error("Error canceling payment:", error);
      return ApiResponse.internalError(res, error.message || "Failed to cancel payment");
    }
  });
  app.post("/api/payments/:id/refund", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id: paymentIntentId } = req.params;
      const { amount, reason } = req.body;
      const payment = await storage.getPaymentByIntentId(paymentIntentId);
      if (!payment) {
        return ApiResponse.notFound(res, "Payment not found");
      }
      const order = await storage.getOrderById(payment.orderId);
      if (!order || order.userId !== userId && !req.user.claims.isAdmin) {
        return ApiResponse.forbidden(res, "Not authorized to refund this payment");
      }
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const refund = await stripePayments.processRefund({
        paymentIntentId,
        amount,
        reason,
        refundApplicationFee: true,
        reverseTransfer: true
      });
      await storage.updateOrderStatus(
        payment.orderId,
        amount ? "partially_refunded" : "refunded"
      );
      res.json({
        refundId: refund.id,
        amount: refund.amount / 100,
        status: refund.status
      });
    } catch (error) {
      console.error("Error processing refund:", error);
      return ApiResponse.internalError(res, error.message || "Failed to process refund");
    }
  });
  app.post("/api/payment-methods/save", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { paymentMethodId, setAsDefault } = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const customer = await stripePayments.createOrRetrieveCustomer(
        userId,
        req.user.claims.email,
        req.user.claims.name
      );
      const paymentMethod = await stripePayments.savePaymentMethod(
        customer.id,
        paymentMethodId,
        setAsDefault
      );
      res.json({
        id: paymentMethod.id,
        type: paymentMethod.type,
        last4: paymentMethod.card?.last4,
        brand: paymentMethod.card?.brand
      });
    } catch (error) {
      console.error("Error saving payment method:", error);
      return ApiResponse.internalError(res, error.message || "Failed to save payment method");
    }
  });
  app.get("/api/payment-methods", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { type = "card" } = req.query;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const customer = await stripePayments.createOrRetrieveCustomer(
        userId,
        req.user.claims.email,
        req.user.claims.name
      );
      const paymentMethods = await stripePayments.listPaymentMethods(
        customer.id,
        type
      );
      res.json(paymentMethods.map((pm) => ({
        id: pm.id,
        type: pm.type,
        last4: pm.card?.last4 || pm.us_bank_account?.last4,
        brand: pm.card?.brand,
        bankName: pm.us_bank_account?.bank_name
      })));
    } catch (error) {
      console.error("Error listing payment methods:", error);
      return ApiResponse.internalError(res, error.message || "Failed to list payment methods");
    }
  });
  app.delete("/api/payment-methods/:id", isAuthenticated, async (req, res) => {
    try {
      const { id: paymentMethodId } = req.params;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      await stripePayments.deletePaymentMethod(paymentMethodId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting payment method:", error);
      return ApiResponse.internalError(res, error.message || "Failed to delete payment method");
    }
  });
  app.post("/api/subscriptions/create", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { priceId, paymentMethodId, trialDays, coupon } = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const customer = await stripePayments.createOrRetrieveCustomer(
        userId,
        req.user.claims.email,
        req.user.claims.name
      );
      const subscription = await stripePayments.createSubscription(
        customer.id,
        priceId,
        {
          trialDays,
          coupon,
          paymentMethodId,
          metadata: { userId }
        }
      );
      res.json({
        subscriptionId: subscription.id,
        status: subscription.status,
        currentPeriodEnd: subscription.current_period_end,
        trialEnd: subscription.trial_end
      });
    } catch (error) {
      console.error("Error creating subscription:", error);
      return ApiResponse.internalError(res, error.message || "Failed to create subscription");
    }
  });
  app.post("/api/subscriptions/:id/cancel", isAuthenticated, async (req, res) => {
    try {
      const { id: subscriptionId } = req.params;
      const { immediately = false } = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const subscription = await stripePayments.cancelSubscription(
        subscriptionId,
        immediately
      );
      res.json({
        subscriptionId: subscription.id,
        status: subscription.status,
        cancelAt: subscription.cancel_at,
        canceledAt: subscription.canceled_at
      });
    } catch (error) {
      console.error("Error canceling subscription:", error);
      return ApiResponse.internalError(res, error.message || "Failed to cancel subscription");
    }
  });
  app.post("/api/connect/accounts/create", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const businessData = req.body;
      const business = await storage.getBusinessById(businessData.businessId);
      if (!business || business.ownerId !== userId) {
        return ApiResponse.forbidden(res, "Not authorized");
      }
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const account = await stripeConnect.createConnectAccount({
        businessId: businessData.businessId,
        userId,
        email: req.user.claims.email,
        businessName: business.name,
        businessType: businessData.businessType || "company",
        country: businessData.country || "US",
        firstName: businessData.firstName,
        lastName: businessData.lastName,
        phone: businessData.phone,
        address: businessData.address,
        taxId: businessData.taxId,
        website: business.website,
        productDescription: business.description
      });
      await storage.updateBusinessStripeInfo(businessData.businessId, {
        stripeAccountId: account.id,
        stripeOnboardingStatus: "pending"
      });
      res.json({
        accountId: account.id,
        chargesEnabled: account.charges_enabled,
        payoutsEnabled: account.payouts_enabled
      });
    } catch (error) {
      console.error("Error creating Connect account:", error);
      res.status(500).json({ message: error.message || "Failed to create seller account" });
    }
  });
  app.post("/api/connect/accounts/:id/onboarding", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const { refreshUrl, returnUrl } = req.body;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const accountLink = await stripeConnect.createAccountLink(
        accountId,
        refreshUrl || `${process.env.APP_URL}/seller/onboarding/refresh`,
        returnUrl || `${process.env.APP_URL}/seller/onboarding/complete`
      );
      res.json({ url: accountLink.url });
    } catch (error) {
      console.error("Error creating onboarding link:", error);
      res.status(500).json({ message: error.message || "Failed to create onboarding link" });
    }
  });
  app.post("/api/connect/accounts/:id/dashboard", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const loginLink = await stripeConnect.createLoginLink(accountId);
      res.json({ url: loginLink.url });
    } catch (error) {
      console.error("Error creating dashboard link:", error);
      res.status(500).json({ message: error.message || "Failed to create dashboard link" });
    }
  });
  app.get("/api/connect/accounts/:id", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const account = await stripeConnect.getConnectAccount(accountId);
      const verificationStatus = await stripeConnect.getVerificationStatus(accountId);
      const capabilities = await stripeConnect.getAccountCapabilities(accountId);
      res.json({
        id: account.id,
        email: account.email,
        chargesEnabled: account.charges_enabled,
        payoutsEnabled: account.payouts_enabled,
        verificationStatus,
        capabilities
      });
    } catch (error) {
      console.error("Error getting Connect account:", error);
      res.status(500).json({ message: error.message || "Failed to get account details" });
    }
  });
  app.patch("/api/connect/accounts/:id/verification", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const updates = req.body;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const account = await stripeConnect.updateVerificationInfo(accountId, updates);
      res.json({
        id: account.id,
        requirementsCount: account.requirements?.currently_due?.length || 0
      });
    } catch (error) {
      console.error("Error updating verification:", error);
      res.status(500).json({ message: error.message || "Failed to update verification" });
    }
  });
  app.get("/api/connect/accounts/:id/balance", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const balance = await stripeConnect.getAccountBalance(accountId);
      res.json({
        available: balance.available.map((b) => ({
          amount: b.amount / 100,
          currency: b.currency
        })),
        pending: balance.pending.map((b) => ({
          amount: b.amount / 100,
          currency: b.currency
        }))
      });
    } catch (error) {
      console.error("Error getting balance:", error);
      res.status(500).json({ message: error.message || "Failed to get balance" });
    }
  });
  app.post("/api/connect/accounts/:id/payouts", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const { amount, currency = "usd", instant = false } = req.body;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const payout = instant ? await stripeConnect.createInstantPayout(accountId, amount, currency) : await stripeConnect.createPayout(accountId, amount, currency);
      res.json({
        payoutId: payout.id,
        amount: payout.amount / 100,
        currency: payout.currency,
        arrivalDate: payout.arrival_date,
        method: payout.method
      });
    } catch (error) {
      console.error("Error creating payout:", error);
      res.status(500).json({ message: error.message || "Failed to create payout" });
    }
  });
  app.get("/api/connect/accounts/:id/payouts", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const { limit = 10 } = req.query;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const payouts = await stripeConnect.listPayouts(accountId, parseInt(limit));
      res.json({
        payouts: payouts.data.map((p) => ({
          id: p.id,
          amount: p.amount / 100,
          currency: p.currency,
          arrivalDate: p.arrival_date,
          status: p.status,
          method: p.method
        })),
        hasMore: payouts.hasMore
      });
    } catch (error) {
      console.error("Error listing payouts:", error);
      res.status(500).json({ message: error.message || "Failed to list payouts" });
    }
  });
  app.patch("/api/connect/accounts/:id/payout-settings", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const settings = req.body;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const account = await stripeConnect.updatePayoutSettings(accountId, settings);
      res.json({
        interval: account.settings?.payouts?.schedule?.interval,
        delayDays: account.settings?.payouts?.schedule?.delay_days
      });
    } catch (error) {
      console.error("Error updating payout settings:", error);
      res.status(500).json({ message: error.message || "Failed to update payout settings" });
    }
  });
  app.post("/api/connect/accounts/:id/bank-accounts", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const bankAccountData = req.body;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const bankAccount = await stripeConnect.addBankAccount(accountId, bankAccountData);
      res.json({
        id: bankAccount.id,
        last4: bankAccount.last4,
        bankName: bankAccount.bank_name,
        status: bankAccount.status
      });
    } catch (error) {
      console.error("Error adding bank account:", error);
      res.status(500).json({ message: error.message || "Failed to add bank account" });
    }
  });
  app.get("/api/connect/accounts/:id/transactions", isAuthenticated, async (req, res) => {
    try {
      const { id: accountId } = req.params;
      const { limit = 10, startingAfter } = req.query;
      const stripeConnect = await Promise.resolve().then(() => (init_stripeConnect(), stripeConnect_exports));
      const transactions = await stripeConnect.listBalanceTransactions(accountId, {
        limit: parseInt(limit),
        startingAfter
      });
      res.json({
        transactions: transactions.data.map((t) => ({
          id: t.id,
          amount: t.amount / 100,
          fee: t.fee / 100,
          net: t.net / 100,
          currency: t.currency,
          type: t.type,
          created: t.created
        })),
        hasMore: transactions.hasMore
      });
    } catch (error) {
      console.error("Error listing transactions:", error);
      res.status(500).json({ message: error.message || "Failed to list transactions" });
    }
  });
  app.get("/api/reports/financial", isAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate, accountId } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start and end dates required" });
      }
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const report = await stripePayments.generateFinancialReport(
        new Date(startDate),
        new Date(endDate),
        {
          accountId,
          includeTransfers: true,
          includePayouts: true,
          includeCharges: true,
          includeRefunds: true
        }
      );
      res.json(report);
    } catch (error) {
      console.error("Error generating financial report:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate report");
    }
  });
  app.get("/api/reports/compliance", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start and end dates required" });
      }
      const stripeCompliance = await Promise.resolve().then(() => (init_stripeCompliance(), stripeCompliance_exports));
      const report = await stripeCompliance.generateComplianceReport(
        new Date(startDate),
        new Date(endDate)
      );
      res.json(report);
    } catch (error) {
      console.error("Error generating compliance report:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate report");
    }
  });
  app.get("/api/reports/tax/:accountId", isAuthenticated, async (req, res) => {
    try {
      const { accountId } = req.params;
      const { year } = req.query;
      if (!year) {
        return res.status(400).json({ message: "Year required" });
      }
      const stripeCompliance = await Promise.resolve().then(() => (init_stripeCompliance(), stripeCompliance_exports));
      const report = await stripeCompliance.generateTaxReport(
        accountId,
        parseInt(year)
      );
      res.json(report);
    } catch (error) {
      console.error("Error generating tax report:", error);
      return ApiResponse.internalError(res, error.message || "Failed to generate report");
    }
  });
  app.post("/api/payments/calculate-fees", async (req, res) => {
    try {
      const { amount, taxRate, couponDiscount } = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const fees = stripePayments.calculateFees(amount, {
        taxRate,
        couponDiscount
      });
      res.json(fees);
    } catch (error) {
      console.error("Error calculating fees:", error);
      res.status(500).json({ message: error.message || "Failed to calculate fees" });
    }
  });
  app.post("/api/coupons/create", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const couponData = req.body;
      const stripePayments = await Promise.resolve().then(() => (init_stripePayments(), stripePayments_exports));
      const coupon = await stripePayments.createCoupon(couponData);
      res.json({
        id: coupon.id,
        name: coupon.name,
        percentOff: coupon.percent_off,
        amountOff: coupon.amount_off ? coupon.amount_off / 100 : null,
        duration: coupon.duration,
        maxRedemptions: coupon.max_redemptions
      });
    } catch (error) {
      console.error("Error creating coupon:", error);
      res.status(500).json({ message: error.message || "Failed to create coupon" });
    }
  });
  app.get("/api/admin/stats", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      const allBusinesses = await storage.getAllBusinesses();
      const allOrders = await storage.getAllOrders();
      const totalRevenue = allOrders.reduce((sum2, order) => {
        const total = parseFloat(order.total || "0");
        return sum2 + total * 100;
      }, 0);
      const pendingApprovals = allBusinesses.filter((b) => !b.isVerified).length;
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
      const activeUsers2 = allUsers.filter((u) => {
        const lastSeen = u.lastSeenAt ? new Date(u.lastSeenAt) : null;
        return lastSeen && lastSeen > oneDayAgo;
      }).length;
      res.json({
        totalUsers: allUsers.length,
        totalBusinesses: allBusinesses.length,
        totalOrders: allOrders.length,
        totalRevenue,
        pendingApprovals,
        activeUsers: activeUsers2
      });
    } catch (error) {
      console.error("Error getting admin stats:", error);
      res.status(500).json({ message: error.message || "Failed to get admin stats" });
    }
  });
  app.get("/api/admin/users", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const users2 = await storage.getAllUsers();
      res.json(users2);
    } catch (error) {
      console.error("Error getting all users:", error);
      res.status(500).json({ message: error.message || "Failed to get users" });
    }
  });
  app.get("/api/admin/businesses", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const businesses3 = await storage.getAllBusinesses();
      res.json(businesses3);
    } catch (error) {
      console.error("Error getting all businesses:", error);
      res.status(500).json({ message: error.message || "Failed to get businesses" });
    }
  });
  app.get("/api/admin/orders", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const orders2 = await storage.getAllOrders();
      res.json(orders2);
    } catch (error) {
      console.error("Error getting all orders:", error);
      res.status(500).json({ message: error.message || "Failed to get orders" });
    }
  });
  app.post("/api/admin/users/:userId/:action", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { userId, action } = req.params;
      const adminId = req.user.claims.sub;
      if (userId === adminId && (action === "ban" || action === "promote")) {
        return ApiResponse.badRequest(res, "Validation error");
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      switch (action) {
        case "promote":
          await storage.updateUser(userId, { isAdmin: !user.isAdmin });
          res.json({ message: `User ${user.isAdmin ? "demoted from" : "promoted to"} admin` });
          break;
        case "ban":
          res.json({ message: "User ban functionality to be implemented" });
          break;
        case "view":
          res.json(user);
          break;
        default:
          res.status(400).json({ message: "Invalid action" });
      }
    } catch (error) {
      console.error("Error performing user action:", error);
      res.status(500).json({ message: error.message || "Failed to perform action" });
    }
  });
  app.post("/api/admin/businesses/:businessId/:action", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { businessId, action } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      switch (action) {
        case "verify":
          await storage.updateBusiness(businessId, { name: business.name, isVerified: !business.isVerified });
          res.json({ message: `Business ${business.isVerified ? "unverified" : "verified"}` });
          break;
        case "activate":
          await storage.updateBusiness(businessId, { name: business.name, isActive: true });
          res.json({ message: "Business activated" });
          break;
        case "deactivate":
          await storage.updateBusiness(businessId, { name: business.name, isActive: false });
          res.json({ message: "Business deactivated" });
          break;
        case "view":
          res.json(business);
          break;
        case "delete":
          res.json({ message: "Business deletion to be implemented" });
          break;
        default:
          res.status(400).json({ message: "Invalid action" });
      }
    } catch (error) {
      console.error("Error performing business action:", error);
      res.status(500).json({ message: error.message || "Failed to perform action" });
    }
  });
  app.get("/api/admin/users/:userId/details", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const businesses3 = await storage.getBusinessesByOwner(userId);
      const orders2 = await storage.getOrdersByUser(userId);
      const { LoyaltyStorage: LoyaltyStorage2 } = await Promise.resolve().then(() => (init_loyaltyStorage(), loyaltyStorage_exports));
      const loyaltyStorage2 = new LoyaltyStorage2();
      const loyaltyAccount = await loyaltyStorage2.getLoyaltyAccount(userId);
      const loyaltyTransactions2 = loyaltyAccount ? await loyaltyStorage2.getTransactionHistory(userId, { limit: 10 }) : [];
      const referrals2 = loyaltyAccount ? await loyaltyStorage2.getUserReferrals(userId) : [];
      res.json({
        user,
        businesses: businesses3,
        orders: orders2,
        loyaltyAccount,
        loyaltyTransactions: loyaltyTransactions2,
        referrals: referrals2,
        stats: {
          totalBusinesses: businesses3.length,
          totalOrders: orders2.length,
          totalSpent: orders2.reduce((sum2, order) => sum2 + parseFloat(order.total || "0"), 0),
          loyaltyPoints: loyaltyAccount?.currentPoints || 0,
          referralCount: referrals2.length
        }
      });
    } catch (error) {
      console.error("Error getting user details:", error);
      res.status(500).json({ message: error.message || "Failed to get user details" });
    }
  });
  app.get("/api/admin/businesses/:businessId/details", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { businessId } = req.params;
      const business = await storage.getBusinessById(businessId);
      if (!business) {
        return ApiResponse.notFound(res, "Business not found");
      }
      const owner = await storage.getUser(business.ownerId);
      const products2 = await storage.getProductsByBusiness(businessId);
      const posts2 = await storage.getPostsByBusiness(businessId);
      const allOrders = await storage.getAllOrders();
      const productIds = new Set(products2.map((p) => p.id));
      const businessOrders = [];
      for (const order of allOrders) {
        const orderItems2 = await storage.getOrderItemsWithProducts(order.id);
        const hasBusinessProducts = orderItems2.some((item) => productIds.has(item.productId));
        if (hasBusinessProducts) {
          businessOrders.push(order);
        }
      }
      const totalRevenue = businessOrders.reduce(
        (sum2, order) => sum2 + parseFloat(order.total || "0"),
        0
      );
      let gmbStatus = null;
      if (business.gmbConnected) {
        gmbStatus = {
          connected: business.gmbConnected,
          verified: business.gmbVerified,
          syncStatus: business.gmbSyncStatus,
          lastSyncAt: business.gmbLastSyncAt,
          lastError: business.gmbLastError
        };
      }
      let stripeStatus = null;
      if (business.stripeAccountId) {
        stripeStatus = {
          accountId: business.stripeAccountId,
          onboardingStatus: business.stripeOnboardingStatus,
          chargesEnabled: business.stripeChargesEnabled,
          payoutsEnabled: business.stripePayoutsEnabled
        };
      }
      res.json({
        business,
        owner,
        products: products2,
        posts: posts2,
        orders: businessOrders,
        gmbStatus,
        stripeStatus,
        stats: {
          totalProducts: products2.length,
          totalPosts: posts2.length,
          totalOrders: businessOrders.length,
          totalRevenue,
          avgRating: parseFloat(business.rating || "0"),
          reviewCount: business.reviewCount || 0,
          followerCount: business.followerCount || 0
        }
      });
    } catch (error) {
      console.error("Error getting business details:", error);
      res.status(500).json({ message: error.message || "Failed to get business details" });
    }
  });
  app.get("/api/admin/content", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { type, status, limit = 50, offset = 0 } = req.query;
      const blogPosts2 = await storage.getBlogPosts({
        status: status || "all",
        limit: Number(limit),
        offset: Number(offset)
      });
      const allPosts = await storage.getAllPosts();
      const allProducts = await storage.getAllProducts();
      res.json({
        blogPosts: {
          items: blogPosts2,
          total: blogPosts2.length
        },
        posts: {
          items: allPosts.slice(Number(offset), Number(offset) + Number(limit)),
          total: allPosts.length
        },
        products: {
          items: allProducts.slice(Number(offset), Number(offset) + Number(limit)),
          total: allProducts.length
        }
      });
    } catch (error) {
      console.error("Error getting content:", error);
      res.status(500).json({ message: error.message || "Failed to get content" });
    }
  });
  app.get("/api/admin/marketing", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { MarketingStorage: MarketingStorage2 } = await Promise.resolve().then(() => (init_marketingStorage(), marketingStorage_exports));
      const marketingStorage2 = new MarketingStorage2();
      const campaigns = await marketingStorage2.getAllCampaigns({ limit: 100 });
      const segments = await marketingStorage2.getAllSegments({ limit: 100 });
      const campaignStats = {
        total: campaigns.length,
        active: campaigns.filter((c) => c.status === "active").length,
        completed: campaigns.filter((c) => c.status === "completed").length,
        draft: campaigns.filter((c) => c.status === "draft").length
      };
      const segmentStats = {
        total: segments.length,
        avgSize: segments.reduce((sum2, s) => sum2 + (s.memberCount || 0), 0) / segments.length || 0
      };
      res.json({
        campaigns: {
          items: campaigns.slice(0, 20),
          stats: campaignStats
        },
        segments: {
          items: segments.slice(0, 20),
          stats: segmentStats
        }
      });
    } catch (error) {
      console.error("Error getting marketing data:", error);
      res.status(500).json({ message: error.message || "Failed to get marketing data" });
    }
  });
  app.get("/api/admin/loyalty", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { LoyaltyStorage: LoyaltyStorage2 } = await Promise.resolve().then(() => (init_loyaltyStorage(), loyaltyStorage_exports));
      const loyaltyStorage2 = new LoyaltyStorage2();
      const accounts = await loyaltyStorage2.getAllAccounts({ limit: 1e3 });
      const tiers = await loyaltyStorage2.getAllTiers();
      const rewards2 = await loyaltyStorage2.getAllRewards({ limit: 100 });
      const redemptions = await loyaltyStorage2.getRecentRedemptions({ limit: 50 });
      const tierDistribution = tiers.map((tier) => ({
        tier: tier.name,
        count: accounts.filter((a) => a.tierId === tier.id).length
      }));
      const totalPointsIssued = accounts.reduce((sum2, a) => sum2 + (a.lifetimePoints || 0), 0);
      const totalPointsAvailable = accounts.reduce((sum2, a) => sum2 + (a.currentPoints || 0), 0);
      res.json({
        accounts: {
          total: accounts.length,
          items: accounts.slice(0, 20)
        },
        tiers: {
          items: tiers,
          distribution: tierDistribution
        },
        rewards: {
          items: rewards2,
          total: rewards2.length
        },
        redemptions: {
          items: redemptions,
          pending: redemptions.filter((r) => r.status === "pending").length,
          completed: redemptions.filter((r) => r.status === "completed").length
        },
        stats: {
          totalPointsIssued,
          totalPointsAvailable,
          activeMembers: accounts.length
        }
      });
    } catch (error) {
      console.error("Error getting loyalty data:", error);
      res.status(500).json({ message: error.message || "Failed to get loyalty data" });
    }
  });
  app.get("/api/admin/system", adminRateLimit, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const redisStatus = await checkRedisConnection();
      const allUsers = await storage.getAllUsers();
      const allBusinesses = await storage.getAllBusinesses();
      const allOrders = await storage.getAllOrders();
      const platformMetrics = {
        totalUsers: allUsers.length,
        totalBusinesses: allBusinesses.length,
        totalOrders: allOrders.length,
        verifiedBusinesses: allBusinesses.filter((b) => b.isVerified).length,
        activeBusinesses: allBusinesses.filter((b) => b.isActive).length
      };
      const systemHealth = {
        redis: redisStatus ? "healthy" : "unhealthy",
        database: "healthy",
        // If we got here, DB is working
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      res.json({
        health: systemHealth,
        metrics: platformMetrics,
        uptime: process.uptime(),
        memory: process.memoryUsage()
      });
    } catch (error) {
      console.error("Error getting system data:", error);
      res.status(500).json({
        message: error.message || "Failed to get system data",
        health: {
          redis: "unknown",
          database: "unhealthy",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    }
  });
  app.get("/api/social-media/accounts/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const accounts = await socialMediaService.getAccounts(req.params.businessId);
      res.json(accounts);
    } catch (error) {
      console.error("Error fetching social media accounts:", error);
      res.status(500).json({ message: error.message || "Failed to fetch accounts" });
    }
  });
  app.post("/api/social-media/accounts/connect", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const data = insertSocialMediaAccountSchema.parse({
        ...req.body,
        userId
      });
      const account = await socialMediaService.connectAccount(data);
      res.json(account);
    } catch (error) {
      console.error("Error connecting social media account:", error);
      res.status(500).json({ message: error.message || "Failed to connect account" });
    }
  });
  app.post("/api/social-media/accounts/:accountId/disconnect", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      await socialMediaService.disconnectAccount(req.params.accountId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error disconnecting account:", error);
      res.status(500).json({ message: error.message || "Failed to disconnect account" });
    }
  });
  app.post("/api/social-media/posts", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const data = insertSocialMediaPostSchema.parse({
        ...req.body,
        authorId: userId
      });
      const post = await socialMediaService.createPost(data);
      res.json(post);
    } catch (error) {
      console.error("Error creating social media post:", error);
      res.status(500).json({ message: error.message || "Failed to create post" });
    }
  });
  app.get("/api/social-media/posts/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { status, platform, campaignId, startDate, endDate } = req.query;
      const posts2 = await storage.getSocialMediaPosts(req.params.businessId, {
        status,
        platform,
        campaignId,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      });
      res.json(posts2);
    } catch (error) {
      console.error("Error fetching social media posts:", error);
      res.status(500).json({ message: error.message || "Failed to fetch posts" });
    }
  });
  app.post("/api/social-media/posts/:postId/publish", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const post = await storage.getSocialMediaPostById(req.params.postId);
      if (!post) {
        return ApiResponse.notFound(res, "Post not found");
      }
      await socialMediaService.publishPost(post);
      res.json({ success: true });
    } catch (error) {
      console.error("Error publishing post:", error);
      res.status(500).json({ message: error.message || "Failed to publish post" });
    }
  });
  app.post("/api/social-media/posts/bulk-schedule", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const { csvData, businessId } = req.body;
      const posts2 = await socialMediaService.bulkSchedulePosts(csvData, businessId, userId);
      res.json(posts2);
    } catch (error) {
      console.error("Error bulk scheduling posts:", error);
      res.status(500).json({ message: error.message || "Failed to bulk schedule posts" });
    }
  });
  app.get("/api/social-media/analytics/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      const dateRange = {
        start: new Date(startDate || Date.now() - 30 * 24 * 60 * 60 * 1e3),
        end: new Date(endDate || Date.now())
      };
      const analytics = await socialMediaService.fetchAnalytics(req.params.businessId, dateRange);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ message: error.message || "Failed to fetch analytics" });
    }
  });
  app.get("/api/social-media/analytics/:businessId/summary", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { platform, dateRange } = req.query;
      const analytics = await storage.getSocialMediaAnalytics(req.params.businessId, {
        platform,
        dateRange: dateRange ? JSON.parse(dateRange) : void 0
      });
      const summary = {
        totalImpressions: analytics.reduce((sum2, a) => sum2 + (a.impressions || 0), 0),
        totalEngagements: analytics.reduce((sum2, a) => sum2 + (a.engagements || 0), 0),
        totalReach: analytics.reduce((sum2, a) => sum2 + (a.reach || 0), 0),
        avgEngagementRate: analytics.reduce((sum2, a) => sum2 + Number(a.engagementRate || 0), 0) / analytics.length,
        platforms: [...new Set(analytics.map((a) => a.platform))]
      };
      res.json({ analytics, summary });
    } catch (error) {
      console.error("Error fetching analytics summary:", error);
      res.status(500).json({ message: error.message || "Failed to fetch analytics summary" });
    }
  });
  app.get("/api/social-media/messages/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      await socialMediaService.fetchMessages(req.params.businessId);
      const messages2 = await storage.getSocialMediaMessages(req.params.businessId, {
        platform: req.query.platform,
        status: req.query.status,
        priority: req.query.priority,
        assignedTo: req.query.assignedTo
      });
      res.json(messages2);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ message: error.message || "Failed to fetch messages" });
    }
  });
  app.post("/api/social-media/messages/:messageId/reply", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { response } = req.body;
      await socialMediaService.sendMessage(req.params.messageId, response);
      res.json({ success: true });
    } catch (error) {
      console.error("Error replying to message:", error);
      res.status(500).json({ message: error.message || "Failed to send reply" });
    }
  });
  app.put("/api/social-media/messages/:messageId/status", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { status, assignedTo, priority } = req.body;
      await storage.updateSocialMediaMessage(req.params.messageId, {
        status,
        assignedTo,
        priority
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating message status:", error);
      res.status(500).json({ message: error.message || "Failed to update message status" });
    }
  });
  app.post("/api/social-media/campaigns", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const data = insertSocialMediaCampaignSchema.parse({
        ...req.body,
        createdBy: userId
      });
      const campaign = await socialMediaService.createCampaign(data);
      res.json(campaign);
    } catch (error) {
      console.error("Error creating campaign:", error);
      res.status(500).json({ message: error.message || "Failed to create campaign" });
    }
  });
  app.get("/api/social-media/campaigns/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const campaigns = await storage.getSocialMediaCampaigns(req.params.businessId);
      res.json(campaigns);
    } catch (error) {
      console.error("Error fetching campaigns:", error);
      res.status(500).json({ message: error.message || "Failed to fetch campaigns" });
    }
  });
  app.put("/api/social-media/campaigns/:campaignId/metrics", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      await socialMediaService.updateCampaignMetrics(req.params.campaignId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating campaign metrics:", error);
      res.status(500).json({ message: error.message || "Failed to update campaign metrics" });
    }
  });
  app.post("/api/social-media/hashtags/suggest", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { content, platform } = req.body;
      const hashtags = await socialMediaService.generateHashtags(content, platform);
      res.json(hashtags);
    } catch (error) {
      console.error("Error generating hashtags:", error);
      res.status(500).json({ message: error.message || "Failed to generate hashtags" });
    }
  });
  app.get("/api/social-media/optimal-times/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const { platform } = req.query;
      const times = await socialMediaService.suggestOptimalTimes(
        req.params.businessId,
        platform
      );
      res.json(times);
    } catch (error) {
      console.error("Error suggesting optimal times:", error);
      res.status(500).json({ message: error.message || "Failed to suggest optimal times" });
    }
  });
  app.post("/api/social-media/listeners", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const data = insertSocialMediaListenerSchema.parse(req.body);
      const listener = await socialMediaService.createListener(data);
      res.json(listener);
    } catch (error) {
      console.error("Error creating listener:", error);
      res.status(500).json({ message: error.message || "Failed to create listener" });
    }
  });
  app.get("/api/social-media/mentions/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const mentions = await socialMediaService.checkMentions(req.params.businessId);
      res.json(mentions);
    } catch (error) {
      console.error("Error fetching mentions:", error);
      res.status(500).json({ message: error.message || "Failed to fetch mentions" });
    }
  });
  app.post("/api/social-media/automation", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const data = insertSocialMediaAutomationSchema.parse(req.body);
      const automation = await socialMediaService.createAutomation(data);
      res.json(automation);
    } catch (error) {
      console.error("Error creating automation:", error);
      res.status(500).json({ message: error.message || "Failed to create automation" });
    }
  });
  app.post("/api/social-media/automation/:automationId/run", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      await socialMediaService.runAutomation(req.params.automationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error running automation:", error);
      res.status(500).json({ message: error.message || "Failed to run automation" });
    }
  });
  app.get("/api/social-media/automation/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const automations = await storage.getSocialMediaAutomations(req.params.businessId);
      res.json(automations);
    } catch (error) {
      console.error("Error fetching automations:", error);
      res.status(500).json({ message: error.message || "Failed to fetch automations" });
    }
  });
  app.post("/api/social-media/team", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const invitedBy = req.user.claims.sub;
      const data = insertSocialMediaTeamSchema.parse({
        ...req.body,
        invitedBy
      });
      const member = await socialMediaService.addTeamMember(data);
      res.json(member);
    } catch (error) {
      console.error("Error adding team member:", error);
      res.status(500).json({ message: error.message || "Failed to add team member" });
    }
  });
  app.put("/api/social-media/team/:memberId/permissions", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      await socialMediaService.updateTeamMemberPermissions(req.params.memberId, req.body);
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating permissions:", error);
      res.status(500).json({ message: error.message || "Failed to update permissions" });
    }
  });
  app.get("/api/social-media/team/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const members = await socialMediaService.getTeamMembers(req.params.businessId);
      res.json(members);
    } catch (error) {
      console.error("Error fetching team members:", error);
      res.status(500).json({ message: error.message || "Failed to fetch team members" });
    }
  });
  app.post("/api/social-media/categories", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const data = insertSocialContentCategorySchema.parse(req.body);
      const category = await socialMediaService.createCategory(data);
      res.json(category);
    } catch (error) {
      console.error("Error creating category:", error);
      res.status(500).json({ message: error.message || "Failed to create category" });
    }
  });
  app.get("/api/social-media/categories/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const categories = await socialMediaService.getCategories(req.params.businessId);
      res.json(categories);
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({ message: error.message || "Failed to fetch categories" });
    }
  });
  app.post("/api/social-media/templates", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const data = insertSocialResponseTemplateSchema.parse(req.body);
      const template = await socialMediaService.createResponseTemplate(data);
      res.json(template);
    } catch (error) {
      console.error("Error creating template:", error);
      res.status(500).json({ message: error.message || "Failed to create template" });
    }
  });
  app.get("/api/social-media/templates/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const templates = await socialMediaService.getResponseTemplates(req.params.businessId);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching templates:", error);
      res.status(500).json({ message: error.message || "Failed to fetch templates" });
    }
  });
  app.post("/api/social-media/templates/:templateId/use", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const content = await socialMediaService.useResponseTemplate(req.params.templateId);
      res.json({ content });
    } catch (error) {
      console.error("Error using template:", error);
      res.status(500).json({ message: error.message || "Failed to use template" });
    }
  });
  app.post("/api/social-media/refresh-tokens/:businessId", generalAPIRateLimit, isAuthenticated, async (req, res) => {
    try {
      const accounts = await storage.getSocialMediaAccounts(req.params.businessId);
      const results = [];
      for (const account of accounts) {
        try {
          await socialMediaService.refreshTokens(account.id);
          results.push({ accountId: account.id, status: "success" });
        } catch (error) {
          results.push({
            accountId: account.id,
            status: "failed",
            error: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
      res.json(results);
    } catch (error) {
      console.error("Error refreshing tokens:", error);
      res.status(500).json({ message: error.message || "Failed to refresh tokens" });
    }
  });
  const { aiContentRoutes } = await Promise.resolve().then(() => (init_aiContentRoutes(), aiContentRoutes_exports));
  app.use("/api/ai", aiContentRoutes);
  const { registerBlogRoutes: registerBlogRoutes2 } = await Promise.resolve().then(() => (init_blogRoutes(), blogRoutes_exports));
  registerBlogRoutes2(app);
  const { registerMarketingRoutes: registerMarketingRoutes2 } = await Promise.resolve().then(() => (init_marketingRoutes(), marketingRoutes_exports));
  registerMarketingRoutes2(app);
  const { registerAIMarketingRoutes: registerAIMarketingRoutes2 } = await Promise.resolve().then(() => (init_aiMarketingRoutes(), aiMarketingRoutes_exports));
  registerAIMarketingRoutes2(app);
  const { registerMarketplaceAgentRoutes: registerMarketplaceAgentRoutes2 } = await Promise.resolve().then(() => (init_marketplaceAgentRoutes(), marketplaceAgentRoutes_exports));
  registerMarketplaceAgentRoutes2(app);
  const { registerLoyaltyRoutes: registerLoyaltyRoutes2 } = await Promise.resolve().then(() => (init_loyaltyRoutes(), loyaltyRoutes_exports));
  registerLoyaltyRoutes2(app);
  const { registerAnalyticsRoutes: registerAnalyticsRoutes2 } = await Promise.resolve().then(() => (init_analyticsRoutes(), analyticsRoutes_exports));
  registerAnalyticsRoutes2(app);
  const { registerMonitoringRoutes: registerMonitoringRoutes2 } = await Promise.resolve().then(() => (init_monitoringRoutes(), monitoringRoutes_exports));
  registerMonitoringRoutes2(app);
  const { errorHandlerMiddleware: errorHandlerMiddleware2, performanceMiddleware: performanceMiddleware2 } = await Promise.resolve().then(() => (init_errorHandler(), errorHandler_exports));
  app.use(performanceMiddleware2);
  app.use(errorHandlerMiddleware2);
  registerSocialAuthRoutes(app);
  startTokenRefreshService(4);
  console.log("\u2705 Automatic social media token refresh service started");
  app.get("/api/admin/token-status", isAuthenticated, isAdmin, async (_req, res) => {
    try {
      const status = await getTokenRefreshStatus();
      res.json({ tokens: status });
    } catch (error) {
      res.status(500).json({ error: "Failed to get token status" });
    }
  });
  const httpServer = createServer(app);
  const { initWebSocket: initWebSocket2 } = await Promise.resolve().then(() => (init_websocket(), websocket_exports));
  initWebSocket2(httpServer);
  return httpServer;
}
var gmbSyncRequestSchema, stripePayoutRequestSchema, stripePayoutSettingsSchema, productImageUploadSchema, productImageUrlSchema, messageFileUploadSchema, shareBusinessMessageSchema, cartQuantityUpdateSchema, createPaymentIntentSchema, completeOrderSchema, aiGenerateContentSchema, adminPromoteUserSchema, gmbVerifyRequestSchema, spotlightVoteSchema, objectUploadRequestSchema, businessImageUpdateSchema;
var init_routes = __esm({
  "server/routes.ts"() {
    "use strict";
    init_storage();
    init_auth();
    init_adminAuth();
    init_rateLimit();
    init_redis();
    init_db();
    init_schema();
    init_objectStorage();
    init_objectAcl();
    init_apiResponse();
    init_gmbService();
    init_businessVerificationService();
    init_dataSyncService();
    init_gmbReviewService();
    init_gmbPostService();
    init_gmbInsightsService();
    init_gmbSyncService();
    init_stripeConnect();
    init_socialAuthRoutes();
    init_socialTokenRefresh();
    init_socialMediaService();
    init_schema();
    init_blogService();
    gmbSyncRequestSchema = z5.object({
      forceUpdate: z5.boolean().default(false),
      syncPhotos: z5.boolean().default(true),
      syncReviews: z5.boolean().default(true),
      syncBusinessInfo: z5.boolean().default(true),
      conflictResolution: z5.enum(["merge", "gmb_wins", "local_wins"]).default("merge")
    });
    stripePayoutRequestSchema = z5.object({
      amount: z5.number().int().min(100, "Amount must be at least $1.00 (100 cents)"),
      description: z5.string().max(500).optional()
    });
    stripePayoutSettingsSchema = z5.object({
      interval: z5.enum(["daily", "weekly", "monthly", "manual"]),
      delayDays: z5.number().int().min(0).optional()
    });
    productImageUploadSchema = z5.object({
      filename: z5.string().min(1).max(255).regex(/\.(jpg|jpeg|png|webp)$/i, "Invalid file type")
    });
    productImageUrlSchema = z5.object({
      imageUrl: z5.string().url().max(2048)
    });
    messageFileUploadSchema = z5.object({
      receiverId: z5.string().uuid(),
      file: z5.object({
        name: z5.string().max(255),
        type: z5.string(),
        size: z5.number().max(10 * 1024 * 1024),
        url: z5.string().url()
      })
    });
    shareBusinessMessageSchema = z5.object({
      receiverId: z5.string().uuid(),
      businessId: z5.string().uuid()
    });
    cartQuantityUpdateSchema = z5.object({
      quantity: z5.number().int().min(0).max(999)
    });
    createPaymentIntentSchema = z5.object({
      shippingAddress: z5.string().max(500),
      billingAddress: z5.string().max(500),
      customerEmail: z5.string().email().max(255),
      customerPhone: z5.string().max(20).optional(),
      notes: z5.string().max(1e3).optional(),
      currency: z5.string().length(3).default("usd")
    });
    completeOrderSchema = z5.object({
      paymentIntentId: z5.string().min(1).max(255)
    });
    aiGenerateContentSchema = z5.object({
      businessId: z5.string().uuid(),
      platform: z5.enum(["facebook", "instagram", "twitter", "linkedin", "general"]),
      idea: z5.string().min(1).max(500),
      tone: z5.enum(["professional", "casual", "friendly", "formal", "humorous"]).default("professional")
    });
    adminPromoteUserSchema = z5.object({
      userId: z5.string().min(1).max(255)
    });
    gmbVerifyRequestSchema = z5.object({
      gmbLocationName: z5.string().min(1).max(500)
    });
    spotlightVoteSchema = z5.object({
      businessId: z5.string().uuid()
    });
    objectUploadRequestSchema = z5.object({
      fileType: z5.string().regex(/^image\/(jpeg|jpg|png|gif|webp)$/i, "Only image files are allowed").optional(),
      fileSize: z5.number().max(5 * 1024 * 1024, "File size must be under 5MB").optional()
    });
    businessImageUpdateSchema = z5.object({
      imageURL: z5.string().url().max(2048)
    });
  }
});

// server/metrics.ts
var metrics_exports = {};
__export(metrics_exports, {
  activeUsers: () => activeUsers,
  aiRequestDuration: () => aiRequestDuration,
  aiRequests: () => aiRequests,
  businessSignups: () => businessSignups,
  cacheHits: () => cacheHits,
  cacheMisses: () => cacheMisses,
  httpRequestDuration: () => httpRequestDuration,
  httpRequestErrors: () => httpRequestErrors,
  httpRequestsTotal: () => httpRequestsTotal,
  metricsMiddleware: () => metricsMiddleware,
  orderValue: () => orderValue,
  ordersCreated: () => ordersCreated,
  paymentAttempts: () => paymentAttempts,
  paymentFailures: () => paymentFailures,
  queueJobDuration: () => queueJobDuration,
  queueJobsProcessed: () => queueJobsProcessed,
  queueSize: () => queueSize,
  setupMetrics: () => setupMetrics,
  trackBusinessEvent: () => trackBusinessEvent,
  updateGaugeMetrics: () => updateGaugeMetrics,
  websocketConnections: () => websocketConnections,
  websocketMessages: () => websocketMessages
});
import { register, collectDefaultMetrics, Counter, Histogram, Gauge } from "prom-client";
function metricsMiddleware(req, res, next) {
  const start = Date.now();
  const route = req.route?.path || req.path;
  const method = req.method;
  res.on("finish", () => {
    const duration = (Date.now() - start) / 1e3;
    const status = res.statusCode.toString();
    httpRequestsTotal.labels(method, route, status).inc();
    httpRequestDuration.labels(method, route, status).observe(duration);
    if (res.statusCode >= 400) {
      httpRequestErrors.labels(method, route, status).inc();
    }
  });
  next();
}
function setupMetrics(app) {
  app.use(metricsMiddleware);
  app.get("/metrics", async (req, res) => {
    try {
      res.set("Content-Type", register.contentType);
      const metrics = await register.metrics();
      res.end(metrics);
    } catch (error) {
      logger.error("Error generating metrics", { error });
      res.status(500).end();
    }
  });
  logger.info("\u2705 Metrics endpoint available at /metrics");
}
function trackBusinessEvent(event, labels = {}) {
  switch (event) {
    case "order_created":
      ordersCreated.labels(labels.payment_method || "unknown", labels.status || "pending").inc();
      if (labels.value) {
        orderValue.observe(parseFloat(labels.value));
      }
      break;
    case "payment_attempt":
      paymentAttempts.labels(labels.provider || "unknown", labels.status || "unknown").inc();
      break;
    case "payment_failure":
      paymentFailures.labels(labels.provider || "unknown", labels.reason || "unknown").inc();
      break;
    case "business_signup":
      businessSignups.labels(labels.category || "unknown").inc();
      break;
    case "websocket_connect":
      websocketConnections.inc();
      break;
    case "websocket_disconnect":
      websocketConnections.dec();
      break;
    case "websocket_message":
      websocketMessages.labels(labels.type || "unknown", labels.direction || "unknown").inc();
      break;
    case "cache_hit":
      cacheHits.labels(labels.cache_type || "unknown").inc();
      break;
    case "cache_miss":
      cacheMisses.labels(labels.cache_type || "unknown").inc();
      break;
    case "queue_job_processed":
      queueJobsProcessed.labels(labels.queue || "unknown", labels.status || "unknown").inc();
      if (labels.duration) {
        queueJobDuration.labels(labels.queue || "unknown").observe(parseFloat(labels.duration));
      }
      break;
    case "ai_request":
      aiRequests.labels(labels.model || "unknown", labels.operation || "unknown").inc();
      if (labels.duration) {
        aiRequestDuration.labels(labels.model || "unknown", labels.operation || "unknown").observe(parseFloat(labels.duration));
      }
      break;
  }
}
async function updateGaugeMetrics() {
  try {
    const { getOnlineUsersCount: getOnlineUsersCount2, io: io2 } = await Promise.resolve().then(() => (init_websocket(), websocket_exports));
    if (io2) {
      const onlineUsers = await getOnlineUsersCount2();
      activeUsers.labels("online").set(onlineUsers);
    }
  } catch (error) {
    logger.debug("Could not update active users metric", { error: error instanceof Error ? error.message : error });
  }
  try {
    const { getQueues: getQueues2, isRedisAvailable: isRedisAvailable2 } = await Promise.resolve().then(() => (init_redis(), redis_exports));
    if (!isRedisAvailable2()) {
      logger.debug("Skipping queue metrics: Redis not available");
      return;
    }
    const { emailQueue: emailQueue2, imageQueue: imageQueue2 } = getQueues2();
    if (emailQueue2) {
      try {
        const emailQueueCounts = await emailQueue2.getJobCounts();
        queueSize.labels("email", "waiting").set(emailQueueCounts.waiting || 0);
        queueSize.labels("email", "active").set(emailQueueCounts.active || 0);
        queueSize.labels("email", "completed").set(emailQueueCounts.completed || 0);
        queueSize.labels("email", "failed").set(emailQueueCounts.failed || 0);
      } catch (error) {
        logger.debug("Could not update email queue metrics", { error: error instanceof Error ? error.message : error });
      }
    }
    if (imageQueue2) {
      try {
        const imageQueueCounts = await imageQueue2.getJobCounts();
        queueSize.labels("image", "waiting").set(imageQueueCounts.waiting || 0);
        queueSize.labels("image", "active").set(imageQueueCounts.active || 0);
        queueSize.labels("image", "completed").set(imageQueueCounts.completed || 0);
        queueSize.labels("image", "failed").set(imageQueueCounts.failed || 0);
      } catch (error) {
        logger.debug("Could not update image queue metrics", { error: error instanceof Error ? error.message : error });
      }
    }
  } catch (error) {
    logger.debug("Could not update queue metrics", { error: error instanceof Error ? error.message : error });
  }
}
var httpRequestsTotal, httpRequestDuration, httpRequestErrors, ordersCreated, orderValue, paymentAttempts, paymentFailures, activeUsers, businessSignups, websocketConnections, websocketMessages, cacheHits, cacheMisses, queueJobsProcessed, queueJobDuration, queueSize, aiRequests, aiRequestDuration;
var init_metrics = __esm({
  "server/metrics.ts"() {
    "use strict";
    init_monitoring();
    collectDefaultMetrics({ register });
    httpRequestsTotal = new Counter({
      name: "http_requests_total",
      help: "Total number of HTTP requests",
      labelNames: ["method", "route", "status"]
    });
    httpRequestDuration = new Histogram({
      name: "http_request_duration_seconds",
      help: "Duration of HTTP requests in seconds",
      labelNames: ["method", "route", "status"],
      buckets: [0.1, 0.5, 1, 2, 5]
    });
    httpRequestErrors = new Counter({
      name: "http_request_errors_total",
      help: "Total number of HTTP request errors",
      labelNames: ["method", "route", "status"]
    });
    ordersCreated = new Counter({
      name: "orders_created_total",
      help: "Total number of orders created",
      labelNames: ["payment_method", "status"]
    });
    orderValue = new Histogram({
      name: "order_value_dollars",
      help: "Order value in dollars",
      buckets: [10, 25, 50, 100, 250, 500, 1e3]
    });
    paymentAttempts = new Counter({
      name: "payment_attempts_total",
      help: "Total number of payment attempts",
      labelNames: ["provider", "status"]
    });
    paymentFailures = new Counter({
      name: "payment_failures_total",
      help: "Total number of payment failures",
      labelNames: ["provider", "reason"]
    });
    activeUsers = new Gauge({
      name: "active_users",
      help: "Number of active users",
      labelNames: ["type"]
    });
    businessSignups = new Counter({
      name: "business_signups_total",
      help: "Total number of business signups",
      labelNames: ["category"]
    });
    websocketConnections = new Gauge({
      name: "websocket_connections",
      help: "Number of active WebSocket connections"
    });
    websocketMessages = new Counter({
      name: "websocket_messages_total",
      help: "Total number of WebSocket messages",
      labelNames: ["type", "direction"]
    });
    cacheHits = new Counter({
      name: "cache_hits_total",
      help: "Total number of cache hits",
      labelNames: ["cache_type"]
    });
    cacheMisses = new Counter({
      name: "cache_misses_total",
      help: "Total number of cache misses",
      labelNames: ["cache_type"]
    });
    queueJobsProcessed = new Counter({
      name: "queue_jobs_processed_total",
      help: "Total number of queue jobs processed",
      labelNames: ["queue", "status"]
    });
    queueJobDuration = new Histogram({
      name: "queue_job_duration_seconds",
      help: "Duration of queue job processing",
      labelNames: ["queue"],
      buckets: [0.1, 0.5, 1, 5, 10, 30, 60]
    });
    queueSize = new Gauge({
      name: "queue_size",
      help: "Current queue size",
      labelNames: ["queue", "status"]
    });
    aiRequests = new Counter({
      name: "ai_requests_total",
      help: "Total number of AI requests",
      labelNames: ["model", "operation"]
    });
    aiRequestDuration = new Histogram({
      name: "ai_request_duration_seconds",
      help: "Duration of AI requests",
      labelNames: ["model", "operation"],
      buckets: [0.1, 0.5, 1, 2, 5, 10]
    });
    setInterval(updateGaugeMetrics, 3e4);
  }
});

// server/middleware/sessionExtension.ts
var sessionExtension_exports = {};
__export(sessionExtension_exports, {
  autoExtendSession: () => autoExtendSession,
  checkSessionExpiry: () => checkSessionExpiry,
  getSessionHealth: () => getSessionHealth
});
function autoExtendSession(req, res, next) {
  if (req.isAuthenticated && req.isAuthenticated() && req.session) {
    const session2 = req.session;
    const now = Date.now();
    const lastActivity = session2.lastActivity || 0;
    const timeSinceActivity = now - lastActivity;
    session2.lastActivity = now;
    if (timeSinceActivity > 6e4) {
      logger.debug("\u{1F504} Session activity updated", {
        userId: req.user?.id,
        timeSinceLastActivity: `${Math.round(timeSinceActivity / 1e3)}s`
      });
    }
    req.session.touch();
  }
  next();
}
function checkSessionExpiry(req, res, next) {
  if (req.isAuthenticated && req.isAuthenticated() && req.session && req.session.cookie) {
    const cookie = req.session.cookie;
    if (cookie.expires) {
      const timeUntilExpiry = cookie.expires.getTime() - Date.now();
      const fiveMinutes = 5 * 60 * 1e3;
      if (timeUntilExpiry < fiveMinutes && timeUntilExpiry > 0) {
        res.setHeader("X-Session-Expiring-Soon", "true");
        res.setHeader("X-Session-Expires-In", Math.round(timeUntilExpiry / 1e3).toString());
        logger.warn("\u23F0 Session expiring soon", {
          userId: req.user?.id,
          expiresIn: `${Math.round(timeUntilExpiry / 1e3)}s`
        });
      }
    }
  }
  next();
}
function getSessionHealth(req) {
  const health = {
    isAuthenticated: req.isAuthenticated ? req.isAuthenticated() : false,
    hasSession: !!req.session
  };
  if (req.session) {
    health.sessionId = req.sessionID;
    if (req.session.cookie && req.session.cookie.expires) {
      health.expiresAt = req.session.cookie.expires;
      health.expiresIn = req.session.cookie.expires.getTime() - Date.now();
    }
    const session2 = req.session;
    if (session2.lastActivity) {
      health.lastActivity = session2.lastActivity;
      health.timeSinceActivity = Date.now() - session2.lastActivity;
    }
  }
  return health;
}
var init_sessionExtension = __esm({
  "server/middleware/sessionExtension.ts"() {
    "use strict";
    init_monitoring();
  }
});

// server/middleware/oauthStateRecovery.ts
var oauthStateRecovery_exports = {};
__export(oauthStateRecovery_exports, {
  cleanupExpiredOAuthAttempts: () => cleanupExpiredOAuthAttempts,
  getOAuthRecoveryHealth: () => getOAuthRecoveryHealth,
  oauthStateErrorHandler: () => oauthStateErrorHandler,
  oauthStateRecoveryMiddleware: () => oauthStateRecoveryMiddleware
});
function oauthStateRecoveryMiddleware(req, res, next) {
  if (!req.path.includes("/callback") && !req.path.includes("/api/auth")) {
    return next();
  }
  const hasCode = !!req.query.code;
  const hasState = !!req.query.state;
  const hasSession = !!req.session;
  if (hasCode && hasState && hasSession) {
    const oauthSession = req.session;
    oauthSession.lastOAuthAttempt = {
      code: String(req.query.code).substring(0, 20) + "...",
      state: String(req.query.state).substring(0, 20) + "...",
      timestamp: Date.now(),
      recovered: false
    };
  }
  next();
}
function oauthStateErrorHandler(err, req, res, next) {
  const isStateError = err.message?.includes("state") || err.message?.includes("Unable to verify authorization request state") || err.name === "AuthorizationError";
  if (isStateError) {
    logger.warn("\u26A0\uFE0F  OAuth state verification failed - attempting recovery", {
      error: err.message,
      hasSession: !!req.session,
      hasCode: !!req.query.code,
      hasState: !!req.query.state,
      sessionID: req.sessionID,
      userAgent: req.get("user-agent")
    });
    captureAuthWarning("OAuth state verification failed", {
      operation: "OAuth Callback",
      sessionId: req.sessionID,
      additionalData: {
        error: err.message,
        hasSession: !!req.session,
        hasCode: !!req.query.code,
        hasState: !!req.query.state
      }
    });
    const canRecover = attemptOAuthRecovery(req, res);
    if (canRecover) {
      return;
    }
    return res.redirect("/login-error?reason=state_mismatch&recoverable=true");
  }
  next(err);
}
function attemptOAuthRecovery(req, res) {
  const oauthSession = req.session;
  const lastAttempt = oauthSession?.lastOAuthAttempt;
  if (lastAttempt && Date.now() - lastAttempt.timestamp < 12e4) {
    logger.warn("\u26A0\uFE0F  Recent OAuth retry detected, showing error page", {
      lastAttemptAge: Date.now() - lastAttempt.timestamp,
      sessionID: req.sessionID
    });
    return false;
  }
  const sessionHasData = req.session && Object.keys(req.session).length > 2;
  if (!sessionHasData) {
    logger.info("\u{1F504} OAuth recovery: Clearing corrupt session and redirecting to login", {
      sessionID: req.sessionID
    });
    req.session.destroy((err) => {
      if (err) {
        logger.error("\u274C Failed to destroy session during recovery:", {
          error: err.message
        });
      }
      res.redirect("/login-error?reason=session_corrupt&action=restart");
    });
    return true;
  }
  logger.warn("\u26A0\uFE0F  OAuth state mismatch with valid session - possible cookie issue", {
    sessionID: req.sessionID,
    sessionKeys: Object.keys(req.session)
  });
  return false;
}
function cleanupExpiredOAuthAttempts(req, res, next) {
  const oauthSession = req.session;
  const lastAttempt = oauthSession?.lastOAuthAttempt;
  if (lastAttempt && Date.now() - lastAttempt.timestamp > 6e5) {
    delete oauthSession.lastOAuthAttempt;
    logger.debug("\u{1F9F9} Cleaned up expired OAuth attempt from session");
  }
  next();
}
function getOAuthRecoveryHealth() {
  return {
    status: "operational",
    features: {
      stateRecovery: "enabled",
      sessionCleanup: "enabled",
      errorHandling: "enabled"
    }
  };
}
var init_oauthStateRecovery = __esm({
  "server/middleware/oauthStateRecovery.ts"() {
    "use strict";
    init_monitoring();
    init_authSentry();
  }
});

// server/bootstrap.ts
init_config();
init_monitoring();
init_db();
init_session();
init_auth();
import express2 from "express";
import { createServer as createServer2 } from "http";
import helmet from "helmet";
import cors from "cors";
import passport4 from "passport";

// server/router/index.ts
init_monitoring();

// server/health.ts
init_db();
init_redis();
init_monitoring();
async function getHealthStatus() {
  const errors = [];
  let overallStatus = "healthy";
  const dbStatus = getDatabaseStatus();
  const dbHealthy = await testDatabaseConnection().catch(() => false);
  if (!dbHealthy) {
    errors.push("Database connection failed");
    overallStatus = "unhealthy";
  }
  const redisConnected2 = await checkRedisConnection().catch(() => false);
  const redisAvail = isRedisAvailable();
  if (!redisConnected2 && process.env.REDIS_HOST) {
    overallStatus = overallStatus === "unhealthy" ? "unhealthy" : "degraded";
  }
  const healthStatus = {
    status: overallStatus,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    uptime: process.uptime(),
    services: {
      database: {
        status: dbHealthy ? "connected" : dbStatus.isConnected ? "connected" : "disconnected",
        details: {
          poolIdleCount: dbStatus.poolIdleCount,
          poolTotalCount: dbStatus.poolTotalCount,
          poolWaitingCount: dbStatus.poolWaitingCount,
          lastError: dbStatus.lastError,
          lastErrorTime: dbStatus.lastErrorTime,
          reconnectAttempts: dbStatus.reconnectAttempts
        }
      },
      redis: {
        status: process.env.REDIS_HOST ? redisConnected2 ? "connected" : "disconnected" : "not_configured",
        available: redisAvail
      },
      session: {
        status: "active",
        store: redisConnected2 ? "redis" : dbHealthy ? "postgresql" : "memory"
      }
    },
    ...errors.length > 0 && { errors }
  };
  return healthStatus;
}
async function healthCheckHandler(req, res) {
  try {
    const health = await getHealthStatus();
    const statusCode = health.status === "healthy" ? 200 : health.status === "degraded" ? 200 : 503;
    res.status(statusCode).json(health);
  } catch (error) {
    logger.error("Health check failed:", error);
    res.status(503).json({
      status: "unhealthy",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function simpleHealthCheck(req, res) {
  res.status(200).json({ status: "ok" });
}

// server/auth/routes.ts
init_monitoring();
init_authMetrics();
import { Router } from "express";
import passport2 from "passport";

// server/middleware/sessionPersistenceCheck.ts
init_monitoring();
init_authSentry();
init_authMetrics();
async function verifySessionPersistence(req, sessionId, userId, callback) {
  await new Promise((resolve) => setTimeout(resolve, 100));
  const session2 = req.session;
  if (!session2) {
    logger.error("\u274C Session verification failed: No session object", {
      sessionId,
      userId
    });
    captureAuthWarning("Session persistence check failed - no session", {
      operation: "Session Persistence Check",
      userId,
      sessionId
    });
    authMetrics.recordSessionError("store", "Session object missing after login", userId);
    callback(false);
    return;
  }
  const passportUser = session2.passport?.user;
  if (!passportUser) {
    logger.error("\u274C Session verification failed: No passport user in session", {
      sessionId,
      userId,
      sessionKeys: Object.keys(session2)
    });
    captureAuthWarning("Session persistence check failed - no passport user", {
      operation: "Session Persistence Check",
      userId,
      sessionId,
      additionalData: {
        sessionKeys: Object.keys(session2)
      }
    });
    authMetrics.recordSessionError("store", "Passport user missing from session", userId);
    callback(false);
    return;
  }
  if (passportUser !== userId) {
    logger.error("\u274C Session verification failed: User ID mismatch", {
      sessionId,
      expectedUserId: userId,
      actualUserId: passportUser
    });
    captureAuthWarning("Session persistence check failed - user ID mismatch", {
      operation: "Session Persistence Check",
      userId,
      sessionId,
      additionalData: {
        expectedUserId: userId,
        actualUserId: passportUser
      }
    });
    authMetrics.recordSessionError("store", "User ID mismatch in session", userId);
    callback(false);
    return;
  }
  if (req.sessionStore && typeof req.sessionStore.get === "function") {
    req.sessionStore.get(sessionId, (err, sessionData) => {
      if (err) {
        logger.warn("\u26A0\uFE0F  Session verification warning: Could not read session from store", {
          sessionId,
          userId,
          error: err.message
        });
        captureAuthWarning("Session persistence check - store read error", {
          operation: "Session Persistence Check",
          userId,
          sessionId,
          additionalData: {
            error: err.message
          }
        });
        callback(true);
        return;
      }
      if (!sessionData) {
        logger.error("\u274C Session verification failed: Session not found in store", {
          sessionId,
          userId
        });
        captureAuthWarning("Session persistence check failed - not in store", {
          operation: "Session Persistence Check",
          userId,
          sessionId
        });
        authMetrics.recordSessionError("store", "Session not found in store after login", userId);
        callback(false);
        return;
      }
      logger.info("\u2705 Session persistence verified", {
        sessionId,
        userId,
        hasPassportUser: !!sessionData.passport?.user
      });
      callback(true);
    });
  } else {
    logger.debug("\u2139\uFE0F  Session store does not support verification, assuming success", {
      sessionId,
      userId
    });
    callback(true);
  }
}

// server/auth/routes.ts
var router = Router();
function getStrategyName(req) {
  let host = req.get("host") || req.hostname || "localhost";
  host = host.split(":")[0];
  const strategyName = `replitauth:${host}`;
  logger.debug("\u{1F50D} Selecting auth strategy:", { rawHost: req.get("host"), cleanedHost: host, strategyName });
  return strategyName;
}
router.get("/api/login", (req, res, next) => {
  logger.info("\u{1F510} Login request received", {
    ip: req.ip,
    userAgent: req.get("user-agent"),
    host: req.get("host")
  });
  const strategyName = getStrategyName(req);
  passport2.authenticate(strategyName, {
    failureRedirect: "/login-error",
    failureMessage: true
  })(req, res, next);
});
var handleCallback = (req, res, next) => {
  const loginStart = Date.now();
  logger.info("\u{1F510} OAuth callback received", {
    query: Object.keys(req.query),
    hasCode: !!req.query.code,
    hasState: !!req.query.state,
    code: req.query.code ? `${String(req.query.code).substring(0, 10)}...` : "none",
    state: req.query.state ? `${String(req.query.state).substring(0, 10)}...` : "none",
    host: req.get("host"),
    sessionID: req.sessionID,
    hasSession: !!req.session,
    cookies: req.headers.cookie ? "present" : "missing"
  });
  const strategyName = getStrategyName(req);
  logger.info(`   - Using strategy: ${strategyName}`);
  passport2.authenticate(strategyName, {
    failureRedirect: "/login-error",
    failureMessage: true
  }, (err, user, info) => {
    logger.info("\u{1F510} Passport authenticate callback invoked", {
      hasError: !!err,
      hasUser: !!user,
      hasInfo: !!info,
      userKeys: user ? Object.keys(user) : "none",
      infoKeys: info ? Object.keys(info) : "none"
    });
    if (err) {
      const duration = Date.now() - loginStart;
      authMetrics.recordLoginAttempt("failure", duration, void 0, err.message);
      logger.error("\u274C OAuth callback error:", {
        message: err.message,
        stack: err.stack
      });
      return res.redirect("/login-error?reason=auth_failed");
    }
    if (!user) {
      const duration = Date.now() - loginStart;
      authMetrics.recordLoginAttempt("failure", duration, void 0, "No user returned from auth");
      const debugInfo = {
        info: JSON.stringify(info),
        hasError: !!err,
        errorMessage: err?.message,
        strategyName,
        host: req.get("host")
      };
      logger.error("\u26A0\uFE0F  OAuth callback: No user returned", debugInfo);
      const errorDetails = encodeURIComponent(JSON.stringify(debugInfo));
      return res.redirect(`/login-error?reason=no_user&debug=${errorDetails}`);
    }
    logger.info("\u2705 User object received from strategy:", {
      userId: user.id,
      email: user.email,
      hasFirstName: !!user.firstName,
      hasLastName: !!user.lastName,
      isNewUser: info?.isNewUser
    });
    logger.info("   - About to call req.logIn()...");
    req.logIn(user, (loginErr) => {
      if (loginErr) {
        const duration2 = Date.now() - loginStart;
        authMetrics.recordLoginAttempt("failure", duration2, user.id, loginErr.message);
        authMetrics.recordSessionError("store", loginErr.message, user.id);
        logger.error("\u274C Session login error:", {
          message: loginErr.message,
          userId: user.id,
          sessionID: req.sessionID
        });
        return res.redirect("/login-error?reason=session_failed");
      }
      const duration = Date.now() - loginStart;
      authMetrics.recordLoginAttempt("success", duration, user.id);
      authMetrics.addActiveSession(req.sessionID);
      logger.info("\u2705 req.logIn() completed successfully");
      logger.info("   - Session after login:", {
        sessionID: req.sessionID,
        hasPassport: !!req.session.passport,
        passportUser: req.session.passport?.user,
        sessionKeys: Object.keys(req.session)
      });
      logger.info("\u{1F36A} Session cookie info", {
        setCookieHeaders: res.getHeader("set-cookie"),
        cookieFromRequest: req.headers.cookie
      });
      logger.info("\u{1F50D} Verifying session persistence...");
      verifySessionPersistence(req, req.sessionID, user.id, (success) => {
        if (!success) {
          logger.error("\u274C Session persistence verification failed!", {
            userId: user.id,
            sessionID: req.sessionID
          });
        } else {
          logger.info("\u2705 Session persistence verified - user fully authenticated");
        }
        if (info?.isNewUser) {
          logger.info("\u{1F195} New user - redirecting to subscriptions");
          return res.redirect("/subscription?welcome=true");
        }
        logger.info("\u2705 Existing user - redirecting to home");
        res.redirect("/");
      });
    });
  })(req, res, next);
};
router.get("/api/callback", handleCallback);
router.get("/api/auth/callback", handleCallback);
router.post("/api/logout", (req, res, next) => {
  const userId = req.user ? req.user.id : "unknown";
  const sessionId = req.sessionID;
  logger.info("\u{1F510} Logout request", { userId });
  req.logout((err) => {
    if (err) {
      logger.error("\u274C Logout error:", {
        message: err.message,
        userId
      });
      return next(err);
    }
    req.session.destroy((destroyErr) => {
      if (destroyErr) {
        logger.error("\u274C Session destroy error:", {
          message: destroyErr.message,
          userId
        });
      }
      authMetrics.removeActiveSession(sessionId);
      logger.info("\u2705 User logged out successfully", { userId });
      res.redirect("/");
    });
  });
});
router.get("/api/logout", (req, res, next) => {
  const userId = req.user ? req.user.id : "unknown";
  const sessionId = req.sessionID;
  logger.info("\u{1F510} Logout request (GET)", { userId });
  req.logout((err) => {
    if (err) {
      logger.error("\u274C Logout error:", {
        message: err.message,
        userId
      });
      return next(err);
    }
    req.session.destroy((destroyErr) => {
      if (destroyErr) {
        logger.error("\u274C Session destroy error:", {
          message: destroyErr.message,
          userId
        });
      }
      authMetrics.removeActiveSession(sessionId);
      logger.info("\u2705 User logged out successfully", { userId });
      res.redirect("/");
    });
  });
});
function createAuthRouter() {
  logger.info("\u{1F527} Creating auth router...");
  logger.info("   - GET /api/login");
  logger.info("   - GET /api/callback (primary)");
  logger.info("   - GET /api/auth/callback (alternative)");
  logger.info("   - POST /api/logout");
  logger.info("   - GET /api/logout");
  logger.info("   \u2139\uFE0F  Note: /api/auth/user handled in routes.ts");
  return router;
}

// server/routes/authMetricsRoutes.ts
init_authMetrics();
init_auth();
init_session();
init_monitoring();
import { Router as Router2 } from "express";
var router2 = Router2();
router2.get("/api/metrics/auth", (req, res) => {
  try {
    const metrics = authMetrics.getMetrics();
    const circuitBreakerStatus = getOidcCircuitBreakerStatus();
    const sessionStore = getCurrentSessionStore();
    const response = {
      ...metrics,
      circuitBreaker: circuitBreakerStatus,
      sessionStore: {
        type: sessionStore?.type || "unknown"
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    logger.debug("\u{1F4CA} Auth metrics requested", {
      requestedBy: req.user?.id || "anonymous",
      metricsCount: metrics.overview.totalMetrics
    });
    res.json(response);
  } catch (error) {
    logger.error("\u274C Failed to retrieve auth metrics:", {
      message: error.message
    });
    res.status(500).json({
      error: "Failed to retrieve metrics",
      message: error.message
    });
  }
});
router2.get("/api/metrics/auth/prometheus", (req, res) => {
  try {
    const prometheusMetrics = authMetrics.getPrometheusMetrics();
    logger.debug("\u{1F4CA} Prometheus auth metrics requested", {
      requestedBy: req.user?.id || "anonymous"
    });
    res.set("Content-Type", "text/plain; version=0.0.4");
    res.send(prometheusMetrics);
  } catch (error) {
    logger.error("\u274C Failed to retrieve Prometheus metrics:", {
      message: error.message
    });
    res.status(500).send("# Error retrieving metrics\n");
  }
});
router2.post("/api/metrics/auth/reset", (req, res) => {
  try {
    authMetrics.reset();
    logger.warn("\u26A0\uFE0F  Auth metrics manually reset", {
      resetBy: req.user?.id || "anonymous"
    });
    res.json({
      success: true,
      message: "Auth metrics have been reset"
    });
  } catch (error) {
    logger.error("\u274C Failed to reset auth metrics:", {
      message: error.message
    });
    res.status(500).json({
      error: "Failed to reset metrics",
      message: error.message
    });
  }
});
function createAuthMetricsRouter() {
  logger.info("\u{1F527} Creating auth metrics router...");
  logger.info("   - GET /api/metrics/auth (JSON format)");
  logger.info("   - GET /api/metrics/auth/prometheus (Prometheus format)");
  logger.info("   - POST /api/metrics/auth/reset (reset metrics)");
  return router2;
}

// server/router/index.ts
async function mountRoutes(app) {
  logger.info("\u{1F6E3}\uFE0F  Mounting routes in guaranteed order...");
  logger.info("\n=== PHASE 1: Health & System Routes ===");
  app.get("/health", simpleHealthCheck);
  app.get("/api/health", healthCheckHandler);
  logger.info("   \u2705 GET /health");
  logger.info("   \u2705 GET /api/health");
  logger.info("\n=== PHASE 2: Metrics Routes ===");
  logger.info("   \u2139\uFE0F  App metrics already mounted by setupMetrics()");
  const authMetricsRouter = createAuthMetricsRouter();
  app.use(authMetricsRouter);
  logger.info("   \u2705 Auth metrics router mounted");
  logger.info("\n=== PHASE 3: Authentication Routes ===");
  const authRouter = createAuthRouter();
  app.use(authRouter);
  logger.info("   \u2705 Auth router mounted");
  logger.info("\n=== PHASE 4: Application Routes ===");
  logger.info("   \u2139\uFE0F  Loading registerRoutes from routes.ts...");
  try {
    const { registerRoutes: registerRoutes2 } = await Promise.resolve().then(() => (init_routes(), routes_exports));
    await registerRoutes2(app);
    logger.info("   \u2705 Application routes registered");
  } catch (error) {
    logger.error("   \u274C Failed to register application routes:", {
      message: error.message,
      stack: error.stack
    });
    throw error;
  }
  logger.info("\n\u2705 All routes mounted successfully\n");
}

// server/bootstrap.ts
async function bootstrap() {
  logger.info("");
  logger.info("================================================== ");
  logger.info("\u{1F680} BOOTSTRAPPING APPLICATION");
  logger.info("================================================== \n");
  const app = express2();
  const server = createServer2(app);
  logger.info("STEP 1: Load and validate configuration");
  logger.info("--------------------------------------------------");
  const config2 = initConfig();
  if (config2.isProduction) {
    app.set("trust proxy", 1);
    logger.info("   \u2705 Proxy trust configured (1 hop for Replit)");
  }
  logger.info("\nSTEP 2: Initialize monitoring");
  logger.info("--------------------------------------------------");
  initSentry(app);
  initPostHog();
  logger.info("\nSTEP 3: Configure security middleware");
  logger.info("--------------------------------------------------");
  const helmetConfig = config2.isProduction ? {
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
        fontSrc: ["'self'", "https://fonts.gstatic.com"],
        imgSrc: ["'self'", "data:", "https:", "blob:"],
        scriptSrc: ["'self'"],
        connectSrc: ["'self'", "wss:", "ws:"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'none'"]
      }
    },
    crossOriginEmbedderPolicy: false
  } : {
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
        fontSrc: ["'self'", "https://fonts.gstatic.com"],
        imgSrc: ["'self'", "data:", "https:", "blob:"],
        scriptSrc: ["'self'", "'unsafe-inline'"],
        connectSrc: ["'self'", "wss:", "ws:"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'none'"]
      }
    },
    crossOriginEmbedderPolicy: false
  };
  app.use(helmet(helmetConfig));
  logger.info("   \u2705 Helmet configured");
  const corsOrigins = config2.isProduction ? config2.replitDomains.map((d) => `https://${d}`) : true;
  app.use(cors({
    origin: corsOrigins,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"]
  }));
  logger.info("   \u2705 CORS configured");
  logger.info(`   - Origins: ${config2.isProduction ? corsOrigins : "all (development)"}`);
  logger.info("\nSTEP 4: Configure body parsing");
  logger.info("--------------------------------------------------");
  app.use(express2.json({ limit: "10mb" }));
  app.use(express2.urlencoded({ extended: false, limit: "10mb" }));
  logger.info("   \u2705 Body parsers configured");
  app.use(requestLogger);
  logger.info("   \u2705 Request logger configured");
  logger.info("\nSTEP 5: Connect to database");
  logger.info("--------------------------------------------------");
  try {
    await initializeDatabasePool(config2.databaseUrl);
    await connectDatabaseWithRetry(config2.databaseUrl, 3);
  } catch (error) {
    logger.error("\u274C FATAL: Database connection failed:", {
      message: error.message,
      stack: error.stack
    });
    throw error;
  }
  logger.info("\nSTEP 6: Setup metrics");
  logger.info("--------------------------------------------------");
  const { setupMetrics: setupMetrics2 } = await Promise.resolve().then(() => (init_metrics(), metrics_exports));
  setupMetrics2(app);
  logger.info("   \u2705 Metrics configured");
  logger.info("\nSTEP 7: Initialize session store");
  logger.info("--------------------------------------------------");
  const { middleware: sessionMiddleware, storeType } = await initializeSession(config2);
  app.use(sessionMiddleware);
  logger.info(`   \u2705 Session middleware configured (${storeType} store)`);
  logger.info("\nSTEP 8: Initialize authentication");
  logger.info("--------------------------------------------------");
  await initializeAuth(config2);
  app.use(passport4.initialize());
  logger.info("   \u2705 Passport initialized");
  app.use(passport4.session());
  logger.info("   \u2705 Passport session enabled");
  const { autoExtendSession: autoExtendSession2, checkSessionExpiry: checkSessionExpiry2 } = await Promise.resolve().then(() => (init_sessionExtension(), sessionExtension_exports));
  app.use(autoExtendSession2);
  app.use(checkSessionExpiry2);
  logger.info("   \u2705 Session auto-extension enabled");
  logger.info("   \u2705 Session expiry warnings enabled");
  const { oauthStateRecoveryMiddleware: oauthStateRecoveryMiddleware2, cleanupExpiredOAuthAttempts: cleanupExpiredOAuthAttempts2 } = await Promise.resolve().then(() => (init_oauthStateRecovery(), oauthStateRecovery_exports));
  app.use(cleanupExpiredOAuthAttempts2);
  app.use(oauthStateRecoveryMiddleware2);
  logger.info("   \u2705 OAuth state recovery enabled");
  logger.info("   \u2705 Authentication system ready");
  logger.info("\nSTEP 9: Mount all routes");
  logger.info("--------------------------------------------------");
  await mountRoutes(app);
  logger.info("   \u2705 Routes mounted successfully");
  logger.info("\nSTEP 10: Setup error handling");
  logger.info("--------------------------------------------------");
  setupErrorHandling(app);
  logger.info("   \u2705 Error handlers configured");
  logger.info("\n================================================== ");
  logger.info("\u2705 BOOTSTRAP COMPLETE");
  logger.info("================================================== \n");
  return { app, server, config: config2 };
}

// server/vite.ts
import express3 from "express";
import fs3 from "fs";
import path5 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path4 from "path";
import { fileURLToPath } from "url";
import { VitePWA } from "vite-plugin-pwa";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path4.dirname(__filename);
var isTest = process.env.NODE_ENV === "test";
var isDev = process.env.NODE_ENV === "development";
var vite_config_default = defineConfig({
  root: "./client",
  plugins: [
    react(),
    // PWA Support - DISABLED IN DEVELOPMENT
    VitePWA({
      disable: isDev,
      registerType: "autoUpdate",
      includeAssets: ["favicon.ico", "apple-touch-icon.png", "masked-icon.svg"],
      manifest: {
        name: "Florida Local Elite",
        short_name: "FL Elite",
        description: "Florida's premier business networking platform",
        theme_color: "#0ea5e9",
        background_color: "#ffffff",
        display: "standalone",
        icons: [
          {
            src: "pwa-192x192.png",
            sizes: "192x192",
            type: "image/png"
          },
          {
            src: "pwa-512x512.png",
            sizes: "512x512",
            type: "image/png"
          }
        ]
      },
      workbox: {
        globPatterns: ["**/*.{js,css,html,ico,svg,woff2}"],
        // Increase file size limit to 10MB for large assets
        maximumFileSizeToCacheInBytes: 10 * 1024 * 1024,
        // Exclude florida-local images from precaching (use runtime caching instead)
        globIgnores: ["**/florida-local/**"],
        // CRITICAL: Exclude API routes from NavigationRoute fallback
        // This ensures /api/* and /auth/* requests reach the server instead of serving index.html
        navigateFallbackDenylist: [
          /^\/api\//,
          // Exclude all /api/* routes (authentication, data)
          /^\/auth\//,
          // Exclude all /auth/* routes
          /^\/metrics/
          // Exclude metrics endpoint
        ],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\./,
            handler: "NetworkFirst",
            options: {
              cacheName: "api-cache",
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 300
                // 5 minutes
              }
            }
          },
          {
            urlPattern: /\.(png|jpg|jpeg|svg|webp)$/,
            handler: "CacheFirst",
            options: {
              cacheName: "image-cache",
              expiration: {
                maxEntries: 200,
                maxAgeSeconds: 30 * 24 * 60 * 60
                // 30 days
              }
            }
          },
          {
            // Runtime caching for florida-local images
            urlPattern: /\/florida-local\/.*/,
            handler: "CacheFirst",
            options: {
              cacheName: "florida-local-cache",
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 60 * 24 * 60 * 60
                // 60 days
              }
            }
          }
        ]
      }
    })
  ],
  resolve: {
    alias: {
      "@": path4.resolve(__dirname, "./client/src"),
      "@assets": path4.resolve(__dirname, "./client/src/assets"),
      "@shared": path4.resolve(__dirname, "./shared")
    }
  },
  build: {
    target: "es2020",
    cssTarget: "chrome80",
    minify: "terser",
    sourcemap: false,
    commonjsOptions: {
      transformMixedEsModules: true
    },
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
        pure_funcs: ["console.log", "console.info", "console.debug", "console.trace"]
      }
    },
    rollupOptions: {
      treeshake: {
        moduleSideEffects: "no-external",
        propertyReadSideEffects: false,
        unknownGlobalSideEffects: false
      },
      output: {
        manualChunks: {
          // Vendor chunks
          "react-vendor": ["react", "react-dom", "react-hook-form"],
          "ui-vendor": ["@radix-ui/react-accordion", "@radix-ui/react-alert-dialog", "@radix-ui/react-avatar"],
          "utils-vendor": ["clsx", "tailwind-merge", "date-fns", "zod"],
          "query-vendor": ["@tanstack/react-query"],
          "animation-vendor": ["framer-motion"],
          // Feature chunks
          "auth": ["./client/src/hooks/useAuth.ts"],
          "business": ["./client/src/pages/business-profile.tsx", "./client/src/pages/create-business.tsx"],
          "marketplace": ["./client/src/pages/marketplace.tsx", "./client/src/components/product-card.tsx"],
          "checkout": ["./client/src/pages/checkout.tsx", "./client/src/pages/cart.tsx"]
        },
        chunkFileNames: (chunkInfo) => {
          const facadeModuleId = chunkInfo.facadeModuleId ? chunkInfo.facadeModuleId.split("/").pop() : "chunk";
          return `assets/js/${facadeModuleId}-[hash].js`;
        },
        assetFileNames: (assetInfo) => {
          const extType = assetInfo.name?.split(".").at(1);
          if (/png|jpe?g|svg|gif|tiff|bmp|ico/i.test(extType || "")) {
            return `assets/images/[name]-[hash][extname]`;
          }
          if (/woff|woff2|eot|ttf|otf/i.test(extType || "")) {
            return `assets/fonts/[name]-[hash][extname]`;
          }
          return `assets/[ext]/[name]-[hash][extname]`;
        }
      }
    },
    reportCompressedSize: false,
    chunkSizeWarningLimit: 1e3
  },
  optimizeDeps: {
    include: ["react", "react-dom", "@tanstack/react-query"],
    exclude: ["@vite/client", "@vite/env"],
    esbuildOptions: {
      target: "es2020"
    }
  },
  server: {
    host: "0.0.0.0",
    // CRITICAL: Allow external connections from Replit
    port: 5e3,
    strictPort: true,
    hmr: {
      overlay: false
    }
  },
  // @ts-ignore - test config is for vitest
  test: {
    globals: true,
    environment: "happy-dom",
    setupFiles: ["./client/src/__tests__/setup.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html", "lcov"],
      reportsDirectory: "./coverage/client",
      exclude: [
        "node_modules/",
        "client/src/__tests__/",
        "**/*.d.ts",
        "**/*.config.*",
        "**/mockData",
        "dist/"
      ],
      thresholds: {
        lines: 70,
        functions: 70,
        branches: 70,
        statements: 70
      }
    }
  }
});

// server/vite.ts
import { nanoid as nanoid2 } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app.get("/sw.js", (req, res) => {
    res.status(404).type("text/javascript").send("// Service worker disabled in development");
    log("Blocked service worker request in development mode");
  });
  const videosPath = path5.resolve(import.meta.dirname, "..", "client", "public", "Videos");
  if (fs3.existsSync(videosPath)) {
    app.use("/Videos", express3.static(videosPath));
    log(`\u{1F4F9} Serving videos from: ${videosPath}`, "videos");
  }
  const assetsPath = path5.resolve(import.meta.dirname, "..", "client", "public", "attached_assets");
  if (fs3.existsSync(assetsPath)) {
    app.use("/attached_assets", express3.static(assetsPath));
    log(`\u{1F4CE} Serving attached assets from: ${assetsPath}`, "assets");
  }
  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    if (url.startsWith("/api/") || url.startsWith("/auth/") || url.startsWith("/metrics")) {
      return next();
    }
    try {
      const clientTemplate = path5.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs3.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid2()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app) {
  const distPath = path5.resolve(import.meta.dirname, "public");
  if (!fs3.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  log(`\u{1F4C1} Serving static files from: ${distPath}`, "static");
  const videosPath = path5.join(distPath, "Videos");
  if (fs3.existsSync(videosPath)) {
    app.use("/Videos", express3.static(videosPath, {
      maxAge: "1y",
      // Cache videos for 1 year
      setHeaders: (res, filePath) => {
        if (filePath.endsWith(".mov")) {
          res.setHeader("Content-Type", "video/quicktime");
        } else if (filePath.endsWith(".mp4")) {
          res.setHeader("Content-Type", "video/mp4");
        } else if (filePath.endsWith(".webm")) {
          res.setHeader("Content-Type", "video/webm");
        }
      }
    }));
    log(`\u{1F4F9} Serving videos from: ${videosPath}`, "videos");
    const videoFiles = fs3.readdirSync(videosPath).filter(
      (f) => /\.(mov|mp4|webm|avi)$/i.test(f)
    );
    log(`   Found ${videoFiles.length} video files: ${videoFiles.join(", ")}`, "videos");
  } else {
    log(`\u26A0\uFE0F  Videos folder not found at: ${videosPath}`, "videos");
  }
  app.use((req, res, next) => {
    const url = req.originalUrl;
    if (url.startsWith("/api/") || url.startsWith("/auth/") || url.startsWith("/metrics")) {
      log(`\u26A1 Skipping static serving for: ${url}`, "static");
      return next();
    }
    log(`\u{1F4C4} Checking static file: ${url}`, "static");
    next();
  });
  app.use(express3.static(distPath));
  app.use("*", (req, res, next) => {
    const url = req.originalUrl;
    if (url.startsWith("/api/") || url.startsWith("/auth/") || url.startsWith("/metrics")) {
      log(`\u26A1 Skipping index.html fallback for: ${url}`, "static");
      return next();
    }
    log(`\u{1F3E0} Serving index.html for: ${url}`, "static");
    res.sendFile(path5.resolve(distPath, "index.html"));
  });
}

// server/index.ts
init_monitoring();
init_db();
init_redis();
async function startServer() {
  try {
    const { app, server, config: config2 } = await bootstrap();
    logger.info("\nSTEP 11: Setup frontend serving");
    logger.info("--------------------------------------------------");
    if (config2.isProduction) {
      logger.info("   - Production mode: Setting up static file serving");
      serveStatic(app);
      logger.info("   \u2705 Static file serving configured");
    } else {
      logger.info("   - Development mode: Setting up Vite dev server");
      await setupVite(app, server);
      logger.info("   \u2705 Vite dev server configured");
    }
    logger.info("\nSTEP 12: Start HTTP server");
    logger.info("--------------------------------------------------");
    server.listen(config2.port, "0.0.0.0", () => {
      logger.info("");
      logger.info("================================================== ");
      logger.info("\u{1F389} SERVER STARTED SUCCESSFULLY");
      logger.info("================================================== ");
      logger.info(`   - Environment: ${config2.nodeEnv}`);
      logger.info(`   - Port: ${config2.port}`);
      logger.info(`   - URL: http://0.0.0.0:${config2.port}`);
      if (config2.isProduction) {
        logger.info(`   - Production URLs: ${config2.replitDomains.map((d) => `https://${d}`).join(", ")}`);
      }
      logger.info("================================================== \n");
    });
  } catch (error) {
    logger.error("");
    logger.error("================================================== ");
    logger.error("\u274C SERVER STARTUP FAILED");
    logger.error("================================================== ");
    logger.error("Error:", {
      message: error.message,
      stack: error.stack
    });
    logger.error("================================================== \n");
    process.exit(1);
  }
}
async function gracefulShutdown() {
  logger.info("");
  logger.info("\u{1F6D1} Graceful shutdown initiated...");
  try {
    await closeDatabaseConnection();
    await closeRedisConnections();
    logger.info("\u2705 Cleanup complete");
    process.exit(0);
  } catch (error) {
    logger.error("\u274C Shutdown error:", error);
    process.exit(1);
  }
}
process.on("SIGTERM", gracefulShutdown);
process.on("SIGINT", gracefulShutdown);
process.on("unhandledRejection", (reason, promise) => {
  logger.error("\u274C Unhandled Promise Rejection:", {
    reason,
    promise
  });
});
process.on("uncaughtException", (error) => {
  logger.error("\u274C Uncaught Exception:", {
    message: error.message,
    stack: error.stack
  });
  gracefulShutdown();
});
startServer();
